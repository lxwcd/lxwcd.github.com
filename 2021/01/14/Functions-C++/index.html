

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="C++ Primer(Fifth Edition) Chapter 6 Functions">
  <meta name="author" content="李诩">
  <meta name="keywords" content="编程, 阅读, 音乐, 生活">
  
  <title>Functions - CD_LX</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lxwcd.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":4},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"cfOIMBd6tuDTv7dOXC9Iy3NQ-gzGzoHsz","app_key":"5oQLiMeBUSIe3XsUFbQRh5m5","server_url":"https://cfoimbd6.lc-cn-n1-shared.com"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/Functions-C++_Inner.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Functions">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      李诩
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-14 19:57" pubdate>
        January 14, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      79
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Functions</h1>
            
            <div class="markdown-body">
              <p>C++ Primer(Fifth Edition) Chapter 6 Functions</p>
<a id="more"></a>
<h1 id="1-Function-Basics"><a href="#1-Function-Basics" class="headerlink" title="1. Function Basics"></a>1. Function Basics</h1><p><strong>Arguments</strong> are the <strong>initializers</strong> for a function’s <strong>parameters</strong>.</p>
<p>Although we know which argument initializes which parameter, we have no guarantees about the order in which arguments are evaluated. </p>
<p>The compiler is free to evaluate the arguments in whatever order it prefers.</p>
<p>We must pass exactly <strong>the same number</strong> of arguments as the function has parameters.</p>
<p>Because every call is guaranteed to pass as many arguments as the function has parameters, <strong>parameters are always initialized</strong>.</p>
<h1 id="2-Argument-Passing"><a href="#2-Argument-Passing" class="headerlink" title="2. Argument Passing"></a>2. Argument Passing</h1><h2 id="1-const-Parameters-and-Arguments"><a href="#1-const-Parameters-and-Arguments" class="headerlink" title="(1) const Parameters and Arguments"></a>(1) const Parameters and Arguments</h2><p>We can initialize an object with a <strong>low-level const</strong> from a <strong>nonconst object</strong> but <strong>not vice</strong> versa, and a <strong>plain reference</strong> must be initialized from an object of the <strong>same type</strong>.  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *cp = &amp;i; <span class="hljs-comment">// ok: but cp can't change i (§ 2.4.2 (p. 62))</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r = i; <span class="hljs-comment">// ok: but r can't change i (§ 2.4.1 (p. 61))</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// ok</span><br><span class="hljs-keyword">int</span> *p = cp; <span class="hljs-comment">// error: types of p and cp don't match </span><br><span class="hljs-keyword">int</span> &amp;r3 = r; <span class="hljs-comment">// error: types of r3 and r don't match </span><br><span class="hljs-keyword">int</span> &amp;r4 = <span class="hljs-number">42</span>; <span class="hljs-comment">// error: can't initialize a plain reference from a literal</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;i)</span> </span><br><span class="hljs-function"></span>&#123;<br>    i = <span class="hljs-number">0</span>; <br>&#125;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i;<br><span class="hljs-built_in">string</span>::size_type ctr = <span class="hljs-number">0</span>;<br>reset(&amp;i); <span class="hljs-comment">// calls the version of reset that has an int* parameter</span><br><span class="hljs-comment">// error: can't initialize an int* from a pointer to a const int object</span><br>reset(&amp;ci); <br>reset(i); <span class="hljs-comment">// calls the version of reset that has an int&amp; parameter</span><br>reset(ci); <span class="hljs-comment">// error: can't bind a plain reference to the const object ci</span><br>reset(<span class="hljs-number">42</span>); <span class="hljs-comment">// error: can't bind a plain reference to a literal</span><br>reset(ctr); <span class="hljs-comment">// error: types don't match; ctr has an unsigned type</span><br><span class="hljs-comment">// ok: find_char's first parameter is a reference to const</span><br>find_char(<span class="hljs-string">"Hello World!"</span>, <span class="hljs-string">'o'</span>, ctr);<br></code></pre></td></tr></table></figure>
<p><strong>We cannot pass a const object, or a literal, or an object that requires conversion to a plain reference parameter.</strong></p>
<h2 id="2-Varying-Parameters"><a href="#2-Varying-Parameters" class="headerlink" title="(2) Varying Parameters"></a>(2) Varying Parameters</h2><h3 id="initializer-list-Parameters"><a href="#initializer-list-Parameters" class="headerlink" title="initializer_list Parameters"></a>initializer_list Parameters</h3><p><a href="http://www.cplusplus.com/reference/initializer_list/initializer_list/?kw=initializer_list" target="_blank" rel="noopener">std::initializer_list</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/initializer_list" target="_blank" rel="noopener">std::initializer_list<T> </a></p>
<p>We can write a function that takes an <strong>unknown number of arguments</strong> of a <strong>single type</strong> by using an <strong>initializer_list</strong> parameter.</p>
<p>An <strong>initializer_list</strong> is a <strong>library type</strong> that represents an <strong>array</strong> of values of the <strong>specified type</strong>. </p>
<p>This type is defined in the <strong>initializer_list header</strong>.</p>
<p><img src="https://img-blog.csdnimg.cn/20200202140027499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述">Like a vector, <code>initializer_list</code> is a <strong>template type</strong>. </p>
<p>When we define an <code>initializer_list</code>, we must specify the type of the elements that the list will contain:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-built_in">string</span>&gt; ls; <span class="hljs-comment">// initializer_list of strings</span><br><span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-keyword">int</span>&gt; li; <span class="hljs-comment">// initializer_list of ints</span><br></code></pre></td></tr></table></figure>
<p>Unlike <code>vector</code>, the elements in an <code>initializer_list</code> are always <strong>const values</strong>; there is no way to change the value of an element in an <code>initializer_list</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_msg</span><span class="hljs-params">(<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-built_in">string</span>&gt; il)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> beg = il.begin(); beg != il.end(); ++beg)<br>    <span class="hljs-built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="hljs-string">" "</span> ;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>When we pass <strong>a sequence of values</strong> to an initializer_list parameter, we must enclose the sequence in <strong>curly braces</strong>:</p>
<p>A function with an <code>initializer_list</code> parameter can have other parameters as well. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (expected != actual)<br>    error_msg(ErrCode(<span class="hljs-number">42</span>), &#123;<span class="hljs-string">"functionX"</span>, expected, actual&#125;);<br><span class="hljs-keyword">else</span><br>    error_msg(ErrCode(<span class="hljs-number">0</span>), &#123;<span class="hljs-string">"functionX"</span>, <span class="hljs-string">"okay"</span>&#125;);<br></code></pre></td></tr></table></figure>
<h2 id="Ellipsis-Parameters"><a href="#Ellipsis-Parameters" class="headerlink" title="Ellipsis Parameters"></a>Ellipsis Parameters</h2><p>Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named <code>varargs</code>. </p>
<p>An ellipsis parameter may appear only as the last element in a parameter list and may take either of two forms:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(parm_list, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(...)</span></span>;<br></code></pre></td></tr></table></figure>
<h1 id="3-Return-Types-and-the-return-Statement"><a href="#3-Return-Types-and-the-return-Statement" class="headerlink" title="3. Return Types and the return Statement"></a>3. Return Types and the return Statement</h1><h2 id="1-Reference-Returns-Are-Lvalues"><a href="#1-Reference-Returns-Are-Lvalues" class="headerlink" title="(1) Reference Returns Are Lvalues"></a>(1) Reference Returns Are Lvalues</h2><p>Calls to functions that <strong>return references</strong> are <strong>lvalues</strong>; <strong>other</strong> return types yield <strong>rvalues</strong>. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span> &amp;<span class="hljs-title">get_val</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;str, <span class="hljs-built_in">string</span>::size_type ix)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> str[ix]; <span class="hljs-comment">// get_val assumes the given index is valid</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"a value"</span>)</span></span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// prints a value</span><br>    get_val(s, <span class="hljs-number">0</span>) = <span class="hljs-string">'A'</span>; <span class="hljs-comment">// changes s[0] to A</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// prints A value</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-List-Initializing-the-Return-Value"><a href="#2-List-Initializing-the-Return-Value" class="headerlink" title="(2) List Initializing the Return Value"></a>(2) List Initializing the Return Value</h2><p>As in any other <code>return</code>, the list is used to initialize the temporary that represents the function’s return.</p>
<p>If the list is empty, that temporary is value initialized.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// . . .</span><br><span class="hljs-comment">// expected and actual are strings</span><br><span class="hljs-keyword">if</span> (expected.empty())<br>    <span class="hljs-keyword">return</span> &#123;&#125;; <span class="hljs-comment">// return an empty vector</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expected == actual)<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">"functionX"</span>, <span class="hljs-string">"okay"</span>&#125;; <span class="hljs-comment">// return list-initialized vector</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">"functionX"</span>, expected, actual&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-Declaring-a-Function-That-Returns-a-Pointer-to-an-Array"><a href="#3-Declaring-a-Function-That-Returns-a-Pointer-to-an-Array" class="headerlink" title="(3) Declaring a Function That Returns a Pointer to an Array"></a>(3) Declaring a Function That Returns a Pointer to an Array</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Type</span> (*<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(parameter_list)</span></span>)[<span class="hljs-keyword">dimension</span>]<br></code></pre></td></tr></table></figure>
<p>As a concrete example, the following declares <code>func</code> without using a type alias:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">int</span> (*<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span>)[10];</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>func(int) says that we can call func with an int argument.</p>
</li>
<li><p>(*func(int)) says we can dereference the result of that call.</p>
</li>
<li><p>(*func(int))[10] says that dereferencing the result of a call to func yields an array of size ten.</p>
</li>
<li><p>int (*func(int))[10] says the element type in that array is int.</p>
</li>
</ul>
<h2 id="4-Using-a-Trailing-Return-Type"><a href="#4-Using-a-Trailing-Return-Type" class="headerlink" title="(4) Using a Trailing Return Type"></a>(4) Using a Trailing Return Type</h2><p><strong>Trailing returns</strong> can be defined for any function, but are most<br>useful for functions with <strong>complicated return</strong> types, such as pointers (or references) to arrays. </p>
<p>A trailing return type follows the parameter list and is preceded by <code>-&gt;</code>. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// fcn takes an int argument and returns a pointer to an array of ten ints</span><br>auto func(int i) -&gt; int(*)[10];<br></code></pre></td></tr></table></figure>
<h2 id="5-Using-decltype"><a href="#5-Using-decltype" class="headerlink" title="(5) Using decltype"></a>(5) Using decltype</h2><p>As another alternative, if we know the array(s) to which our function can return a pointer, we can use <strong>decltype</strong> to declare the return type.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> odd[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">int</span> even[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-comment">// returns a pointer to an array of five int elements</span><br><span class="hljs-keyword">decltype</span>(odd) *arrPtr(<span class="hljs-keyword">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span>) ? &amp;odd : &amp;even; <span class="hljs-comment">// returns a pointer to the array</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>The return type for <code>arrPtr</code> uses <code>decltype</code> to say that the function returns a pointer to whatever type <code>odd</code> has. </p>
<p>The only tricky part is that we must remember that <strong>decltype does not automatically convert an array to its corresponding pointer type</strong>. </p>
<h1 id="4-Overloaded-Functions"><a href="#4-Overloaded-Functions" class="headerlink" title="4. Overloaded Functions"></a>4. Overloaded Functions</h1><p>Functions that have the <strong>same name</strong> but <strong>different parameter lists</strong> and that appear in the <strong>same scope</strong> are <strong>overloaded</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *beg, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *end)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[], <span class="hljs-keyword">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure>
<p>We should only overload operations that actually do <strong>similar things</strong>. </p>
<h2 id="1-Defining-Overloaded-Functions"><a href="#1-Defining-Overloaded-Functions" class="headerlink" title="(1) Defining Overloaded Functions"></a>(1) Defining Overloaded Functions</h2><p>It is an <strong>error</strong> for two functions to <strong>differ only</strong> in terms of their <strong>return types</strong>. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// each pair declares the same function</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account &amp;acct)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>; <span class="hljs-comment">// parameter names are ignored</span><br><span class="hljs-keyword">typedef</span> Phone Telno;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Phone&amp;)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Telno&amp;)</span></span>; <span class="hljs-comment">// Telno and Phone are the same type</span><br></code></pre></td></tr></table></figure>
<h2 id="2-Overloading-and-const-Parameters"><a href="#2-Overloading-and-const-Parameters" class="headerlink" title="(2) Overloading and const Parameters"></a>(2) Overloading and const Parameters</h2><p>A parameter that has a <strong>top-level const</strong> is <strong>indistinguishable</strong> from one without a <strong>top-level const</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Phone)</span></span>; <span class="hljs-comment">// redeclares Record lookup(Phone)</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone*)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone* <span class="hljs-keyword">const</span>)</span></span>; <span class="hljs-comment">// redeclares Record lookup(Phone*)</span><br></code></pre></td></tr></table></figure>

<p><strong>On the other hand</strong>, we can overload based on whether the parameter is a reference (or pointer) to the <code>const</code> or <code>nonconst</code> version of a given type; such <code>consts</code> are <strong>low-level</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// functions taking const and nonconst references or pointers</span><br><span class="hljs-comment">// have different parameters</span><br><span class="hljs-comment">// declarations for four independent, overloaded functions</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account&amp;)</span></span>; <span class="hljs-comment">// function that takes a reference to Account</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>; <span class="hljs-comment">// new function that takes a const reference</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account*)</span></span>; <span class="hljs-comment">// new function, takes a pointer to Account</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account*)</span></span>; <span class="hljs-comment">// new function, takes a pointer to const</span><br></code></pre></td></tr></table></figure>
<h2 id="3-Overloading-and-Scope"><a href="#3-Overloading-and-Scope" class="headerlink" title="(3) Overloading and Scope"></a>(3) Overloading and Scope</h2><p>As usual, if we declare a name in an inner scope, that name hides uses of that name declared in an outer scope. Names do not overload across scopes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>; <span class="hljs-comment">// overloads the print function</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fooBar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ival)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span> read = <span class="hljs-literal">false</span>; <span class="hljs-comment">// new scope: hides the outer declaration of read</span><br>    <span class="hljs-built_in">string</span> s = read(); <span class="hljs-comment">// error: read is a bool variable, not a function</span><br>    <span class="hljs-comment">// bad practice: usually it's a bad idea to declare functions at local scope</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">// new scope: hides previous instances of print</span><br>    print(<span class="hljs-string">"Value: "</span>); <span class="hljs-comment">// error: print(const string &amp;) is hidden</span><br>    print(ival); <span class="hljs-comment">// ok: print(int) is visible</span><br>    print(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// ok: calls print(int); print(double) is hidden</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>In C++, name lookup happens before type checking.</p>
<h1 id="5-Default-Arguments"><a href="#5-Default-Arguments" class="headerlink" title="5. Default Arguments"></a>5. Default Arguments</h1><p>Some functions have parameters that are given a particular value in most, but not all, calls. </p>
<p>In such cases, we can declare that common value as a <strong>default argument</strong> for the function. </p>
<p>Functions with default arguments can be called <strong>with or without</strong> that argument.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">string</span>::size_type sz; <span class="hljs-comment">// typedef see § 2.5.1 (p. 67)</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz ht = <span class="hljs-number">24</span>, sz wid = <span class="hljs-number">80</span>, <span class="hljs-keyword">char</span> backgrnd = <span class="hljs-string">' '</span>)</span></span>;<br></code></pre></td></tr></table></figure>
<p>A default argument is specified as an <strong>initializer</strong> for a parameter in the <strong>parameter list</strong>. </p>
<p>We may define defaults for <strong>one or more</strong> parameters. </p>
<p>However, if a parameter has a default argument, all the parameters that <strong>follow it</strong> must also have default arguments.</p>
<p>Because screen provides defaults for all of its parameters, we can call screen with zero, one, two, or three arguments:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> window;<br>window = screen(); <span class="hljs-comment">// equivalent to screen(24,80,' ')</span><br>window = screen(<span class="hljs-number">66</span>);<span class="hljs-comment">// equivalent to screen(66,80,' ')</span><br>window = screen(<span class="hljs-number">66</span>, <span class="hljs-number">256</span>); <span class="hljs-comment">// screen(66,256,' ')</span><br>window = screen(<span class="hljs-number">66</span>, <span class="hljs-number">256</span>, <span class="hljs-string">'#'</span>); <span class="hljs-comment">// screen(66,256,'#')</span><br></code></pre></td></tr></table></figure>
<p>Arguments in the call are resolved by position. The default arguments are used for the trailing (right-most) arguments of a call. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">window = screen(, , <span class="hljs-string">'?'</span>); <span class="hljs-comment">// error: can omit only trailing arguments</span><br>window = screen(<span class="hljs-string">'?'</span>); <span class="hljs-comment">// calls screen('?',80,' ')</span><br></code></pre></td></tr></table></figure>
<p>In this call, the char argument is implicitly converted to string::size_type, and is passed as the argument to height. </p>
<h2 id="1-Default-Argument-Declarations"><a href="#1-Default-Argument-Declarations" class="headerlink" title="(1) Default Argument Declarations"></a>(1) Default Argument Declarations</h2><p>Although it is normal practice to declare a function once inside a header, it is legal to <strong>redeclare a function multiple times</strong>. </p>
<p>However, each parameter can have its <strong>default specified only once</strong> in a <strong>given scope</strong>. </p>
<p>Any subsequent declaration can add a default only for a parameter that has not previously had a default specified.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// no default for the height or width parameters</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz, sz, <span class="hljs-keyword">char</span> = <span class="hljs-string">' '</span>)</span></span>;<br></code></pre></td></tr></table></figure>
<p>we cannot change an already declared default value:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz, sz, <span class="hljs-keyword">char</span> = <span class="hljs-string">'*'</span>)</span></span>; <span class="hljs-comment">// error: redeclaration</span><br></code></pre></td></tr></table></figure>
<p>but we can add a default argument as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz = <span class="hljs-number">24</span>, sz = <span class="hljs-number">80</span>, <span class="hljs-keyword">char</span>)</span></span>; <span class="hljs-comment">// ok: adds default</span><br></code></pre></td></tr></table></figure>
<h1 id="6-Inline-and-constexpr-Functions"><a href="#6-Inline-and-constexpr-Functions" class="headerlink" title="6. Inline and constexpr Functions"></a>6. Inline and constexpr Functions</h1><h2 id="1-inline-Functions"><a href="#1-inline-Functions" class="headerlink" title="(1)  inline Functions"></a>(1)  inline Functions</h2><p>A function specified as inline (usually) is expanded “<strong>in line</strong>” at each call. </p>
<p>In an inline function, the compiled code is “in line” with the other code in the program. </p>
<p>That is, the compiler <strong>replaces the function call</strong> with the <strong>corresponding function code</strong>.</p>
<p>With inline code, the program doesn’t have to jump to another location to execute the code and then jump back. </p>
<p>Inline functions thus run a little <strong>faster</strong> than regular functions, but they come with a <strong>memory penalty</strong>. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// inline.cpp -- using an inline function</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// an inline function definition</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br>    <span class="hljs-keyword">double</span> a, b;<br>    <span class="hljs-keyword">double</span> c = <span class="hljs-number">13.0</span>;<br>    a = square(<span class="hljs-number">5.0</span>);<br>    b = square(<span class="hljs-number">4.5</span> + <span class="hljs-number">7.5</span>); <span class="hljs-comment">// can pass expressions</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>The inline specification is <strong>only a request to the compiler</strong>. The compiler may choose to ignore this request.</p>
<h2 id="2-constexpr-Functions"><a href="#2-constexpr-Functions" class="headerlink" title="(2) constexpr Functions"></a>(2) constexpr Functions</h2><p><a href="https://en.cppreference.com/w/cpp/language/constexpr" target="_blank" rel="noopener">constexpr specifier</a></p>
<p>A <strong>constexpr</strong> function is a function that can be used in a constant expression.</p>
<p>A <strong>constexpr</strong> function is defined like any other function but must meet certain <strong>restrictions</strong>:<br>The <strong>return type</strong> and the type of each parameter in a must be a <a href="https://en.cppreference.com/w/cpp/named_req/LiteralType" target="_blank" rel="noopener">literal type</a>, and the <strong>function body</strong> must contain exactly one return statement:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> foo = new_sz(); <span class="hljs-comment">// ok: foo is a constant expression</span><br></code></pre></td></tr></table></figure>
<p>Here we defined <code>new_sz</code> as a <strong>constexpr</strong> that takes no arguments. </p>
<p>The compiler can verify at compile time that a call to <code>new_sz</code> returns a constant expression, so we can use <code>new_sz</code> to initialize our <strong>constexpr variable</strong> <code>foo</code>.</p>
<p>When it can do so, the compiler will replace a call to a <strong>constexpr</strong> function with its resulting value. </p>
<p>In order to be able to expand the function immediately, <strong>constexpr</strong> functions are <strong>implicitly inline</strong>.</p>
<p>A <strong>constexpr function body</strong> may contain other statements so long as those statements <strong>generate no actions at run time</strong>.</p>
<p>A <strong>constexpr function</strong> is permitted to <strong>return</strong> a value that is not a constant:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// scale(arg) is a constant expression if arg is a constant expression</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> cnt)</span> </span>&#123; <span class="hljs-keyword">return</span> new_sz() * cnt; &#125;<br></code></pre></td></tr></table></figure>
<p>The scale function will return a constant expression if its argument is a constant expression but not otherwise:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> arr[scale(<span class="hljs-number">2</span>)]; <span class="hljs-comment">// ok: scale(2) is a constant expression</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; <span class="hljs-comment">// i is not a constant expression</span><br><span class="hljs-keyword">int</span> a2[scale(i)]; <span class="hljs-comment">// error: scale(i) is not a constant expression</span><br></code></pre></td></tr></table></figure>
<h2 id="3-Put-inline-and-constexpr-Functions-in-Header-Files"><a href="#3-Put-inline-and-constexpr-Functions-in-Header-Files" class="headerlink" title="(3) Put inline and constexpr Functions in Header Files"></a>(3) Put inline and constexpr Functions in Header Files</h2><p>Unlike other functions, <strong>inline</strong> and <strong>constexpr</strong> functions may be <strong>defined multiple times in the program</strong>. </p>
<p>After all, the compiler needs the definition, not just the declaration, in order to expand the code. </p>
<p>However, all of the definitions of a given <strong>inline</strong> or <strong>constexpr</strong> must match exactly. </p>
<p>As a result, <strong>inline</strong> and <strong>constexpr</strong> functions normally are defined in <strong>headers</strong>.</p>
<h1 id="7-Aids-for-Debugging"><a href="#7-Aids-for-Debugging" class="headerlink" title="7. Aids for Debugging"></a>7. Aids for Debugging</h1><p>C++ programmers sometimes use a technique similar to header guards to <strong>conditionally</strong> execute <strong>debugging code</strong>. </p>
<p>The idea is that the program will <strong>contain debugging code</strong> that is executed <strong>only</strong> while the program is being developed. </p>
<p>When the application is <strong>completed</strong> and ready to ship, the debugging code is <strong>turned off</strong>. </p>
<p>This approach uses two <strong>preprocessor</strong> facilities: <strong>assert</strong> and <strong>NDEBUG</strong>.</p>
<h2 id="1-The-assert-Preprocessor-Macro"><a href="#1-The-assert-Preprocessor-Macro" class="headerlink" title="(1) The assert Preprocessor Macro"></a>(1) The assert Preprocessor Macro</h2><p><strong>assert</strong> is a <strong>preprocessor macro</strong>. </p>
<p>A <strong>preprocessor macro</strong> is a <strong>preprocessor variable</strong> that acts somewhat like an <strong>inline function</strong>. </p>
<p>The <strong>assert macro</strong> takes a <strong>single expression</strong>, which it uses as a <strong>condition</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">assert(expr);<br></code></pre></td></tr></table></figure>
<p>evaluates <code>expr</code> and if the expression is <strong>false</strong> (i.e., zero), then <strong>assert</strong> writes a <strong>message</strong> and <strong>terminates the program</strong>. If the expression is <strong>true</strong> (i.e., is nonzero), then assert <strong>does nothing</strong>.</p>
<p>The <strong>assert macro</strong> is defined in the <strong>cassert</strong> header. </p>
<p>As we’ve seen, <code>preprocessor</code> names are managed by the <code>preprocessor</code> not the compiler. </p>
<p>As a result, we <strong>use preprocessor names</strong> <strong>directly</strong> and <strong>do not</strong> provide a <strong>using declaration</strong> for them. </p>
<p>As with <code>preprocessor</code> variables, macro names must be unique within the program.</p>
<p>The assert macro is often used to check for conditions that “cannot happen”.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">assert(word.size() &gt; threshold);<br></code></pre></td></tr></table></figure>

<h2 id="2-The-NDEBUG-Preprocessor-Variable"><a href="#2-The-NDEBUG-Preprocessor-Variable" class="headerlink" title="(2) The NDEBUG Preprocessor Variable"></a>(2) The NDEBUG Preprocessor Variable</h2><p>The <strong>behavior of assert</strong> depends on the <strong>status</strong> of a <strong>preprocessor variable</strong> named <strong>NDEBUG</strong>. </p>
<p>If <strong>NDEBUG</strong> is defined, assert does nothing. </p>
<p>By default, <strong>NDEBUG</strong> is <strong>not defined</strong>, so, by default, assert performs a <strong>run-time check</strong>.</p>
<p>We can “turn off” debugging by providing a <code>#define</code> to define <code>NDEBUG</code>.</p>
<p>Alternatively, most compilers provide a command-line option that lets us define preprocessor variables:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ CC -D NDEBUG main.C <span class="hljs-comment"># use /D with the Microsoft compiler</span><br></code></pre></td></tr></table></figure>
<p>has the same effect as writing <strong>#define NDEBUG</strong> at the beginning of main.C.</p>
<p>In addition to <strong>using assert</strong>, we can write our own conditional debugging code using NDEBUG. </p>
<p>If <strong>NDEBUG</strong> is not defined, the code between the <strong>#ifndef</strong> and the <strong>#endif</strong> is executed. </p>
<p>If <strong>NDEBUG</strong> is defined, that code is ignored:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[], <span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><br><span class="hljs-comment">// _ _func_ _ is a local static defined by the compiler that holds the function's name</span><br><span class="hljs-built_in">cerr</span> &lt;&lt; _ _func_ _ &lt;&lt; <span class="hljs-string">": array size is "</span> &lt;&lt; size &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>
<p>Here we use a variable named <code>_ _func_ _</code> to print the name of the function we are debugging. </p>
<p>The compiler defines <code>_ _func_ _</code> in every function. It is a local static array of const char that holds the name of the function.</p>
<p>In addition to <code>_ _func_ _</code>, which the C++ compiler defines, the preprocessor defines four other names that can be useful in debugging:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">_ _FILE_ _ <span class="hljs-keyword">string</span> literal containing <span class="hljs-keyword">the</span> name <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span><br>_ _LINE_ _ <span class="hljs-keyword">integer</span> literal containing <span class="hljs-keyword">the</span> current <span class="hljs-built_in">line</span> <span class="hljs-built_in">number</span><br>_ _TIME_ _ <span class="hljs-keyword">string</span> literal containing <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> was compiled<br>_ _DATE_ _ <span class="hljs-keyword">string</span> literal containing <span class="hljs-keyword">the</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> was compiled<br></code></pre></td></tr></table></figure>
<p>We might use these constants to report additional information in error messages:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (word.size() &lt; threshold)<br><span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: "</span> &lt;&lt; _ _FILE_ _<br>&lt;&lt; <span class="hljs-string">" : in function "</span> &lt;&lt; _ _func_ _<br>&lt;&lt; <span class="hljs-string">" at line "</span> &lt;&lt; _ _LINE_ _ &lt;&lt; <span class="hljs-built_in">endl</span><br>&lt;&lt; <span class="hljs-string">" Compiled on "</span> &lt;&lt; _ _DATE_ _<br>&lt;&lt; <span class="hljs-string">" at "</span> &lt;&lt; _ _TIME_ _ &lt;&lt; <span class="hljs-built_in">endl</span><br>&lt;&lt; <span class="hljs-string">" Word read was \""</span> &lt;&lt; word<br>&lt;&lt; <span class="hljs-string">"\": Length too short"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure>
<p>If we give this program a string that is shorter than the threshold, then the following error message will be generated:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Error: wdebug.cc : in function main at line <span class="hljs-number">27</span><br>Compiled on Jul <span class="hljs-number">11</span> <span class="hljs-number">2012</span> at <span class="hljs-number">20</span>:<span class="hljs-number">50</span>:<span class="hljs-number">03</span><br>Word read was <span class="hljs-string">"foo"</span>: Length too short<br></code></pre></td></tr></table></figure>
<h1 id="8-Function-Matching"><a href="#8-Function-Matching" class="headerlink" title="8. Function Matching"></a>8. Function Matching</h1><p>It is not so simple when the overloaded functions have the same number of parameters and when one or more of the parameters have types that are related by conversions. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span> = <span class="hljs-number">3.14</span>)</span></span>;<br>f(<span class="hljs-number">5.6</span>); <span class="hljs-comment">// calls void f(double, double)</span><br></code></pre></td></tr></table></figure>
<h2 id="1-Determining-the-Candidate-and-Viable-Functions"><a href="#1-Determining-the-Candidate-and-Viable-Functions" class="headerlink" title="(1) Determining the Candidate and Viable Functions"></a>(1) Determining the Candidate and Viable Functions</h2><p><strong>The first step</strong> of <strong>function matching</strong> identifies the set of overloaded functions considered for the call.</p>
<p>The functions in this set are the <strong>candidate functions</strong>.</p>
<p><strong>The second step</strong> selects from the set of candidate functions those functions that can be called with the arguments in the given call. </p>
<p>The selected functions are the <strong>viable functions</strong>. </p>
<p><strong>To be viable</strong>, a function must have the <strong>same number of parameters</strong> as there are arguments in the call, and the <strong>type</strong> of each argument must <strong>match</strong> or be <strong>convertible</strong> to the type of its <strong>corresponding parameter</strong>.</p>
<p><strong>When a function has default arguments, a call may appear to have fewer arguments than it actually does.</strong></p>
<p>If there are no viable functions, the compiler will complain that there is no matching function.</p>
<p><strong>The third step</strong> of function matching determines which viable function provides the <strong>best match</strong> for the call. </p>
<p>Function matching is more complicated if there are two or more arguments. </p>
<p>Given the same functions named <code>f</code>, let’s analyze the following call:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">f(<span class="hljs-number">42</span>, <span class="hljs-number">2.56</span>);<br></code></pre></td></tr></table></figure>
<p>In this case, the viable functions are <code>f(int, int)</code> and <code>f(double, double)</code>. </p>
<p>Considering <strong>only the first argument</strong>, <code>f(int, int)</code> is a better match than <code>f(double, double)</code>.</p>
<p>When we consider <strong>only the second parameter</strong>, the function <code>f(double, double)</code> is a better match.</p>
<p>The compiler will <strong>reject this call</strong> because it is <strong>ambiguous</strong>: Each viable function is a better match than the other on one of the arguments to the call. </p>
<p><strong>Note:</strong><br><strong>Casts should not be needed to call an overloaded function.</strong> The need for a cast suggests that the parameter sets are designed poorly.</p>
<h2 id="2-Argument-Type-Conversions"><a href="#2-Argument-Type-Conversions" class="headerlink" title="(2) Argument Type Conversions"></a>(2) Argument Type Conversions</h2><p>In order to <strong>determine the best match</strong>, the compiler <strong>ranks the conversions</strong> that could be used to convert each argument to the type of its corresponding parameter.</p>
<p>Conversions are ranked as follows:</p>
<h3 id="An-exact-match"><a href="#An-exact-match" class="headerlink" title="An exact match"></a>An exact match</h3><p>An exact match happens when:</p>
<ul>
<li><p>The argument and parameter types are identical.</p>
</li>
<li><p>The argument is converted from an <strong>array or function type</strong> to the corresponding <strong>pointer type</strong>. (covers function pointers.)</p>
</li>
<li><p>A top-level const is added to or discarded from the argument.</p>
<h3 id="Match-through-a-const-conversion"><a href="#Match-through-a-const-conversion" class="headerlink" title="Match through a const conversion"></a>Match through a const conversion</h3><p>When we call an overloaded function that differs on whether a <code>reference</code> or <code>pointer parameter</code> refers or points to <code>const</code>, the compiler uses the constness of the argument to decide which function to call:</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// function that takes a reference to Account</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account&amp;)</span></span>; <br><span class="hljs-comment">// new function that takes a const reference</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>; <br><span class="hljs-keyword">const</span> Account a;<br>Account b;<br>lookup(a); <span class="hljs-comment">// calls lookup(const Account&amp;)</span><br>lookup(b); <span class="hljs-comment">// calls lookup(Account&amp;)</span><br></code></pre></td></tr></table></figure>
<p>We cannot bind a <code>plain reference</code> to a <code>const</code> object.</p>
<p>We can use <code>b</code> to initialize a reference to either <code>const</code> or <code>nonconst</code> type.</p>
<p>However, initializing a reference to <code>const</code> from a <code>nonconst</code> object requires a <strong>conversion</strong>. Hence, the <code>nonconst</code> version is preferred.</p>
<h3 id="Match-through-a-Promotion-or-Arithmetic-Conversion"><a href="#Match-through-a-Promotion-or-Arithmetic-Conversion" class="headerlink" title="Match through a Promotion or Arithmetic Conversion"></a>Match through a Promotion or Arithmetic Conversion</h3><p>The small integral types always promote to int or to a larger integral type. </p>
<p>Given two functions, one of which takes an <code>int</code> and the other a <code>short</code>, the <code>short</code> version will be called <strong>only</strong> on values of type short:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(short)</span></span>;<br>ff(<span class="hljs-string">'a'</span>); <span class="hljs-comment">// char promotes to int; calls f(int)</span><br></code></pre></td></tr></table></figure>
<p><strong>All the arithmetic conversions are treated as equivalent to each other.</strong></p>
<p>The conversion from <code>int</code> to <code>unsigned int</code>, for example, does not take precedence over the conversion from <code>int</code> to <code>double</code>:   </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manip</span><span class="hljs-params">(<span class="hljs-keyword">long</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manip</span><span class="hljs-params">(<span class="hljs-keyword">float</span>)</span></span>;<br>manip(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// error: ambiguous call</span><br></code></pre></td></tr></table></figure>
<h1 id="9-Pointers-to-Functions"><a href="#9-Pointers-to-Functions" class="headerlink" title="9. Pointers to Functions"></a>9. Pointers to Functions</h1><p>A function pointer is just that a pointer that denotes a function rather than an object.</p>
<p>When we use the name of a function as a value, the function is automatically converted to a pointer. </p>
<h2 id="1-Function-Pointer-Parameters"><a href="#1-Function-Pointer-Parameters" class="headerlink" title="(1) Function Pointer Parameters"></a>(1) Function Pointer Parameters</h2><p>Just as with arrays, we cannot define parameters of function type but can have a parameter that is a pointer to function. </p>
<p>As with arrays, we can write a parameter that looks like a function type, but it will be treated as a pointer:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// third parameter is a function type and is automatically treated as a pointer to function</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span> pf(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;))</span></span>;<br><span class="hljs-comment">// equivalent declaration: explicitly define the parameter as a pointer to function</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span> (*pf)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;))</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// compares lengths of two strings</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">lengthCompare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;)</span></span>;<br><span class="hljs-comment">// Func and Func2 have function type</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> Func2</span>; <span class="hljs-comment">// equivalent type</span><br><span class="hljs-comment">// FuncP and FuncP2 have pointer to function type</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span><span class="hljs-params">(*FuncP)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> *FuncP2</span>; <span class="hljs-comment">// equivalent type</span><br></code></pre></td></tr></table></figure>
<p>Both <code>Func</code> and <code>Func2</code> are <strong>function types</strong>, whereas <code>FuncP</code> and <code>FuncP2</code> are <strong>pointer types</strong>. </p>
<p><strong>It is important to note that decltype returns the function type</strong>; the <strong>automatic conversion</strong> to pointer is not done.</p>
<h2 id="2-Returning-a-Pointer-to-Function"><a href="#2-Returning-a-Pointer-to-Function" class="headerlink" title="(2) Returning a Pointer to Function"></a>(2) Returning a Pointer to Function</h2><p>As with arrays, we can’t return a function type but can return a pointer to a function type. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> F = <span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>); <span class="hljs-comment">// F is a function type, not a pointer</span><br><span class="hljs-keyword">using</span> PF = <span class="hljs-keyword">int</span>(*)(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>); <span class="hljs-comment">// PF is a pointer type</span><br></code></pre></td></tr></table></figure>
<p>Here we used type alias declarations to define <code>F</code>as a <strong>function type</strong> and <code>PF</code> as a <strong>pointer to function type</strong>. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">PF <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">// ok: PF is a pointer to function; f1 returns a pointer to function</span><br><span class="hljs-function">F <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">// error: F is a function type; f1 can't return a function</span><br><span class="hljs-function">F *<span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">// ok: explicitly specify that the return type is a pointer to function</span><br></code></pre></td></tr></table></figure>
<p>We can also declare <code>f1</code> directly, which we’d do as</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> (*f1(<span class="hljs-keyword">int</span>))(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>);<br></code></pre></td></tr></table></figure>
<p>Reading this declaration from the inside out, we see that <code>f1</code> has a parameter list, so <code>f1</code> is a function. </p>
<p><code>f1</code> is preceded by a <code>*</code> so <code>f1</code> returns a pointer. </p>
<p>The type of that pointer itself has a parameter list, so the pointer points to a function. </p>
<p>That function returns an int.</p>
<p>For completeness, it’s worth noting that we can simplify declarations of functions that return pointers to function by using a trailing return:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">auto f1(int) -&gt; int (*)(int*, int);<br></code></pre></td></tr></table></figure>
<h2 id="3-Using-auto-or-decltype-for-Function-Pointer-Types"><a href="#3-Using-auto-or-decltype-for-Function-Pointer-Types" class="headerlink" title="(3) Using auto or decltype for Function Pointer Types"></a>(3) Using auto or decltype for Function Pointer Types</h2><p>If we know which function(s) we want to return, we can use <strong>decltype</strong> to simplify writing a function pointer return type. </p>
<p>For example, assume we have two functions, both of which return a <code>string::size_type</code> and have two <code>const string&amp;</code> parameters. </p>
<p>We can write a third function that takes a string parameter and returns a pointer to one of these two functions as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span>::size_type <span class="hljs-title">sumLength</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">string</span>::size_type <span class="hljs-title">largerLength</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;)</span></span>;<br><span class="hljs-comment">// depending on the value of its string parameter,</span><br><span class="hljs-comment">// getFcn returns a pointer to sumLength or to largerLength</span><br><span class="hljs-keyword">decltype</span>(sumLength) *getFcn(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;);<br></code></pre></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/C/">C++</a>
                    
                      <a class="hover-with-bg" href="/categories/C/C-Primer/">C++ Primer</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                      <a class="hover-with-bg" href="/tags/C-Primer/">C++ Primer</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/15/Classes/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Classes</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/01/12/Statements/">
                        <span class="hidden-mobile">Statements</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"cfOIMBd6tuDTv7dOXC9Iy3NQ-gzGzoHsz","appKey":"5oQLiMeBUSIe3XsUFbQRh5m5","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"https://cfoimbd6.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
