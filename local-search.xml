<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Expressions</title>
    <link href="/2020/12/29/Expressions/"/>
    <url>/2020/12/29/Expressions/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 4 Expressions</p><a id="more"></a><h1 id="1-Lvalues-and-Rvalues"><a href="#1-Lvalues-and-Rvalues" class="headerlink" title="1. Lvalues and Rvalues"></a>1. Lvalues and Rvalues</h1><p>Every expression in C++ is either an <strong>rvalue</strong> or an <strong>lvalue</strong>.</p><p>In C++, an <strong>lvalue expression</strong> yields an object or a function. </p><p>Roughly speaking, when we use an object as an <strong>rvalue</strong>, we use the object’s <strong>value</strong> (its contents). </p><p>When we use an object as an <strong>lvalue</strong>, we use the object’s <strong>identity</strong> (its location in memory).</p><ul><li><p><strong>Assignment</strong> requires a (nonconst) <code>lvalue</code> as its left-hand operand and yields its <strong>left-hand operand as an lvalue</strong>.</p></li><li><p>The <strong>address-of operator</strong> requires an <strong>lvalue</strong> operand and <strong>returns</strong> a <strong>pointer</strong> to its operand <strong>as an rvalue</strong>.</p></li><li><p>The built-in dereference and subscript operators and the iterator dereference and string and vector subscript operators all yield <strong>lvalues</strong>.</p></li><li><p>The built-in and iterator <strong>increment and decrement</strong> operators <strong>require lvalue</strong> operands and the prefix versions also <strong>yield lvalues</strong>.</p></li></ul><p><strong>Lvalues and rvalues also differ when used with decltype</strong>.</p><p>When we apply <strong>decltype to an expression</strong> (other than a variable), the result is a <strong>reference</strong> type if the expression yields an <strong>lvalue</strong>. </p><p>As an example, assume <code>p</code> is an <code>int*</code>. Because dereference yields an <strong>lvalue</strong> <code>decltype(*p)</code> is <code>int&amp;</code>. </p><p>On the other hand, because the address-of operator yields an <strong>rvalue</strong> <code>decltype(&amp;p)</code> is <code>int**</code>, that is, a pointer to a pointer to type int.</p><p>The left-hand operand of an assignment operator must be a <strong>modifiable lvalue</strong>. For example, given</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>; <span class="hljs-comment">// initializations, not assignment</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i; <span class="hljs-comment">// initialization, not assignment</span></code></pre><pre><code class="hljs cpp"><span class="hljs-number">1024</span> = k; <span class="hljs-comment">// error: literals are rvalues</span>i + j = k; <span class="hljs-comment">// error: arithmetic expressions are rvalues</span>ci = k; <span class="hljs-comment">// error: ci is a const (nonmodifiable) lvalue</span></code></pre><p>The <strong>result of an assignment</strong> is its <strong>left-hand operand</strong>, which is an <strong>lvalue</strong>. </p><p>The <strong>type of the result</strong> is the type of the left-hand operand. </p><p>If the <strong>types</strong> of the left and right operands <strong>differ</strong>, the <strong>right-hand</strong> operand is <strong>converted</strong> to the type of the <strong>left</strong>:</p><pre><code class="hljs cpp">k = <span class="hljs-number">0</span>; <span class="hljs-comment">// result: type int, value 0</span>k = <span class="hljs-number">3.14159</span>; <span class="hljs-comment">// result: type int, value 3</span></code></pre><p>Under the new standard, we can use a <strong>braced initializer list</strong> on the right-hand side:</p><pre><code class="hljs cpp">k = &#123;<span class="hljs-number">3.14</span>&#125;; <span class="hljs-comment">// error: narrowing conversion</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi; <span class="hljs-comment">// initially empty</span>vi = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;</code></pre><p>If the <strong>left-hand operand</strong> is of a <strong>built-in type</strong>, the <strong>initializer list</strong> may contain at most one value, and that value <strong>must not</strong> require a <strong>narrowing conversion</strong>.</p><p>Regardless of the type of the left-hand operand, the initializer list may be empty. </p><p>In this case, the compiler generates a <strong>value-initialized</strong> temporary and assigns that value to the left-hand operand.</p><p>Unlike the other binary operators, assignment is <strong>right associative</strong>.</p><h1 id="2-Arithmetic-Operators"><a href="#2-Arithmetic-Operators" class="headerlink" title="2. Arithmetic Operators"></a>2. Arithmetic Operators</h1><p>In a <strong>division</strong>, the <a href="http://eel.is/c++draft/expr.mul#:operator,division" target="_blank" rel="noopener">new standard</a> requires the quotient to be rounded toward zero (i.e., truncated).</p><p>The <strong>modulus operator</strong> is defined so that if m and n are integers and n is nonzero, then <strong>(m/n)*n + m%n</strong> is equal to m. </p><p><strong>By implication, if **m%n</strong> is nonzero, it has the same sign as <strong>m</strong>.**</p><pre><code class="hljs angelscript"><span class="hljs-number">21</span> % <span class="hljs-number">6</span>; <span class="hljs-comment">/* result is 3 */</span> <span class="hljs-number">21</span> / <span class="hljs-number">6</span>; <span class="hljs-comment">/* result is 3 */</span><span class="hljs-number">21</span> % <span class="hljs-number">7</span>; <span class="hljs-comment">/* result is 0 */</span> <span class="hljs-number">21</span> / <span class="hljs-number">7</span>; <span class="hljs-comment">/* result is 3 */</span><span class="hljs-number">-21</span> % <span class="hljs-number">-8</span>; <span class="hljs-comment">/* result is -5 */</span> <span class="hljs-number">-21</span> / <span class="hljs-number">-8</span>; <span class="hljs-comment">/* result is 2 */</span><span class="hljs-number">21</span> % <span class="hljs-number">-5</span>; <span class="hljs-comment">/* result is 1 */</span> <span class="hljs-number">21</span> / <span class="hljs-number">-5</span>; <span class="hljs-comment">/* result is -4 */</span></code></pre><h1 id="3-Precedence-and-Associativity"><a href="#3-Precedence-and-Associativity" class="headerlink" title="3. Precedence and Associativity"></a>3. Precedence and Associativity</h1><p><img src="https://img-blog.csdnimg.cn/20200129093415373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200129093555366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200129093618503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200129093634253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="4-Order-of-Evaluation"><a href="#4-Order-of-Evaluation" class="headerlink" title="4. Order of Evaluation"></a>4. Order of Evaluation</h1><p><strong>Precedence</strong> specifies how the operands are grouped. It says nothing about the <strong>order</strong> in which the <strong>operands are evaluated</strong>. </p><p>In most cases, the order is largely <strong>unspecified</strong>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = f1() * f2();</code></pre><p>we know that <code>f1</code> and <code>f2</code> must be called before the multiplication can be done. </p><p>However, we have no way of knowing whether <code>f1</code> will be called before <code>f2</code> or vice versa.</p><p>For operators that do not specify evaluation order, it is an error for an expression to refer to and change the <strong>same object</strong>. </p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; ++i &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// undefined</span></code></pre><p>The compiler might evaluate <code>++i</code> before evaluating <code>i</code>.</p><p>There are <strong>four operators</strong> that do <strong>guarantee the order</strong> in which <strong>operands are evaluated</strong>.</p><p>The logical <strong>AND (&amp;&amp;)</strong> operator guarantees that its <strong>left-hand operand is evaluated first</strong>. </p><p>Moreover, we are also guaranteed that the <strong>right-hand</strong> operand is evaluated <strong>only if the left-hand operand is true</strong>.</p><p>The only other operators that guarantee the order in which operands are evaluated are the <strong>logical OR (||)</strong> operator, the <strong>conditional (? : )</strong> operator, and the <strong>comma (,)</strong> operator </p><h1 id="5-Increment-and-Decrement-Operators"><a href="#5-Increment-and-Decrement-Operators" class="headerlink" title="5. Increment and Decrement Operators"></a>5. Increment and Decrement Operators</h1><p>There are <strong>two forms</strong> of these operators: prefix and postfix. </p><p>The <strong>prefix</strong> increments (or decrements) its operand and <strong>yields the changed object</strong> as its result. </p><p>The <strong>postfix</strong> operators increment (or decrement) the operand but <strong>yield a copy of the original</strong>, unchanged value as its result.</p><p>The <strong>postfix operator</strong> must <strong>store the original value</strong> so that it can return the unincremented value as its result.</p><pre><code class="hljs cpp"><span class="hljs-comment">// the behavior of the following loop is undefined!</span><span class="hljs-keyword">while</span> (beg != s.end() &amp;&amp; !<span class="hljs-built_in">isspace</span>(*beg))    *beg = <span class="hljs-built_in">toupper</span>(*beg++); <span class="hljs-comment">// error: this assignment is undefined</span></code></pre><p>The problem is that both the left and right-hand operands to = use beg and the right-hand operand changes beg. </p><p>The compiler might evaluate this expression as either</p><pre><code class="hljs cpp"><span class="hljs-comment">// execution if left-hand side is evaluated first</span>*beg = <span class="hljs-built_in">toupper</span>(*beg); <span class="hljs-comment">// execution if right-hand side is evaluated first</span>*(beg + <span class="hljs-number">1</span>) = <span class="hljs-built_in">toupper</span>(*beg);</code></pre><h1 id="6-sizeof"><a href="#6-sizeof" class="headerlink" title="6. sizeof"></a>6. sizeof</h1><p>The <strong>sizeof</strong> operator returns the size, in <strong>bytes</strong>, of an expression or a type name. </p><p>The operator is <strong>right associative</strong>. </p><p>The result of <strong>sizeof</strong> is a <strong>constant expression</strong> of type <code>size_t</code>.</p><p>The operator takes one of two forms:</p><pre><code class="hljs cpp"><span class="hljs-keyword">sizeof</span> (type)<span class="hljs-keyword">sizeof</span> expr</code></pre><p><strong>sizeof an array</strong> is the size of the entire array. It is equivalent to taking the sizeof the element type times the number of elements in the array. </p><p><strong>sizeof a string</strong> or a <strong>vector</strong> returns only the size of the fixed part of these types; it does not return the size used by the object’s elements.</p><p>Note that sizeof does not convert the array to a pointer.</p><h1 id="7-Type-Conversion"><a href="#7-Type-Conversion" class="headerlink" title="7. Type Conversion"></a>7. Type Conversion</h1><h2 id="1-implicit-conversions"><a href="#1-implicit-conversions" class="headerlink" title="(1) implicit conversions"></a>(1) implicit conversions</h2><ul><li><p>In <strong>most expressions</strong>, values of integral types smaller than <code>int</code> are first promoted to an appropriate larger integral type.</p></li><li><p>In <strong>conditions</strong>, nonbool expressions are converted to bool.</p></li><li><p>In <strong>initializations</strong>, the initializer is converted to the type of the variable; </p></li><li><p>in <strong>assignments</strong>, the right-hand operand is converted to the type of the left-hand.</p></li><li><p>In <strong>arithmetic and relational expressions</strong> with operands of mixed types, the types are converted to a common type.</p></li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">3.541</span> + <span class="hljs-number">3</span>; <span class="hljs-comment">// the compiler might warn about loss of precision</span></code></pre><ol><li><p><code>3</code> is converted to double, floating-point addition is done, and the result is a double.</p></li><li><p>The double result of the addition is converted to <code>int</code> and used to initialize <code>ival</code>.</p></li></ol><h2 id="2-The-Arithmetic-Conversions"><a href="#2-The-Arithmetic-Conversions" class="headerlink" title="(2) The Arithmetic Conversions"></a>(2) The Arithmetic Conversions</h2><p>The <strong>arithmetic conversions</strong> convert one arithmetic type to another. </p><p>The rules define a hierarchy of type conversions in which operands to an operator are converted to the <strong>widest type</strong>.</p><h2 id="3-Other-Implicit-Conversions"><a href="#3-Other-Implicit-Conversions" class="headerlink" title="(3) Other Implicit Conversions"></a>(3) Other Implicit Conversions</h2><h3 id="Array-to-Pointer-Conversions"><a href="#Array-to-Pointer-Conversions" class="headerlink" title="Array to Pointer Conversions"></a>Array to Pointer Conversions</h3><p>In most expressions, when we use an array, the array is automatically converted to a pointer to the first element in that array.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">10</span>]; <span class="hljs-comment">// array of ten ints</span><span class="hljs-keyword">int</span>* ip = ia; <span class="hljs-comment">// convert ia to a pointer to the first element</span></code></pre><p>This conversion is <strong>not performed</strong> when an array is used with <strong>decltype</strong> or as the operand of the <strong>address-of</strong> ( &amp; ), <strong>sizeof</strong>, or <strong>typeid</strong> operators. </p><p>The conversion is also <strong>omitted</strong> when we <strong>initialize a reference</strong> to an array.</p><h2 id="4-Pointer-Conversions"><a href="#4-Pointer-Conversions" class="headerlink" title="(4) Pointer Conversions"></a>(4) Pointer Conversions</h2><ul><li><p>A constant integral value of <strong>0</strong> and the literal <strong>nullptr</strong> can be converted to any pointer type.</p></li><li><p>A pointer to any nonconst type can be converted to <strong>void*</strong>.</p></li><li><p>A pointer to any type can be converted to a <strong>const void*</strong>.</p></li></ul><h2 id="5-Conversions-to-bool"><a href="#5-Conversions-to-bool" class="headerlink" title="(5) Conversions to bool"></a>(5) Conversions to bool</h2><p>There is an <strong>automatic conversion</strong> from arithmetic or pointer types to bool. </p><p>If the pointer or arithmetic value is zero, the conversion yields false; any other value yields true.</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> *cp = get_string();<span class="hljs-keyword">if</span> (cp) <span class="hljs-comment">/* ... */</span> <span class="hljs-comment">// true if the pointer cp is not zero</span><span class="hljs-keyword">while</span> (*cp) <span class="hljs-comment">/* ... */</span> <span class="hljs-comment">// true if *cp is not the null character</span></code></pre><h2 id="6-Conversion-to-const"><a href="#6-Conversion-to-const" class="headerlink" title="(6) Conversion to const"></a>(6) Conversion to const</h2><p>We <strong>can</strong> convert a <strong>pointer to a nonconst</strong> type to a <strong>pointer to the corresponding const type</strong>, and similarly for <strong>references</strong>. </p><p>That is, if <code>T</code> is a type, we can convert a pointer or a reference to <code>T</code> into a pointer or reference to <strong>const T</strong>, respectively.</p><h2 id="7-Conversions-Defined-by-Class-Types"><a href="#7-Conversions-Defined-by-Class-Types" class="headerlink" title="(7) Conversions Defined by Class Types"></a>(7) Conversions Defined by Class Types</h2><p>Class types can define conversions that the compiler will apply automatically. </p><pre><code class="hljs cpp"><span class="hljs-comment">// character string literal converted to type string</span><span class="hljs-built_in">string</span> s, t = <span class="hljs-string">"a value"</span>; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; s) <span class="hljs-comment">// while condition converts cin to bool</span></code></pre><p>The condition <code>(cin &gt;&gt; s)</code> reads <code>cin</code> and yields <code>cin</code> as its result. </p><p>Conditions expect a value of type bool, but this condition tests a value of type istream. </p><p>The <strong>IO library</strong> defines a conversion from istream to bool. </p><p>That conversion is used (automatically) to convert <code>cin</code> to bool. </p><p>The resulting bool value depends on the state of the stream. </p><p>If the last read succeeded, then the conversion yields true. If the last attempt failed, then the conversion to bool yields false.</p><h2 id="8-Named-Casts"><a href="#8-Named-Casts" class="headerlink" title="(8) Named Casts"></a>(8) Named Casts</h2><pre><code class="hljs elm"><span class="hljs-title">cast</span>-name&lt;<span class="hljs-keyword">type</span>&gt;(expression);</code></pre><p>Where <code>type</code> is the target type of the conversion, and <code>expression</code> is the value to be cast. </p><p>If <code>type</code> is a reference, then the result is an <code>lvalue</code>. </p><p>The cast-name may be one of <strong>static_cast</strong>, <strong>dynamic_cast</strong>, <strong>const_cast</strong>, and <strong>reinterpret_cast</strong>.</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>Any well-defined type conversion, other than those involving low-level const, can be requested using a <strong>static_cast</strong>. </p><pre><code class="hljs cpp"><span class="hljs-comment">// cast used to force floating-point division</span><span class="hljs-keyword">double</span> slope = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(j) / i;</code></pre><p>A <code>static_cast</code> is <strong>often useful</strong> when a <strong>larger arithmetic</strong> type is assigned to a <strong>smaller type</strong>. </p><p>A <code>static_cast</code> is <strong>also useful</strong> to perform a conversion that the compiler will not generate automatically.</p><pre><code class="hljs cpp"><span class="hljs-comment">// ok: address of any nonconst object can be stored in a void*</span><span class="hljs-keyword">void</span>* p = &amp;d; <span class="hljs-comment">// ok: converts void* back to the original pointer type</span><span class="hljs-keyword">double</span> *dp = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>*&gt;(p);</code></pre><p>The result of the cast will be equal to the original address value.</p><p>However, we <strong>must be certain</strong> that the type to which we cast the pointer is the <strong>actual type</strong> of that pointer; if the types do <strong>not match</strong>, the result is <strong>undefined</strong>.</p><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>A <strong>const_cast</strong> changes only a low-level const in its operand</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pc;<span class="hljs-keyword">char</span> *p = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(pc); <span class="hljs-comment">// ok: but writing through p is undefined ？？？</span></code></pre><p>Conventionally we say that a cast that converts a const object to a nonconst type “<strong>casts away the const</strong>.” </p><p><strong>Once we have cast away the const of an object, the compiler will no longer prevent us from writing to that object.</strong> </p><p>If the object was originally not a const, using a cast to obtain write access is legal. </p><p>Only a <strong>const_cast</strong> may be used to change the <strong>constness</strong> of an expression.</p><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>A <strong>reinterpret_cast</strong> generally performs a <strong>low-level reinterpretation</strong> of the bit pattern of its operands.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ip;<span class="hljs-keyword">char</span> *pc = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(ip);</code></pre><p>We must never forget that the <strong>actual object</strong> addressed by <code>pc</code> is an <strong>int</strong>, <strong>not a character</strong>. </p><p>Any use of <code>pc</code> that assumes it’s an ordinary character pointer is likely to fail at run time:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">(pc)</span></span>;</code></pre><p>is likely to result in bizarre run-time behavior.</p><h3 id="Old-Style-Casts"><a href="#Old-Style-Casts" class="headerlink" title="Old-Style Casts"></a>Old-Style Casts</h3><p>In early versions of C++, an explicit cast took one of the following two forms:</p><pre><code class="hljs cpp">type (expr); <span class="hljs-comment">// function-style cast notation</span>(type) expr; <span class="hljs-comment">// C-language-style cast notation</span></code></pre><p>When we use an old-style cast where a <strong>static_cast</strong> or a <strong>const_cast</strong> would be legal, the old-style cast does <strong>the same conversion</strong> as the respective named cast. If neither cast is legal, then an old-style cast performs a <strong>reinterpret_cast</strong>. For example:</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> *pc = (<span class="hljs-keyword">char</span>*) ip; <span class="hljs-comment">// ip is a pointer to int</span></code></pre><p>has the same effect as using a <code>reinterpret_cast</code>.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strings-Vectors-and-Arrays</title>
    <link href="/2020/12/29/Strings-Vectors-and-Arrays/"/>
    <url>/2020/12/29/Strings-Vectors-and-Arrays/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 3 Strings-Vectors-and-Arrays</p><a id="more"></a><h1 id="1-using-declaration"><a href="#1-using-declaration" class="headerlink" title="1. using declaration"></a>1. using declaration</h1><p><a href="http://eel.is/c++draft/basic.namespace" target="_blank" rel="noopener">Namespaces</a> </p><p>A <strong>using</strong> declaration lets us use a name from a namespace without qualifying the <code>name</code> with a namespace_name <strong>::</strong> prefix.</p><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>::name;</code></pre><p>Once the <strong>using</strong> declaration has been made, we can access <code>name</code> directly.</p><p>Code inside headers ordinarily should not use <strong>using</strong> declarations.<br>The reason is that the contents of a header are copied into the including program’s text. </p><p>If a header has a using declaration, then every program that includes that header gets that same <strong>using</strong> declaration. </p><p>As a result, a program that didn’t intend to use the specified library name might <strong>encounter unexpected name conflicts</strong>.</p><h1 id="2-Library-string-Type"><a href="#2-Library-string-Type" class="headerlink" title="2. Library string Type"></a>2. Library string Type</h1><p>A string is a <strong>variable-length sequence of characters</strong>. </p><p>To use the string type, we must include the <strong>string header</strong>. </p><p>Because it is part of the library, string is defined in the <strong>std namespace</strong>. </p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>;</code></pre><h2 id="1-Defining-and-Initializing-strings"><a href="#1-Defining-and-Initializing-strings" class="headerlink" title="(1) Defining and Initializing strings"></a>(1) Defining and Initializing strings</h2><p>Each class defines how objects of its type can be initialized. </p><p>A class may define <strong>many different ways to initialize objects</strong> of its type. </p><p>Each way must be <strong>distinguished</strong> from the others either by the <strong>number of initializers</strong> that we supply, or by the <strong>types of those initializers</strong>. </p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1; <span class="hljs-comment">// default initialization; s1 is the empty string</span><span class="hljs-built_in">string</span> s2 = s1; <span class="hljs-comment">// s2 is a copy of s1</span><span class="hljs-built_in">string</span> s3 = <span class="hljs-string">"hiya"</span>; <span class="hljs-comment">// s3 is a copy of the string literal</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>)</span></span>; <span class="hljs-comment">// s4 is cccccccccc</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200126165219910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="2-Direct-and-Copy-Forms-of-Initialization"><a href="#2-Direct-and-Copy-Forms-of-Initialization" class="headerlink" title="(2) Direct and Copy Forms of Initialization"></a>(2) Direct and Copy Forms of Initialization</h2><p>When we initialize a variable using <strong>=</strong>, we are asking the compiler to <strong>copy</strong> initialize the object by <strong>copying the initializer</strong> on the right-hand side into the object being created.</p><p>Otherwise, when we omit the =, we use <strong>direct initialization</strong>.</p><p>When we have a <strong>single initializer</strong>, we can use either the direct or copy form of initialization. </p><p>When we initialize a variable from <strong>more than one value</strong>, such as in the initialization of s4 above, we must use the <strong>direct form of initialization</strong>:</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s5 = <span class="hljs-string">"hiya"</span>; <span class="hljs-comment">// copy initialization</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s6</span><span class="hljs-params">(<span class="hljs-string">"hiya"</span>)</span></span>; <span class="hljs-comment">// direct initialization</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s7</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>)</span></span>; <span class="hljs-comment">// direct initialization; s7 is cccccccccc</span></code></pre><p>When we want to use several values, we can <strong>indirectly</strong> use the <strong>copy form</strong> of initialization by <strong>explicitly</strong> creating a <strong>(temporary) object</strong> to copy:</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s8 = <span class="hljs-built_in">string</span>(<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>); <span class="hljs-comment">// copy initialization; s8 is cccccccccc</span></code></pre><h3 id="Difference-between-direct-and-copy-Initialization"><a href="#Difference-between-direct-and-copy-Initialization" class="headerlink" title="Difference between direct and copy Initialization"></a>Difference between direct and copy Initialization</h3><p><a href="https://stackoverflow.com/a/1051395/12342782" target="_blank" rel="noopener">Is there a difference between copy initialization and direct initialization?</a></p><h2 id="3-Operations-on-strings"><a href="#3-Operations-on-strings" class="headerlink" title="(3) Operations on strings"></a>(3) Operations on strings</h2><p><img src="https://img-blog.csdnimg.cn/20200126170111949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="4-Reading-and-Writing-strings"><a href="#4-Reading-and-Writing-strings" class="headerlink" title="(4) Reading and Writing strings"></a>(4) Reading and Writing strings</h2><p>We use the iostream library to read and write values of <strong>built-in</strong> types such as int, double, and so on. </p><p>We use the same IO operators to read and write strings:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">string</span> s; <span class="hljs-comment">// empty string</span>    <span class="hljs-built_in">cin</span> &gt;&gt; s; <span class="hljs-comment">// read a whitespace-separated string into s</span>    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// write s to the output</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>The string input operator reads and <strong>discards any leading whitespace</strong> (e.g., spaces, newlines, tabs). </p><p>It then reads characters until the <strong>next whitespace</strong> character is encountered.</p><p>Like the input and output operations on the built-in types, the string operators <strong>return their left-hand operand as their result</strong>. </p><p>Thus, we can <strong>chain together multiple reads or writes</strong>:</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1, s2;<span class="hljs-built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2; <span class="hljs-comment">// read first input into s1, second into s2</span><span class="hljs-built_in">cout</span> &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// write both strings</span></code></pre><h2 id="5-Reading-an-Unknown-Number-of-strings"><a href="#5-Reading-an-Unknown-Number-of-strings" class="headerlink" title="(5) Reading an Unknown Number of strings"></a>(5) Reading an Unknown Number of strings</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">string</span> word;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; word) <span class="hljs-comment">// read until end-of-file</span>        <span class="hljs-built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// write each word followed by a new line</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>If the stream is valid—it hasn’t hit <strong>end-of-file</strong> or encountered<br>an <strong>invalid input</strong>—then the body of the while is executed. </p><h2 id="6-Using-getline-to-Read-an-Entire-Line"><a href="#6-Using-getline-to-Read-an-Entire-Line" class="headerlink" title="(6) Using getline to Read an Entire Line"></a>(6) Using getline to Read an Entire Line</h2><p>The getline function takes an input stream and a string. </p><p>This function reads the given stream up to and <strong>including the first newline</strong> and stores what it read—<strong>not including the newline</strong>—in its string argument. </p><p>After getline sees a <strong>newline</strong>, even if it is the first character in<br>the input, it <strong>stops reading and returns</strong>. </p><p>If the first character in the input is a newline, then the resulting string is the <strong>empty string</strong>.</p><p>Like the input operator, getline <strong>returns its istream</strong> argument. </p><p><strong>The newline that causes getline to return is discarded; the newline is not stored in the string.</strong></p><h2 id="7-The-string-empty-and-size-Operations"><a href="#7-The-string-empty-and-size-Operations" class="headerlink" title="(7) The string empty and size Operations"></a>(7) The string empty and size Operations</h2><p>The empty function does what one would expect: It returns a <strong>bool</strong>  indicating whether the string is empty.</p><pre><code class="hljs cpp"><span class="hljs-comment">// read input a line at a time and discard blank lines</span><span class="hljs-keyword">while</span> (getline(<span class="hljs-built_in">cin</span>, line))    <span class="hljs-keyword">if</span> (!line.empty())        <span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><p>The <strong>size member</strong> returns the <strong>length</strong> of a string. size returns a <strong>string::size_type</strong> value.</p><p>Although we don’t know the precise type of <strong>string::size_type</strong>, we do know that it is an <strong>unsigned type</strong> big enough to hold the size of any string. </p><p>Any variable used to store the result from the string size operation should be of type <strong>string::size_type</strong>.</p><p>Admittedly, it can be tedious to type <strong>string::size_type</strong>. Under the new standard, we can ask the compiler to provide the appropriate type by using <strong>auto or decltype</strong>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> len = line.size(); <span class="hljs-comment">// len has type string::size_type</span></code></pre><h2 id="8-Comparing-strings"><a href="#8-Comparing-strings" class="headerlink" title="(8) Comparing strings"></a>(8) Comparing strings</h2><p>The <strong>equality operators</strong> (== and !=) test whether two strings are <strong>equal or unequal</strong>, respectively. </p><p>Two strings are equal if they are the <strong>same length and contain the same characters</strong>. </p><p>The relational operators <strong>&lt;, &lt;=, &gt;, &gt;=</strong> test whether one string is less than, less than or equal to, greater than, or greater than or equal to another.</p><p>These operators use the same strategy as a (<strong>case-sensitive</strong>) dictionary:</p><h2 id="9-Assignment-for-strings"><a href="#9-Assignment-for-strings" class="headerlink" title="(9) Assignment for strings"></a>(9) Assignment for strings</h2><pre><code class="hljs cpp">string st1(10, 'c'), st2; // st1 is cccccccccc; st2 is an empty stringst1 = st2; <span class="hljs-comment">// assignment: replace contents of st1 with a copy of st2</span><span class="hljs-comment">// both st1 and st2 are now the empty string</span></code></pre><h2 id="10-Adding-Two-strings"><a href="#10-Adding-Two-strings" class="headerlink" title="(10) Adding Two strings"></a>(10) Adding Two strings</h2><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"hello, "</span>, s2 = <span class="hljs-string">"world\n"</span>;<span class="hljs-built_in">string</span> s3 = s1 + s2; <span class="hljs-comment">// s3 is hello, world\n</span>s1 += s2; <span class="hljs-comment">// equivalent to s1 = s1 + s2</span></code></pre><h2 id="11-Adding-Literals-and-strings"><a href="#11-Adding-Literals-and-strings" class="headerlink" title="(11) Adding Literals and strings"></a>(11) Adding Literals and strings</h2><p>The string library lets us convert both character literals and character string literals to strings.</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"hello"</span>, s2 = <span class="hljs-string">"world"</span>; <span class="hljs-comment">// no punctuation in s1 or s2</span><span class="hljs-built_in">string</span> s3 = s1 + <span class="hljs-string">", "</span> + s2 + <span class="hljs-string">'\n'</span>;</code></pre><p>When we mix strings and string or character literals, <strong>at least one operand</strong> to <strong>each +</strong> operator must be of <strong>string type</strong>:</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s4 = s1 + <span class="hljs-string">", "</span>; <span class="hljs-comment">// ok: adding a string and a literal</span><span class="hljs-built_in">string</span> s5 = <span class="hljs-string">"hello"</span> + <span class="hljs-string">", "</span>; <span class="hljs-comment">// error: no string operand</span><span class="hljs-built_in">string</span> s6 = s1 + <span class="hljs-string">", "</span> + <span class="hljs-string">"world"</span>; <span class="hljs-comment">// ok: each + has a string operand</span><span class="hljs-built_in">string</span> s7 = <span class="hljs-string">"hello"</span> + <span class="hljs-string">", "</span> + s2; <span class="hljs-comment">// error: can't add string literals</span></code></pre><p>The subexpression <code>s1 + &quot;, &quot;</code><strong>returns a string</strong>, which forms the left-hand operand of the second <code>+</code> operator. It is as if we had written：</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> tmp = s1 + <span class="hljs-string">", "</span>; <span class="hljs-comment">// ok: + has a string operand</span>s6 = tmp + <span class="hljs-string">"world"</span>; <span class="hljs-comment">// ok: + has a string operand</span></code></pre><h2 id="12-Dealing-with-the-Characters-in-a-string"><a href="#12-Dealing-with-the-Characters-in-a-string" class="headerlink" title="(12) Dealing with the Characters in a string"></a>(12) Dealing with the Characters in a string</h2><p><strong>cctype Functions：</strong><br><img src="https://img-blog.csdnimg.cn/20200126192859119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="13-Range-Based-for-Processing-Every-Character"><a href="#13-Range-Based-for-Processing-Every-Character" class="headerlink" title="(13) Range-Based for: Processing Every Character"></a>(13) Range-Based for: Processing Every Character</h2><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (declaration : expression)    statement</code></pre><p>Where <strong>expression</strong> is an <strong>object</strong> of a type that represents <strong>a sequence</strong>, and <strong>declaration</strong> defines the variable that we’ll use to access the <strong>underlying elements</strong> in the sequence.</p><p>On <strong>each iteration</strong>, the variable in declaration is initialized from the value of the next element in expression.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"some string"</span>)</span></span>;<span class="hljs-comment">// print the characters in str one character to a line</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : str) <span class="hljs-comment">// for every char in str</span>    <span class="hljs-built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// print the current character followed by a newline</span></code></pre><p>In this case, we use <strong>auto</strong> to let the compiler determine the type of <code>c</code>, which in this case will be char. </p><p>On each iteration, the next character in <code>str</code> will be copied into <code>c</code>. </p><p>Thus, we can read this loop as saying, “For every character c in the string str,” do something. </p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"Hello World!!!"</span>)</span></span>;<span class="hljs-comment">// punct_cnt has the same type that s.size returns; see § 2.5.3 (p. 70)</span><span class="hljs-keyword">decltype</span>(s.size()) punct_cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">// count the number of punctuation characters in s</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) <span class="hljs-comment">// for every char in s</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ispunct</span>(c)) <span class="hljs-comment">// if the character is punctuation</span>        ++punct_cnt; <span class="hljs-comment">// increment the punctuation counter</span><span class="hljs-built_in">cout</span> &lt;&lt; punct_cnt&lt;&lt; <span class="hljs-string">" punctuation characters in "</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><h2 id="14-Change-the-Characters-in-a-string"><a href="#14-Change-the-Characters-in-a-string" class="headerlink" title="(14) Change the Characters in a string"></a>(14) Change the Characters in a string</h2><p>If we want to change the value of the characters in a string, we must define the loop variable as a reference type.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"Hello World!!!"</span>)</span></span>;<span class="hljs-comment">// convert s to uppercase</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s) <span class="hljs-comment">// for every char in s (note: c is a reference)</span>    c = <span class="hljs-built_in">toupper</span>(c); <span class="hljs-comment">// c is a reference, so the assignment changes the char in s</span><span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><h2 id="15-Processing-Only-Some-Characters"><a href="#15-Processing-Only-Some-Characters" class="headerlink" title="(15) Processing Only Some Characters"></a>(15) Processing Only Some Characters</h2><p>There are two ways to access individual characters in a string: We can use a subscript or an iterator. </p><p>Subscripts for strings start at zero, and the last character is in <code>s[s.size() - 1]</code>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!s.empty()) <span class="hljs-comment">// make sure there's a character to print</span>    <span class="hljs-built_in">cout</span> &lt;&lt; s[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// print the first character in s</span></code></pre><h1 id="3-Library-vector-Type"><a href="#3-Library-vector-Type" class="headerlink" title="3. Library vector Type"></a>3. Library vector Type</h1><p>A vector is a collection of objects, all of which have the same type. Every object in the collection has an associated index, which gives access to that object. </p><p>A vector is often referred to as a container because it “contains” other objects.</p><p>A vector is a class template. C++ has both class and function templates.</p><p>Templates are not themselves functions or classes. Instead, they can be thought of as instructions to the compiler for generating classes or functions.</p><p>Because references are not objects, we cannot have a vector of references.</p><h2 id="1-Defining-and-Initializing-vectors"><a href="#1-Defining-and-Initializing-vectors" class="headerlink" title="(1) Defining and Initializing vectors"></a>(1) Defining and Initializing vectors</h2><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec <span class="hljs-comment">// default initialization; svec is empty</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec1</span><span class="hljs-params">(svec)</span></span>; <span class="hljs-comment">//svec1 has a copy of each element in svec</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec2 = svec; <span class="hljs-comment">//copy elements of svec into svec2</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">"hi"</span>)</span></span>; <span class="hljs-comment">//ten strings; each element is "hi"</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec4</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//ten elements; each an empty string</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// ten elements; each initialized to 0</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ivec1&#123;<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">// one element with value 10</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec5&#123;<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">// ten default-initialized elements</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec6 = &#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"an"</span>&#125;; <span class="hljs-comment">// two elements; list initialization</span></code></pre><h2 id="2-vector-Operations"><a href="#2-vector-Operations" class="headerlink" title="(2) vector Operations"></a>(2) vector Operations</h2><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">100</span>; i++)    v1.push_back(i);</code></pre><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : v1)    i *= i;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//size member returns a value of the size_type </span><span class="hljs-comment">//defined by the corresponding vector type</span><span class="hljs-comment">//vector&lt;int&gt;::size_type</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ivec;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">decltype</span>(ivec.size()) ix = <span class="hljs-number">0</span>; ix != <span class="hljs-number">10</span>; ++ix)    ivec.push_back(ix);</code></pre><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-built_in">cout</span> &lt;&lt; ivec1[<span class="hljs-number">0</span>];</code></pre><h1 id="5-Using-Iterators"><a href="#5-Using-Iterators" class="headerlink" title="5. Using Iterators"></a>5. Using Iterators</h1><p>Types that have iterators have members that <strong>return iterators</strong>. </p><p>In particular, these types have members named <strong>begin</strong> and <strong>end</strong>. </p><p>The begin member returns an iterator that denotes the first element (or first character):</p><pre><code class="hljs cpp"><span class="hljs-comment">// the compiler determines the type of b and e; </span><span class="hljs-comment">// b denotes the first element and e denotes one past the last element </span><span class="hljs-keyword">auto</span> b = v.begin(), e = v.end(); <span class="hljs-comment">// b and e have the same type</span></code></pre><p>The iterator returned by <strong>end</strong> is an iterator positioned <strong>one past the end</strong> of the associated container (or string). </p><p>It is used as a <strong>marker</strong> indicating when we have processed all the elements. </p><p>If the container is <strong>empty</strong>, begin returns the <strong>same</strong> iterator as the one returned by end.</p><p>If the container is empty, the iterators returned by begin and end are equal—they are both off-the-end iterators.</p><p><img src="https://img-blog.csdnimg.cn/20200127201927385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>As with pointers, we can <strong>dereference</strong> an iterator to obtain the element denoted by an iterator.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"some string"</span>)</span></span>;<span class="hljs-keyword">if</span> (s.begin() != s.end()) &#123; <span class="hljs-comment">// make sure s is not empty</span><span class="hljs-keyword">auto</span> it = s.begin(); <span class="hljs-comment">// it denotes the first character in s</span>*it = <span class="hljs-built_in">toupper</span>(*it); <span class="hljs-comment">// make that character uppercase</span>&#125;</code></pre><p>Because the iterator returned from end does not denote an element, it may not be incremented or dereferenced.</p><p>C++ programmers use <strong>!=</strong> as a matter of habit. </p><p>By routinely using iterators and !=, we don’t have to worry about the precise type of container we’re processing.</p><p>As with <code>size_type</code>, the library types that have iterators define types named <strong>iterator</strong> and <strong>const_iterator</strong> that represent actual iterator types:</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it; <span class="hljs-comment">// it can read and write vector&lt;int&gt; elements</span><span class="hljs-built_in">string</span>::iterator it2; <span class="hljs-comment">// it2 can read and write characters in a string</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator it3; <span class="hljs-comment">// it3 can read but not write elements</span><span class="hljs-built_in">string</span>::const_iterator it4; <span class="hljs-comment">// it4 can read but not write</span></code></pre><p>If the object is <code>const</code>, then <code>begin</code> and <code>end</code> return a <code>const_iterator</code>; if the object is not const, they return <code>iterator</code>:</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; cv;<span class="hljs-keyword">auto</span> it1 = v.begin(); <span class="hljs-comment">// it1 has type vector&lt;int&gt;::iterator</span><span class="hljs-keyword">auto</span> it2 = cv.begin(); <span class="hljs-comment">// it2 has type vector&lt;int&gt;::const_iterator</span></code></pre><p>To let us ask specifically for the <strong>const_iterator</strong> type, the new standard introduced two new functions named <strong>cbegin</strong> and <strong>cend</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it3 = v.cbegin(); <span class="hljs-comment">// it3 has type vector&lt;int&gt;::const_iterator</span></code></pre><p>Assuming it is an <code>iterator</code> into this vector, we can check whether the string that it denotes is empty as follows:</p><pre><code class="hljs cpp">(*it).empty()</code></pre><p>The arrow operator (the <strong>-&gt;</strong> operator)combines dereference and member access into a single operation. </p><p>That is, <strong>it-&gt;mem</strong> is a synonym for <strong>(* it).mem</strong>.</p><p>We noted that there are implications of the fact that <strong>vectors</strong> can <strong>grow dynamically</strong>. </p><p>We also noted that one such implication is that we <strong>cannot</strong> add elements to a vector inside a <strong>range for loop</strong>. </p><p>Another implication is that <strong>any operation</strong>, such as <strong>push_back</strong>, that <strong>changes the size of a vector</strong> potentially <strong>invalidates</strong> all iterators into that vector. </p><p><strong>Warning:</strong><br>It is important to realize that loops that use iterators <strong>should not</strong> <strong>add elements</strong> to the container to which the <strong>iterators refer</strong>.</p><p><img src="https://img-blog.csdnimg.cn/20200127211310408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">We can also subtract two iterators so long as they refer to elements in, or one off the end of, the same vector or string. </p><p>The result is the distance between the iterators. </p><p>The result type is a <strong>signed integral type</strong> named <strong>difference_type</strong>.</p><p>A classic algorithm that uses iterator arithmetic is binary search. </p><pre><code class="hljs cpp"><span class="hljs-comment">// text must be sorted</span><span class="hljs-comment">// beg and end will denote the range we're searching</span><span class="hljs-keyword">auto</span> beg = text.begin(), end = text.end();<span class="hljs-keyword">auto</span> mid = text.begin() + (end - beg)/<span class="hljs-number">2</span>; <span class="hljs-comment">// original midpoint</span><span class="hljs-keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;    <span class="hljs-keyword">if</span> (sought &lt; *mid) <span class="hljs-comment">// is the element we want in the first half?</span>        end = mid; <span class="hljs-comment">// if so, adjust the range to ignore the second half</span>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// the element we want is in the second half</span>        beg = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// start looking with the element just after mid</span>    mid = beg + (end - beg)/<span class="hljs-number">2</span>; <span class="hljs-comment">// new midpoint</span>&#125;</code></pre><h1 id="6-Arrays"><a href="#6-Arrays" class="headerlink" title="6. Arrays"></a>6. Arrays</h1><h2 id="1-Difference-between-array-and-vector"><a href="#1-Difference-between-array-and-vector" class="headerlink" title="(1) Difference between array and vector"></a>(1) Difference between array and vector</h2><p><strong>Like a vector</strong>, an array is a <strong>container</strong> of <strong>unnamed objects</strong> of a <strong>single type</strong> that we access by position.</p><p><strong>Unlike a vector</strong>, arrays have <strong>fixed size</strong>; we cannot add elements to an array.</p><h2 id="2-Complicated-Array-Declarations"><a href="#2-Complicated-Array-Declarations" class="headerlink" title="(2) Complicated Array Declarations"></a>(2) Complicated Array Declarations</h2><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ptrs[<span class="hljs-number">10</span>]; <span class="hljs-comment">// ptrs is an array of ten pointers to int</span><span class="hljs-keyword">int</span> &amp;refs[<span class="hljs-number">10</span>] = <span class="hljs-comment">/* ? */</span>; <span class="hljs-comment">// error: no arrays of references</span><span class="hljs-keyword">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr; <span class="hljs-comment">// Parray points to an array of ten ints</span><span class="hljs-keyword">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr; <span class="hljs-comment">// arrRef refers to an array of ten ints</span></code></pre><p>There are no limits on how many type modifiers can be used:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *(&amp;arry)[<span class="hljs-number">10</span>] = ptrs; <span class="hljs-comment">// arry is a reference to an array of ten pointers</span></code></pre><h2 id="3-Pointers-and-Arrays"><a href="#3-Pointers-and-Arrays" class="headerlink" title="(3) Pointers and Arrays"></a>(3) Pointers and Arrays</h2><p>In particular, as we’ll see, when we use an array, the compiler ordinarily <strong>converts the array to a pointer</strong>.</p><p>When we use an array as an initializer for a variable defined using <strong>auto</strong>, the deduced type is a <strong>pointer</strong>, <strong>not an array</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// ia is an array of ten ints</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>; <span class="hljs-comment">// ia2 is an int* that points to the first element in ia</span>ia2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// error: ia2 is a pointer, and we can't assign an int to a pointer</span></code></pre><p>It is worth noting that this conversion does not happen when we use <strong>decltype</strong>. The type returned by <code>decltype(ia)</code> is <strong>array</strong> of ten ints:</p><pre><code class="hljs cpp"><span class="hljs-comment">// ia3 is an array of ten ints</span><span class="hljs-keyword">decltype</span>(ia) ia3 = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;ia3 = p; <span class="hljs-comment">// error: can't assign an int* to an array</span>ia3[<span class="hljs-number">4</span>] = i; <span class="hljs-comment">// ok: assigns the value of i to an element in ia3</span></code></pre><h2 id="4-The-Library-begin-and-end-Functions"><a href="#4-The-Library-begin-and-end-Functions" class="headerlink" title="(4) The Library begin and end Functions"></a>(4) The Library begin and end Functions</h2><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// ia is an array of ten ints</span><span class="hljs-keyword">int</span> *beg = begin(ia); <span class="hljs-comment">// pointer to the first element in ia</span><span class="hljs-keyword">int</span> *last = end(ia); <span class="hljs-comment">// pointer one past the last element in ia</span></code></pre><p><strong>begin</strong> returns a <strong>pointer to the first</strong>, and <strong>end</strong> returns a <strong>pointer one past the last element</strong> in the given array. These functions are defined in the <strong>iterator header</strong>.</p><h2 id="5-Pointer-Arithmetic"><a href="#5-Pointer-Arithmetic" class="headerlink" title="(5) Pointer Arithmetic"></a>(5) Pointer Arithmetic</h2><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *b = arr, *e = arr + sz;<span class="hljs-keyword">while</span> (b &lt; e) &#123;<span class="hljs-comment">// use *b</span>    ++b;&#125;</code></pre><p><strong>We cannot use the relational operators on pointers to two unrelated objects:</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, sz = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> *p = &amp;i, *e = &amp;sz;<span class="hljs-comment">// undefined: p and e are unrelated; comparison is meaningless!</span><span class="hljs-keyword">while</span> (p &lt; e)</code></pre><h2 id="6-Subscripts-and-Pointers"><a href="#6-Subscripts-and-Pointers" class="headerlink" title="(6) Subscripts and Pointers"></a>(6) Subscripts and Pointers</h2><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = &amp;ia[<span class="hljs-number">2</span>]; <span class="hljs-comment">// p points to the element indexed by 2</span><span class="hljs-keyword">int</span> j = p[<span class="hljs-number">1</span>]; <span class="hljs-comment">// p[1] is equivalent to *(p + 1),</span><span class="hljs-comment">// p[1] is the same element as ia[3]</span><span class="hljs-keyword">int</span> k = p[<span class="hljs-number">-2</span>]; <span class="hljs-comment">// p[-2] is the same element as ia[0]</span></code></pre><p>Unlike subscripts for vector and string, the <strong>index of the built-in subscript</strong> operator is <strong>not an unsigned type</strong>.</p><h1 id="7-Multidimensional-Arrays"><a href="#7-Multidimensional-Arrays" class="headerlink" title="7. Multidimensional Arrays"></a>7. Multidimensional Arrays</h1><p>Strictly speaking, there are no multidimensional arrays in C++. What are commonly referred to as multidimensional arrays are actually <strong>arrays of arrays</strong>. </p><h2 id="1-Using-a-Range-for-with-Multidimensional-Arrays"><a href="#1-Using-a-Range-for-with-Multidimensional-Arrays" class="headerlink" title="(1) Using a Range for with Multidimensional Arrays"></a>(1) Using a Range for with Multidimensional Arrays</h2><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> rowCnt = <span class="hljs-number">3</span>, colCnt = <span class="hljs-number">4</span>;<span class="hljs-keyword">int</span> ia[rowCnt][colCnt]; <span class="hljs-comment">// 12 uninitialized elements</span><span class="hljs-comment">// for each row</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i != rowCnt; ++i) &#123;    <span class="hljs-comment">// for each column within the row</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> j = <span class="hljs-number">0</span>; j != colCnt; ++j) &#123;        <span class="hljs-comment">// assign the element's positional index as its value</span>        ia[i][j] = i * colCnt + j;    &#125;&#125;</code></pre><p>same as</p><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> rowCnt = <span class="hljs-number">3</span>, colCnt = <span class="hljs-number">4</span>;<span class="hljs-keyword">int</span> ia[rowCnt][colCnt];<span class="hljs-keyword">size_t</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;row : ia) <span class="hljs-comment">// for every element in the outer array</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;col : row) &#123; <span class="hljs-comment">// for every element in the inner array</span>        col = cnt; <span class="hljs-comment">// give this element the next value</span>        ++cnt; <span class="hljs-comment">// increment cnt</span>&#125;</code></pre><p><font color = red>note</font><br>To use a multidimensional array in a range for, the loop control variable for<br>all but the innermost array must be <strong>references</strong>.</p><h2 id="2-Pointers-and-Multidimensional-Arrays"><a href="#2-Pointers-and-Multidimensional-Arrays" class="headerlink" title="(2) Pointers and Multidimensional Arrays"></a>(2) Pointers and Multidimensional Arrays</h2><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]; <span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">4</span>] = ia; <span class="hljs-comment">// p points to an array of four ints</span>p = &amp;ia[<span class="hljs-number">2</span>]; <span class="hljs-comment">// p now points to the last element in ia</span></code></pre><pre><code class="hljs cpp"><span class="hljs-comment">// p points to an array of four ints</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = ia; p != ia + <span class="hljs-number">3</span>; ++p) &#123;    <span class="hljs-comment">// q points to the first element of an array of four ints;</span>    <span class="hljs-comment">//that is, q points to an int</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> q = *p; q != *p + <span class="hljs-number">4</span>; ++q)        <span class="hljs-built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="hljs-string">' '</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><p>we can even more easily write this loop using the library <code>begin</code> and <code>end</code> functions：</p><pre><code class="hljs cpp"><span class="hljs-comment">// p points to the first array in ia</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = begin(ia); p != end(ia); ++p) &#123;    <span class="hljs-comment">// q points to the first element in an inner array</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> q = begin(*p); q != end(*p); ++q)        <span class="hljs-built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="hljs-string">' '</span>;     <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Variables and Basic Types</title>
    <link href="/2020/12/29/Variables-and-Basic-Types/"/>
    <url>/2020/12/29/Variables-and-Basic-Types/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 2 Variables and Basic Types</p><a id="more"></a><h1 id="1-Initializers"><a href="#1-Initializers" class="headerlink" title="1. Initializers"></a>1. Initializers</h1><p>An object that is initialized gets the specified value at the moment it is created.</p><p><strong>Warning:</strong><br><strong>Initialization is not assignment.</strong><br>Initialization happens when a variable is given a value when it is created. </p><p>Assignment obliterates an object’s current value and replaces that value with a new one.</p><h2 id="1-List-Initialization"><a href="#1-List-Initialization" class="headerlink" title="(1). List Initialization"></a>(1). List Initialization</h2><p>The language defines several different forms of initialization:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> units_sold = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> units_sold = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> units_sold&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">units_sold</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;</code></pre><p>The generalized use of curly braces for initialization is referred to as <strong>list initialization</strong>.</p><p>The compiler will not let us <strong>list initialize</strong> variables of built-in type if<br>the initializer might lead to the <strong>loss of information</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> ld = <span class="hljs-number">3.1415926536</span>;<span class="hljs-keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class="hljs-comment">// error: narrowing conversion required</span>int c(ld), d = ld; // ok: but value will be truncated</code></pre><h2 id="2-Default-Initialization"><a href="#2-Default-Initialization" class="headerlink" title="(2) Default Initialization"></a>(2) Default Initialization</h2><p>When we define a variable without an initializer, the variable is <strong>default initialized</strong>.</p><p>The value of an object of <strong>built-in type</strong> that is <strong>not explicitly initialized</strong> depends on <strong>where it is defined</strong>. </p><p>Variables defined <strong>outside any function</strong> body are initialized to <strong>zero</strong>.</p><p>variables of <strong>built-in type</strong> defined <strong>inside a function</strong> are <strong>uninitialized</strong>.<br>It is an error to copy or otherwise try to access the value of a variable whose value is undefined.</p><p>Objects of <strong>class type</strong> that we do not explicitly initialize have a value that is defined by the class.</p><p>Different of forms of initialization</p><p><a href="https://stackoverflow.com/questions/1051379/is-there-a-difference-between-copy-initialization-and-direct-initialization" target="_blank" rel="noopener">Is there a difference between copy initialization and direct initialization?</a></p><p><a href="https://stackoverflow.com/questions/29068684/different-forms-of-initialization" target="_blank" rel="noopener">Different forms of initialization</a></p><p><a href="http://www.cplusplus.com/doc/tutorial/variables/" target="_blank" rel="noopener">Initialization of variables</a></p><p><a href="http://eel.is/c++draft/dcl.init" target="_blank" rel="noopener">Initializers </a></p><h1 id="2-Identifiers"><a href="#2-Identifiers" class="headerlink" title="2. Identifiers"></a>2. Identifiers</h1><p>Identifiers in C++ can be composed of letters, digits, and the underscore character.</p><p>The language imposes no limit on name length. </p><p>Identifiers must begin with either a letter or an underscore. Identifiers are case-sensitive; upper- and lowercase letters are distinct.</p><p>The language reserves a set of names. These names may not be used as identifiers.<br><img src="https://img-blog.csdnimg.cn/20200124175004976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>The standard also reserves a set of names for use in the standard library. </p><p>The <strong>identifiers</strong> may not contain two consecutive underscores, nor can an identifier <strong>begin with an underscore followed immediately by an uppercase letter</strong>.</p><p>In addition, identifiers defined <strong>outside a function may not begin with an underscore</strong>.</p><h1 id="3-const-Qualifier"><a href="#3-const-Qualifier" class="headerlink" title="3. const Qualifier"></a>3. const Qualifier</h1><h2 id="1-Initialization"><a href="#1-Initialization" class="headerlink" title="(1) Initialization"></a>(1) Initialization</h2><p>We can make a variable unchangeable by defining the variable’s type as const:</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = <span class="hljs-number">512</span>; <span class="hljs-comment">// input buffer size</span></code></pre><p><strong>Because we can’t change the value of a const object after we create it, it must be initialized.</strong> </p><p>By default, const objects are Local to a file. When a const object is initialized from a compile-time constant, such as in our definition of bufSize:</p><p>The compiler will usually <strong>replace</strong> uses of the variable with its corresponding value <strong>during compilation</strong>. That is, the compiler will generate code using the value <code>512</code> in the places that our code uses <code>bufSize</code>.</p><p>To substitute the value for the variable, the compiler has to see the variable’s initializer. </p><p>When we split a program into multiple files, every file that uses the <strong>const</strong> must have access to its initializer.</p><p>In order to see the initializer, the variable must be defined in every file that wants to use the variable’s value. </p><p>To support this usage, yet avoid multiple definitions of the same variable, <strong>const</strong> variables are defined as local to the file. </p><p><strong>Sometimes we have a const variable that we want to share across multiple files but whose initializer is not a constant expression.</strong></p><p>To define a single instance of a <strong>const</strong> variable, we use the keyword <strong>extern</strong> on <strong>both its definition and declaration(s)</strong>:</p><pre><code class="hljs cpp"><span class="hljs-comment">// file_1.cc defines and initializes a const that </span><span class="hljs-comment">// is accessible to other files</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = fcn();<span class="hljs-comment">// file_1.h</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize; <span class="hljs-comment">// same bufSize as defined in file_1.cc</span></code></pre><p>In this program, <code>file_1.cc</code> defines and initializes <code>bufSize</code>. Because this declaration includes an initializer, it is (as usual) a definition. </p><p>However, because <code>bufSize</code> is <strong>const</strong>, we must specify <strong>extern</strong> in order for <code>bufSize</code> to be used in other files.</p><p>The declaration in <code>file_1.h</code> is also <code>extern</code>. In this case, the <code>extern</code> signifies that <code>bufSize</code> is not local to this file and that its definition will occur elsewhere.</p><h2 id="2-References-to-const"><a href="#2-References-to-const" class="headerlink" title="(2) References to const"></a>(2) References to const</h2><p>As with any other object, we can bind a reference to an object of a <strong>const</strong> type. </p><p>To do so we use a <strong>reference to const</strong>, which is a reference that refers to a <strong>const</strong> type.</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">1024</span>;<span class="hljs-comment">// ok: both reference and underlying object are const</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = ci; r1 = <span class="hljs-number">42</span>; <span class="hljs-comment">// error: r1 is a reference to const</span><span class="hljs-keyword">int</span> &amp;r2 = ci; <span class="hljs-comment">// error: non const reference to a const object</span></code></pre><p><strong>Terminology: const Reference is a Reference to const.</strong></p><p>C++ programmers tend to abbreviate the phrase “reference to const” as “const reference.” </p><p>Technically speaking, there are no <strong>const references</strong>. A reference is <strong>not an object</strong>, so we cannot make a reference itself <strong>const</strong>.</p><p>Indeed, because there is no way to make a reference refer to a different object, in some sense all references are <strong>const</strong>. </p><p><strong>Two exceptions to the rule that the type of a reference must match the type of the object to which it refers:</strong></p><ol><li><strong>We can initialize a reference to const from any expression that can be converted to the type of the reference.</strong> </li></ol><p>In particular, we can bind a reference to <strong>const</strong> to a <strong>nonconst</strong> object, a literal, or a more general expression:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = i; <span class="hljs-comment">// we can bind a const int&amp; to a plain int object</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// ok: r1 is a reference to const</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r3 = r1 * <span class="hljs-number">2</span>; <span class="hljs-comment">// ok: r3 is a reference to const</span><span class="hljs-keyword">int</span> &amp;r4 = r1 * <span class="hljs-number">2</span>; <span class="hljs-comment">// error: r4 is a plain, non const reference</span></code></pre><p>The easiest way to understand this difference in initialization rules is to consider what happens when we bind a reference to an object of a different type:</p><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ri = dval;</code></pre><p>To ensure that the object to which <code>ri</code> is bound is an <code>int</code>, the compiler transforms this code into something like:</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> temp = dval; <span class="hljs-comment">// create a temporary const int from the double</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ri = temp; <span class="hljs-comment">// bind ri to that temporary</span></code></pre><p>In this case, <code>ri</code> is bound to a <strong>temporary</strong> object. A temporary object is an unnamed object created by the compiler when it needs a place to store a result from evaluating an expression. </p><p>C++ programmers often use the word <strong>temporary</strong> as an abbreviation for temporary object.</p><p><strong>Now consider what could happen if this initialization were allowed but ri was not const:</strong> </p><p>If <code>ri</code> weren’t <strong>const</strong>, we could assign to <code>ri</code>. Doing so would change the object to which <code>ri</code> is bound. However, that object is a temporary, not <code>dval</code>. </p><p>Because binding a reference to a temporary is almost surely not what the programmer intended, the language makes it illegal.</p><ol start="2"><li><strong>A Reference to const May Refer to an Object That Is Not const</strong></li></ol><p>It is important to realize that a reference to const <strong>restricts only what we can do through that reference</strong>. </p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> &amp;r1 = i; <span class="hljs-comment">// r1 bound to i</span><span class="hljs-comment">// r2 also bound to i; but cannot be used to change i</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = i; <span class="hljs-comment">//r2 is not a const object, it can be changed</span>r1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// r1 is not const; i is now 0; r2 = 0;</span>r2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// error: r2 is a reference to const</span></code></pre><p>Even so, <strong>the value int i still might change</strong>. We can change <code>i</code> by assigning to it directly, or by assigning to another reference bound to <code>i</code>, such as <code>r1</code>.</p><h2 id="3-Pointers-and-const"><a href="#3-Pointers-and-const" class="headerlink" title="(3) Pointers and const"></a>(3) Pointers and const</h2><p>Like a reference to <strong>const</strong>, a pointer to <strong>const</strong> may not be used to change the object to which the pointer points. </p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// pi is const; its value may not be changed</span><span class="hljs-keyword">double</span> *ptr = &amp;pi; <span class="hljs-comment">// error: ptr is a plain pointer</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *cptr = &amp;pi; <span class="hljs-comment">// ok: cptr may point to a double that is const</span>*cptr = <span class="hljs-number">42</span>; <span class="hljs-comment">// error: cannot assign to *cptr</span></code></pre><p><strong>There are two exceptions to the rule that the types of a pointer and the object to which it points must match:</strong></p><ol><li><strong>We can use a pointer to const to point to a nonconst object</strong></li></ol><p> <strong>Like a reference to const</strong>, a pointer to <strong>const</strong> says nothing about whether the object to which the pointer points is <strong>const</strong>. </p><p>Defining a <strong>pointer</strong> as a <strong>pointer to const</strong> affects only <strong>what we can do with the pointer.</strong> </p><p>It is important to remember that there is <strong>no guarantee that an object pointed to by a pointer to const won’t change</strong>.</p><ol start="2"><li><strong>Unlike references, pointers are objects</strong> </li></ol><p>Hence, as with any other object type, we can have a pointer that is itself <strong>const</strong>. </p><p>Like any other <strong>const object</strong>, a const pointer must be initialized, and once initialized, its value may not be changed. </p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> errNumb = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> curErr = &amp;errNumb; <span class="hljs-comment">// curErr will always point to errNumb</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14159</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *<span class="hljs-keyword">const</span> pip = &amp;pi; <span class="hljs-comment">// pip is a const pointer to a const object</span></code></pre><h2 id="4-Top-Level-const"><a href="#4-Top-Level-const" class="headerlink" title="(4) Top-Level const"></a>(4) Top-Level const</h2><p>We use the term <strong>top-level const</strong> to indicate that the pointer itself is a <strong>const</strong>. </p><p>When a pointer can point to a <strong>const</strong> object, we refer to that <strong>const</strong> as a <strong>low-level const</strong>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">// we can't change the value of p1; const is top-level</span><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p1 = &amp;i; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">42</span>; <span class="hljs-comment">// we cannot change ci; const is top-level</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p2 = &amp;ci; <span class="hljs-comment">// we can change p2; const is low-level</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p3 = p2; <span class="hljs-comment">// right-most const is top-level, left-most is not</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r = ci; <span class="hljs-comment">// const in reference types is always low-level</span></code></pre><p>The <strong>distinction</strong> between top-level and low-level matters when we copy an object. </p><p><strong>When we copy an object, top-level consts are ignored:</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">// ok: copying the value of ci; top-level const in ci is ignored</span>i = ci; <span class="hljs-comment">// ok: pointed-to type matches; top-level const in p3 is ignored</span>p2 = p3;</code></pre><p>Copying an object doesn’t change the copied object. As a result, it is immaterial whether the object copied from or copied into is <strong>const</strong>.</p><p>On the other hand, <strong>low-level const is never ignored</strong>. </p><p>When we copy an object, both objects must have the same <strong>low-level const</strong> qualification or there must be a conversion between the types of the two objects. </p><p>In general, we can convert a <strong>nonconst</strong> to <strong>const</strong> but not the other way round:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = p3; <span class="hljs-comment">// error: p3 has a low-level const but p doesn't</span>p2 = p3; <span class="hljs-comment">// ok: p2 has the same low-level const qualification as p3</span>p2 = &amp;i; <span class="hljs-comment">// ok: we can convert int* to const int*</span><span class="hljs-comment">// error: can't bind an ordinary int&amp; to a const int object</span><span class="hljs-keyword">int</span> &amp;r = ci; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = i; <span class="hljs-comment">// ok: can bind const int&amp; to plain int</span></code></pre><h2 id="5-int-const-const-int-and-int-const"><a href="#5-int-const-const-int-and-int-const" class="headerlink" title="(5) int const * , const int * and int *const"></a>(5) int const * , const int * and int *const</h2><p><a href="https://stackoverflow.com/a/1143272/12342782" target="_blank" rel="noopener">What is the difference between const int*, const int * const, and int const *</a></p><p><a href="https://www.cdecl.org/" target="_blank" rel="noopener">website to auto-translates C declarations </a></p><p><a href="http://c-faq.com/decl/spiral.anderson.html" target="_blank" rel="noopener">Clockwise/Spiral Rule</a></p><pre><code class="hljs nimrod"><span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> *p; // declare p <span class="hljs-keyword">as</span> <span class="hljs-built_in">pointer</span> to <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> *p; // same <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> * p<span class="hljs-built_in">int</span> * <span class="hljs-keyword">const</span> p; // declare p <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">pointer</span> to <span class="hljs-built_in">int</span></code></pre><h2 id="5-Constant-Expressions"><a href="#5-Constant-Expressions" class="headerlink" title="(5) Constant Expressions"></a>(5) Constant Expressions</h2><p>A constant expression is an expression whose value cannot change and that <strong><font color = red>can be evaluated at compile time</strong>.</font> </p><p>A literal is a constant expression. </p><p>A <strong>const</strong> object that is initialized from a constant expression is also a constant expression.</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max_files = <span class="hljs-number">20</span>; <span class="hljs-comment">// max_files is a constant expression</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> limit = max_files + <span class="hljs-number">1</span>; <span class="hljs-comment">// limit is a constant expression</span><span class="hljs-keyword">int</span> staff_size = <span class="hljs-number">27</span>; <span class="hljs-comment">// staff_size is not a constant expression</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = get_size(); <span class="hljs-comment">// sz is not a constant expression</span></code></pre><h2 id="6-Constexpr-Variables"><a href="#6-Constexpr-Variables" class="headerlink" title="(6) Constexpr Variables"></a>(6) Constexpr Variables</h2><p>In a large system, it can be difficult to determine (for certain) that an initializer is a <strong>constant expression</strong>.</p><p>In general, the definition of an object and its use in such a context can be widely separated.</p><p>Under the new standard, we can ask the compiler to verify that a variable is a <strong>constant expression</strong> by declaring the variable in a <strong>constexpr</strong> declaration. </p><p>Variables declared as <strong>constexpr</strong> are <strong>implicitly const</strong> and must be initialized by <strong>constant expressions</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> mf = <span class="hljs-number">20</span>; <span class="hljs-comment">// 20 is a constant expression</span><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> limit = mf + <span class="hljs-number">1</span>; <span class="hljs-comment">// mf + 1 is a constant expression</span><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> sz = size(); <span class="hljs-comment">// ok only if size is a constexpr function</span></code></pre><p>Although we cannot use an ordinary function as an initializer for a <strong>constexpr</strong> variable, the new standard lets us define certain<br>functions as <strong>constexpr</strong>. </p><p>Such functions must be <strong>simple enough</strong> that the compiler can evaluate them at <strong>compile time</strong>. </p><p>We can use <strong>constexpr</strong> functions in the initializer of a <strong>constexpr</strong> variable.</p><p>The types we can use in a <strong>constexpr</strong> are known as “<strong>literal types</strong>“ because they are simple enough to have literal values.</p><p>Variables <strong>defined inside a function</strong> ordinarily are <strong>not</strong> stored at a <strong>fixed address</strong>. Hence, we cannot use a <strong>constexpr</strong> pointer to point to such variables. </p><p>On the other hand, the address of an object defined <strong>outside of any function</strong> is a <strong>constant expression</strong>, and so may be used to initialize a <strong>constexpr</strong> pointer. </p><h2 id="7-Pointers-and-constexpr"><a href="#7-Pointers-and-constexpr" class="headerlink" title="(7) Pointers and constexpr"></a>(7) Pointers and constexpr</h2><p>It is important to understand that when we define a pointer in a <strong>constexpr</strong> declaration, the <strong>constexpr</strong> specifier applies to the <strong>pointer</strong>, <strong>not</strong> the type to which the pointer points:</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// p is a pointer to a const int</span><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *q = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// q is a const pointer to int</span></code></pre><h1 id="4-Dealing-with-Types"><a href="#4-Dealing-with-Types" class="headerlink" title="4. Dealing with Types"></a>4. Dealing with Types</h1><h2 id="1-auto"><a href="#1-auto" class="headerlink" title="(1) auto"></a>(1) auto</h2><p>Under the new standard, we can let the compiler figure out the type for us by using the <strong>auto</strong> type specifier. </p><p><strong>auto</strong> tells the compiler to deduce the type from the <strong>initializer</strong>. </p><p>By implication, a variable that uses <strong>auto</strong> as its type specifier must have an <strong>initializer</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> item = val1 + val2; <span class="hljs-comment">// item initialized to the result of val1 + val2</span></code></pre><p>As with any other type specifier, we can define <strong>multiple variables</strong> using <strong>auto</strong>.</p><p>Because a declaration can involve only <strong>a single base type</strong>, the initializers for all the variables in the declaration must have types that are <strong>consistent</strong> with each other:</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i; <span class="hljs-comment">// ok: i is int and p is a pointer to int</span><span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>, pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// error: inconsistent types for sz and pi</span></code></pre><p>The type that the compiler infers for <strong>auto</strong> is <strong>not always exactly the same as the initializer’s type</strong>. Instead, the compiler adjusts the type to conform to normal initialization rules.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, &amp;r = i;<span class="hljs-keyword">auto</span> a = r; <span class="hljs-comment">// a is an int (r is an alias for i, which has type int)</span></code></pre><p><strong>auto</strong> ordinarily ignores top-level consts. As usual in initializations, <strong>low-level consts, such as when an initializer is a pointer to const, are kept</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i, &amp;cr = ci;<span class="hljs-keyword">auto</span> b = ci; <span class="hljs-comment">// b is an int (top-level const in ci is dropped)</span><span class="hljs-comment">// c is an int (cr is an alias for ci whose const is top-level)</span><span class="hljs-keyword">auto</span> c = cr; <span class="hljs-keyword">auto</span> d = &amp;i; <span class="hljs-comment">// d is an int*(&amp; of an int object is int*)</span><span class="hljs-comment">// e is const int*(&amp; of a const object is low-level const)</span><span class="hljs-keyword">auto</span> e = &amp;ci;</code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> f = ci; <span class="hljs-comment">// deduced type of ci is int; f has type const int</span></code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> &amp;g = ci; <span class="hljs-comment">// g is a const int&amp; that is bound to ci</span><span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>; <span class="hljs-comment">// error: we can't bind a plain reference to a literal</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;j = <span class="hljs-number">42</span>; <span class="hljs-comment">// ok: we can bind a const reference to a literal</span></code></pre><p>When we ask for a reference to an auto-deduced type, <strong>top-level consts in the initializer are not ignored</strong>. </p><p>As usual, <strong>consts are not top-level when we bind a reference to an initializer</strong>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> k = ci, &amp;l = i; <span class="hljs-comment">// k is int; l is int&amp;</span><span class="hljs-keyword">auto</span> &amp;m = ci, *p = &amp;ci; <span class="hljs-comment">// m is a const int&amp;;p is a pointer to const int</span><span class="hljs-comment">// error: type deduced from i is int; type deduced from &amp;ci is const int</span><span class="hljs-keyword">auto</span> &amp;n = i, *p2 = &amp;ci;</code></pre><h2 id="2-decltype"><a href="#2-decltype" class="headerlink" title="(2) decltype"></a>(2) decltype</h2><p>Sometimes we want to define a variable with a type that the compiler <strong>deduces from an expression but do not want to use</strong> that expression to initialize the variable. </p><p>For such cases, the new standard introduced a second type specifier, <strong>decltype</strong>, which returns the type of its operand. </p><p>The compiler analyzes the expression to determine its type but does not evaluate the expression:</p><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>(f()) sum = x; <span class="hljs-comment">// sum has whatever type f returns</span></code></pre><p>Here, the compiler <strong>does not call f</strong>, but it uses the type that such a call would return as the type for <code>sum</code>.</p><p>The way <strong>decltype</strong> handles <strong>top-level const and references</strong> differs subtly from the way <strong>auto</strong> does. </p><p>When the expression to which we apply <strong>decltype</strong> is a variable, <strong>decltype</strong> returns the type of that variable, including top-level const and references:</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>; <span class="hljs-comment">// x has type const int</span><span class="hljs-keyword">decltype</span>(cj) y = x; <span class="hljs-comment">// y has type const int&amp; and is bound to x</span><span class="hljs-keyword">decltype</span>(cj) z; <span class="hljs-comment">// error: z is a reference and must be initialized</span></code></pre><pre><code class="hljs cpp"><span class="hljs-comment">// decltype of an expression can be a reference type</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>, *p = &amp;i, &amp;r = i;<span class="hljs-comment">// ok: addition yields an int; b is an (uninitialized) int</span><span class="hljs-keyword">decltype</span>(r + <span class="hljs-number">0</span>) b; <span class="hljs-keyword">decltype</span>(*p) c; <span class="hljs-comment">// error: c is int&amp; and must be initialized</span></code></pre><p>Here <code>r</code> is a reference, so <code>decltype(r)</code> is a <strong>reference type</strong>. If we want the type to which <code>r</code> refers, we can use <code>r</code> in an expression, such as <code>r + 0</code>, which is an expression that yields a value that has a <strong>nonreference</strong> type.</p><p>On the other hand, the <strong>dereference operator</strong> is an example of an expression for which <strong>decltype</strong> returns a reference. </p><p>As we’ve seen, when we dereference a pointer, we get the object to which the pointer points. Moreover, we can assign to that object.</p><p>Thus, <strong>the type deduced by *<em>decltype(\</em>p)</strong> is <strong>int&amp;</strong>, not plain int**.</p><p>Another <strong>important difference</strong> between <strong>decltype and auto</strong> is that the deduction done by decltype depends on the form of its given expression.</p><p>When we apply <strong>decltype</strong> to a variable <strong>without any parentheses</strong>, we get the type of that variable. </p><p>If we <strong>wrap the variable’s name</strong> in one or more sets of parentheses, the compiler will evaluate the operand as an expression.</p><p>A variable is an expression that can be the left-hand side of an assignment. </p><p><strong>As a result, decltype on such an expression yields a reference:</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">// decltype of a parenthesized variable is always a reference</span><span class="hljs-keyword">decltype</span>((i)) d; <span class="hljs-comment">// error: d is int&amp; and must be initialized</span><span class="hljs-keyword">decltype</span>(i) e; <span class="hljs-comment">// ok: e is an (uninitialized) int</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Getting Started</title>
    <link href="/2020/12/29/Getting-Started/"/>
    <url>/2020/12/29/Getting-Started/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 1 Getting Started</p><a id="more"></a><h1 id="1-Formatting-of-C-Programs"><a href="#1-Formatting-of-C-Programs" class="headerlink" title="1. Formatting of C++ Programs"></a>1. Formatting of C++ Programs</h1><p>C++ programs are largely free-format, meaning that where we put curly braces, indentation, comments, and newlines usually has no effect on what our programs mean. </p><pre><code class="hljs cpp"><span class="hljs-comment">//c++</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello"</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; <span class="hljs-string">"world"</span> &lt;&lt; <span class="hljs-string">"!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs cpp">Hello world!</code></pre><p>That’s because C++’s free format rules treat <strong>newlines and spaces between tokens interchangeably</strong>.</p><p>与c 语言相同，但双引号中的内容不能直接换行分开。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello\n"</span>);https:<span class="hljs-comment">//blog.csdn.net/Lee567/article/details/100099573#4_printf__148)</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre><p><a href="https://lxwcd.github.io/2020/11/28/Charater-Strings-and-Formatted-Input-Output/#4-Printing-Long-Strings">printf() Printing long strings</a></p><h1 id="2-lt-lt-Operator"><a href="#2-lt-lt-Operator" class="headerlink" title="2. &lt;&lt; Operator"></a>2. &lt;&lt; Operator</h1><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter two numbers:"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</code></pre><p>The <code>&lt;&lt;</code> operator takes two operands: The <strong>left-hand</strong> operand must be an <strong>ostream</strong> object; the <strong>right-hand</strong> operand is a <strong>value to print</strong>. </p><p>The operator <strong>writes</strong> the given value on the given <strong>ostream</strong>. </p><p>The <strong>result</strong> of the <strong>output operator</strong> is its <strong>left-hand operand</strong>. </p><p>As a result, we can chain together output requests. </p><p>Thus, our expression is equivalent to</p><pre><code class="hljs cpp">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter two numbers:"</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</code></pre><p>The <strong>second operator</strong> prints <code>endl</code>, which is a special value called a <strong>manipulator</strong>. Writing <code>endl</code> has the effect of ending the current line and <strong>flushing</strong> the buffer associated with that device. </p><p>Flushing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.</p><h1 id="3-Reading-an-Unknown-Number-of-Inputs"><a href="#3-Reading-an-Unknown-Number-of-Inputs" class="headerlink" title="3. Reading an Unknown Number of Inputs"></a>3. Reading an Unknown Number of Inputs</h1><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, value = <span class="hljs-number">0</span>;    <span class="hljs-comment">// read until end-of-file, calculating a running total of all values read</span>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; value)        sum += value; <span class="hljs-comment">// equivalent to sum = sum + value</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sum is: "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; value)</code></pre><p>Evaluating the while condition executes the expression<br><code>std::cin &gt;&gt; value</code> .</p><p>When we use an <code>istream</code> as a condition, the effect is to test the state of the stream. </p><p>If the stream is valid—that is, if the stream hasn’t encountered an error, then the test succeeds. </p><p>An <code>istream</code> becomes invalid when we hit <strong>end-of-file</strong> or encounter an <strong>invalid input</strong>, such as reading a value that is not an integer. </p><p>An <code>istream</code> that is in an invalid state will cause the condition to yield false.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The C Processor and the C Library</title>
    <link href="/2020/12/09/The-C-Processor-and-the-C-Library/"/>
    <url>/2020/12/09/The-C-Processor-and-the-C-Library/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 16 The C Processor and the C Library</p><a id="more"></a><p>The <strong>preprocessor</strong> looks at your program <strong>before</strong> it is <strong>compiled</strong> (hence the term <strong>preprocessor</strong>).</p><p>Following your <strong>preprocessor</strong> directives, the <strong>preprocessor</strong> <strong>replaces</strong> the <strong>symbolic abbreviations</strong> in your program with the <strong>directions</strong> they represent. </p><p>The <strong>preprocessor</strong> can include other files at your request, and it can select which code the compiler sees. </p><p>The <strong>preprocessor</strong> doesn’t know about <strong>C</strong>. Basically, it takes some text and <strong>converts</strong> it to other text. This description does <strong>not do justice</strong> to its true utility and value.</p><h1 id="1-First-Steps-in-Translating-a-Program"><a href="#1-First-Steps-in-Translating-a-Program" class="headerlink" title="1. First Steps in Translating a Program"></a>1. First Steps in Translating a Program</h1><p>The <strong>compiler</strong> has to put a program through some <strong>translation phases</strong> before jumping into <strong>preprocessing</strong>. </p><ol><li><p>The <strong>compiler</strong> <strong>starts</strong> its work by <strong>mapping characters</strong> appearing in the source code to the <strong>source character set</strong>.  This takes care of <strong>multibyte</strong> characters and <strong>trigraphs</strong>—character extensions that make the outer face of C more international. </p></li><li><p>The <strong>compiler</strong> locates each instance of a <strong>backslash</strong> followed by a <strong>newline character</strong> and <strong>deletes</strong> them. That is, two physical lines such as</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"That's wond\</span><span class="hljs-string">erful!\n"</span>);</code></pre><p>are converted to <strong>a single logical line</strong>:</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"That's wonderful\n!"</span>);</code></pre><p>Note that in this context, <strong>“newline character”</strong> means the character produced by pressing the <code>Enter key</code> to start a new line in your source code file; it <strong>doesn’t</strong> mean the symbolic representation <code>\n</code>.</p></li><li><p>The <strong>compiler</strong> breaks the text into a sequence of <strong>preprocessing tokens</strong> and sequences of <strong>whitespace</strong> and <strong>comments</strong>. (In basic terms, tokens are groups separated from each other by spaces, tabs, or line breaks;) <strong>Each comment</strong> is replaced by <strong>one space character</strong>. So something such as</p><pre><code class="hljs c"><span class="hljs-keyword">int</span><span class="hljs-comment">/* this doesn't look like a space*/</span>fox;</code></pre><p>becomes</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> fox;</code></pre><h1 id="2-Manifest-Constants-define"><a href="#2-Manifest-Constants-define" class="headerlink" title="2. Manifest Constants: #define"></a>2. Manifest Constants: #define</h1><p>A <strong>directive</strong> can appear anywhere in the source file, and the definition holds from its place of <strong>appearance to the end of the file</strong>. </p></li></ol><p><strong>Preprocessor</strong> directives run until the <strong>first newline</strong> following the <code>#</code>. </p><p>That is, a directive is limited to <strong>one line</strong> in length. However, as mentioned earlier, the combination <strong>backslash</strong> <strong>newline</strong> is deleted <strong>before preprocessing</strong> begins, so you can spread the directive over <strong>several physical lines</strong>. These lines, however, constitute <strong>a single logical line</strong>.</p><p>Each <strong>#define</strong> line (logical line, that is) has <strong>three</strong> parts:</p><ol><li><p>The <strong>first</strong> part is the <strong>#define directive</strong> itself. </p></li><li><p>The <strong>second</strong> part is your chosen <strong>abbreviation</strong>, known as a <strong>macro</strong>.  </p><p> The <strong>macro name</strong> must have <strong>no spaces</strong> in it, and it must conform to the same <strong>naming rules</strong> that C variables follow: Only <strong>letters</strong>, <strong>digits</strong>, and the <strong>underscore</strong> <code>(_)</code> character can be used, and the <strong>first character cannot be a digit</strong>. </p></li><li><p><strong>Replacement list</strong> or <strong>body</strong> . </p></li></ol><p>When the <strong>preprocessor</strong> finds an example of one of your <strong>macros</strong> within your program, it almost always <strong>replaces</strong> it with the body. ( The one exception to replacement is a <strong>macro</strong> found within <strong>double quotation marks</strong>.) </p><p>This process of going from a <strong>macro</strong> to a <strong>final replacement</strong> is called <strong>macro expansion</strong>. </p><h2 id="1-define-与-const"><a href="#1-define-与-const" class="headerlink" title="(1) define 与 const"></a>(1) define 与 const</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIMIT 20</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LIM = <span class="hljs-number">50</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> data1[LIMIT]; <span class="hljs-comment">// valid</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> data2[LIM]; <span class="hljs-comment">// storage size of 'data' isn't constant</span><span class="hljs-keyword">int</span> data3[LIM]; <span class="hljs-comment">//valid</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LIM2 = <span class="hljs-number">2</span> * LIMIT; <span class="hljs-comment">// valid</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LIM3 = <span class="hljs-number">2</span> * LIM; <span class="hljs-comment">// valid</span></code></pre><p>In <strong>C</strong>, the array size for <strong>nonautomatic</strong> arrays is supposed to be an <strong>integer constant expression</strong>, meaning that it’s a combination of integer constants, such as <code>5</code>, enumeration constants, and sizeof expressions. This doesn’t include values declared using <strong>const</strong>. (This is one respect in which <strong>C++</strong> differs from <strong>C</strong>; in <strong>C++</strong> you can use <strong>const values</strong> as part of <strong>constant expressions</strong>.) </p><p>However, an implementation may accept other forms of <a href="http://port70.net/~nsz/c/c11/n1570.html#6.6p2" target="_blank" rel="noopener">constant expression</a> . </p><p><strong>Note:</strong></p><ul><li>The value of a const-qualified object is not a constant expression. A constant expression can be evaluated during translation rather than runtime.</li><li>You must specify the size of a conventional C array with a constant expression, so the size is<br>determined at compile time. C99/C11 offers the variable-length array alternative for which the<br>size specifier can be a variable. This allows you to delay specifying the size of a VLA until the program is running. So, <code>int data3[LIM];</code> is permitted.</li><li>Static variables and external variables are already in place after a program is loaded into memory. Statically allocated memory is typically reserved in data segment of the program at compile time, while the automatically allocated memory is normally implemented as a transient call stack. Hence, <code>static int data2[LIM];</code> is invalid.</li></ul><h2 id="2-Tokens"><a href="#2-Tokens" class="headerlink" title="(2) Tokens"></a>(2) Tokens</h2><p>Technically, the body of a <strong>macro</strong> is considered to be a <strong>string of tokens</strong> rather than <strong>a string of characters</strong>. </p><p>C preprocessor <strong>tokens</strong> are the separate “words” in the body of a <strong>macro</strong> definition.</p><p>They are separated from one another by <strong>whitespace</strong>. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOUR 2*2</span></code></pre><p>has one token：2*2</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIX 2 * 3</span></code></pre><p>has three tokens: 2，*, 2</p><p><strong>Character strings</strong> and <strong>token strings</strong> differ in how multiple spaces in a body are treated. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EIGHT 4    *    8</span></code></pre><p>A <strong>preprocessor</strong> that interprets the body as a character string would replace <code>EIGHT</code> with 4&emsp;&emsp;*&emsp;&emsp;8.</p><p>That is, the extra spaces would be <strong>part of the replacement</strong>, but a <strong>preprocessor</strong> that interprets the body as <strong>tokens</strong> will replace <code>EIGHT</code> with <strong>three tokens</strong> separated by single spaces: 4 * 8. </p><p>In practice, some C compilers have viewed <strong>macro</strong> bodies as <strong>strings</strong> rather than as <strong>tokens</strong>. </p><h2 id="3-Redefining-Constants"><a href="#3-Redefining-Constants" class="headerlink" title="(3) Redefining Constants"></a>(3) Redefining Constants</h2><p>Suppose you define <code>LIMIT</code> to be 20, and then later in the same file you define it again as 25. This process is called <strong>redefining a constant</strong>. </p><p>The ANSI standard allows redefinition only if the new definition <strong>duplicates</strong> the old.</p><p>Having the same definition means the bodies must have the same <strong>tokens</strong> in the <strong>same order</strong>.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIX 2 * 3</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIX 2   *   3</span></code></pre><p>Both have the same <strong>three tokens</strong>, and the extra spaces are not part of the body. The next definition is considered different:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIX 2*3</span></code></pre><p>It has just <strong>one token</strong>, not three, so it doesn’t match. If you want to redefine a macro, use the <code>#undef</code> directive.</p><h1 id="3-Using-Arguments-with-define"><a href="#3-Using-Arguments-with-define" class="headerlink" title="3. Using Arguments with #define"></a>3. Using Arguments with #define</h1><p><strong>Function-like macro</strong> definitions have one or more <strong>arguments</strong> in <strong>parentheses</strong>, and these arguments then appear in the replacement portion.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SQUARE(X) (X)*(X)</span></code></pre><p>Now <code>SQUARE(x+2)</code> becomes $(x+2)*(x+2)$, you get the correct result.</p><p>However, <code>100/SQUARE(2)</code> becomes $100/(2)*(2)$ instead of $100/4$.</p><h2 id="1-Creating-Strings-from-Macro-Arguments-The-Operator"><a href="#1-Creating-Strings-from-Macro-Arguments-The-Operator" class="headerlink" title="(1) Creating Strings from Macro Arguments: The # Operator"></a>(1) Creating Strings from Macro Arguments: The # Operator</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PSQR(X) printf(<span class="hljs-meta-string">"The square of X is %d.\n"</span>, ((X)*(X)));</span>PSQR(<span class="hljs-number">8</span>);</code></pre><p>output:</p><pre><code class="hljs c">The square of X is <span class="hljs-number">64.</span></code></pre><p>Note that the <code>X</code> in the <strong>quoted string</strong> is treated as ordinary text, not as a <strong>token</strong> that can be replaced.</p><p>Within the replacement part of a <strong>function-like macro</strong>, the <code>#</code> symbol becomes a <strong>preprocessing</strong> operator that <strong>converts tokens into strings</strong>. </p><p>For example, say that <code>x</code>is a macro parameter, and then <code>#x</code> is that parameter name converted to the string <code>&quot;x&quot;</code>. This process is called <strong>stringizing</strong>.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PSQR(x) printf(<span class="hljs-meta-string">"The square of "</span> #x <span class="hljs-meta-string">" is %d.\n"</span>,((x)*(x)))</span>PSQR(y);PSQR(<span class="hljs-number">2</span> + <span class="hljs-number">4</span>);</code></pre><p>output:</p><pre><code class="hljs c">The square of y is <span class="hljs-number">25.</span>The square of <span class="hljs-number">2</span> + <span class="hljs-number">4</span> is <span class="hljs-number">36.</span></code></pre><p>In the first call to the macro, <code>#x</code> was replaced by <code>&quot;y&quot;</code>, and in the second call <code>#x</code> was replaced by <code>&quot;2 + 4&quot;</code>. </p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"The square of "</span> <span class="hljs-string">"y"</span> <span class="hljs-string">" is %d.\n"</span>,((y)*(y)));</code></pre><p>Then string <strong>concatenation</strong> converts the three adjacent strings to one string, which ANSI C introduced, is <strong>string concatenation</strong>.</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"The square of y is %d.\n"</span>,((y)*(y)));</code></pre><p>If you follow one quoted string constant with another, separated only by <strong>whitespace</strong>, C treats the combination as a single string. </p><h2 id="2-Preprocessor-Glue-The-Operator"><a href="#2-Preprocessor-Glue-The-Operator" class="headerlink" title="(2)  Preprocessor Glue: The ## Operator"></a>(2)  Preprocessor Glue: The ## Operator</h2><p>Like the <code>#</code> operator, the <code>##</code> operator can be used in the replacement section of a <strong>function-like macro</strong>. Additionally, it can be used in the replacement section of an <strong>object-like macro</strong>. </p><p>The <code>##</code> operator combines <strong>two tokens</strong> into a <strong>single token</strong>. For example, you could do this:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XNAME(n) x ## n</span></code></pre><p>Then the macro <code>XNAME(4)</code> becomes <code>x4</code>.</p><pre><code class="hljs c"><span class="hljs-comment">// glue.c -- use the ## operator</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XNAME(n) x ## n</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRINT_XN(n) printf(<span class="hljs-meta-string">"x"</span> #n <span class="hljs-meta-string">" = %d\n"</span>, x ## n);</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">XNAME</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span> </span>= <span class="hljs-number">14</span>; <span class="hljs-comment">// becomes int x1 = 14;</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">XNAME</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span> </span>= <span class="hljs-number">20</span>; <span class="hljs-comment">// becomes int x2 = 20;</span>    <span class="hljs-keyword">int</span> x3 = <span class="hljs-number">30</span>;    PRINT_XN(<span class="hljs-number">1</span>); <span class="hljs-comment">// becomes printf("x1 = %d\n", x1);</span>    PRINT_XN(<span class="hljs-number">2</span>); <span class="hljs-comment">// becomes printf("x2 = %d\n", x2);</span>    PRINT_XN(<span class="hljs-number">3</span>); <span class="hljs-comment">// becomes printf("x3 = %d\n", x3);</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Note how the <code>PRINT_XN()</code> <strong>macro</strong> uses the <code>#</code> operator to combine <strong>strings</strong> and the <code>##</code> operator to combine <strong>tokens</strong> into a new identifier.</p><h2 id="3-Variadic-Macros-…-and-VA-ARGS"><a href="#3-Variadic-Macros-…-and-VA-ARGS" class="headerlink" title="(3) Variadic Macros: … and _ VA_ARGS _"></a>(3) Variadic Macros: … and _ <em>VA_ARGS</em> _</h2><p>Some functions, such as <code>printf()</code>, accept a <strong>variable number of arguments</strong>. The <code>stdvar.h</code> header file provides tools for creating user-defined functions with a variable number of arguments. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PR(...) printf(_ _VA_ARGS_ _)</span></code></pre><p>Suppose you later invoke the <strong>macro</strong> like this:</p><pre><code class="hljs c">PR(<span class="hljs-string">"Howdy"</span>);PR(<span class="hljs-string">"weight = %d, shipping = $%.2f\n"</span>, wt, sp);</code></pre><p>For the first invocation,<code>_ _VA_ARGS_ _</code> expands to one argument: <code>&quot;Howdy&quot;</code>.</p><p>For the second invocation, it expands to three arguments: <code>&quot;weight = %d, shipping = $%.2f\n&quot;, wt, sp</code>.</p><p>Thus, the resulting code is this:</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Howdy"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"weight = %d, shipping = $%.2f\n"</span>, wt, sp);</code></pre><pre><code class="hljs c"><span class="hljs-comment">// variadic.c -- variadic macros</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PR(X, ...) printf(<span class="hljs-meta-string">"Message "</span> #X <span class="hljs-meta-string">": "</span> _ _VA_ARGS_ _)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> x = <span class="hljs-number">48</span>;    <span class="hljs-keyword">double</span> y;    y = <span class="hljs-built_in">sqrt</span>(x);    PR(<span class="hljs-number">1</span>, <span class="hljs-string">"x = %g\n"</span>, x);    PR(<span class="hljs-number">2</span>, <span class="hljs-string">"x = %.2f, y = %.4f\n"</span>, x, y);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>In the first <strong>macro call</strong>, <code>X</code>has the value <code>1</code>, so <code>#X</code> becomes <code>&quot;1&quot;</code>. That makes the expansion look like this:</p><pre><code class="hljs c"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Message "</span> <span class="hljs-string">"1"</span> <span class="hljs-string">": "</span> <span class="hljs-string">"x = %g\n"</span>, x);</code></pre><p>Then the four strings are <strong>concatenated</strong>, reducing the call to this:</p><pre><code class="hljs c"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Message 1: x = %g\n"</span>, x);</code></pre><p><strong>Note:</strong> the ellipses have to be the <strong>last macro argument</strong>:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRONG(X, ..., Y) #X #_ _VA_ARGS_ _ #y <span class="hljs-comment">// don't work</span></span></code></pre><h1 id="4-Macro-or-Function"><a href="#4-Macro-or-Function" class="headerlink" title="4. Macro or Function?"></a>4. Macro or Function?</h1><p>The <strong>macro-versus-function</strong> choice represents a trade-off between <strong>time</strong> and <strong>space</strong>. </p><p>A macro produces <strong>inline code</strong>; that is, you get a statement in your program. </p><p>If you use the <strong>macro</strong> 20 times, you get 20 lines of code inserted into your program. </p><p>If you use a <strong>function</strong> 20 times, you have just <strong>one copy</strong> of the function statements in your program, so <strong>less space</strong> is used. </p><p>On the other hand, program control must <strong>shift to</strong> where the function is and then return to the calling program, and this takes <strong>longer</strong> than <strong>inline code</strong>.</p><p><strong>Macros</strong> have an <strong>advantage</strong> in that they don’t worry about <strong>variable types</strong>. (This is because they deal with character strings, not with actual values.) </p><p>Therefore, the <strong>SQUARE(x)</strong> macro can be used equally well with <strong>int</strong> or <strong>float</strong>.</p><p>Here are some points to note:</p><ol><li>Remember that there are <strong>no spaces</strong> in the <strong>macro name</strong>, but that <strong>spaces</strong> can appear in the <strong>replacement string</strong>. </li><li>Use <strong>parentheses</strong> around <strong>each argument</strong> and around the definition as a whole.</li><li>Use capital letters for macro function names.</li><li>A macro inside a <strong>nested loop</strong> is a much better candidate for <strong>speed improvements</strong>. </li></ol><h1 id="5-File-Inclusion-include"><a href="#5-File-Inclusion-include" class="headerlink" title="5. File Inclusion: #include"></a>5. File Inclusion: #include</h1><p>When the preprocessor spots an <strong>#include</strong> directive, it looks for the following filename and includes the contents of that file within the current file. </p><p>Including a large header file doesn’t necessarily add much to the size of your program. The content of header files, for the most part, is information used by the compiler to generate the final code, not material to be added to the final code.</p><h1 id="6-Other-Directives"><a href="#6-Other-Directives" class="headerlink" title="6. Other Directives"></a>6. Other Directives</h1><h2 id="1-The-undef-Directive"><a href="#1-The-undef-Directive" class="headerlink" title="(1) The #undef Directive"></a>(1) The #undef Directive</h2><p>The <strong>#undef</strong> directive “undefines” a given <strong>#define</strong>. That is, suppose you have this definition:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIMIT 400</span>Then the directive<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> LIMIT</span></code></pre><p>removes that definition. Now, if you like, you can redefine LIMIT so that it has a new value.<br>Even if LIMIT is not defined in the first place, it is still valid to undefine it. </p><h2 id="2-Conditional-Compilation"><a href="#2-Conditional-Compilation" class="headerlink" title="(2) Conditional Compilation"></a>(2) Conditional Compilation</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> MAVIS <span class="hljs-comment">// or #if defined MAVIS</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"horse.h"</span> <span class="hljs-comment">// gets done if MAVIS is #defined</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STABLES 5</span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"cow.h"</span> <span class="hljs-comment">// gets done if MAVIS isn't #defined</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STABLES 15</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SIZE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE 100</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><h2 id="3-Predefined-Macros"><a href="#3-Predefined-Macros" class="headerlink" title="(3) Predefined Macros"></a>(3) Predefined Macros</h2><table><thead><tr><th align="left">Macro</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">_ <em>DATE</em> _</td><td align="left">A character string literal in the form “Mmm dd yyyy” representing the date of preprocessing, as in Nov 23 2013</td></tr><tr><td align="left">_ <em>FILE</em> _</td><td align="left">A character string literal representing the name of the current source code file</td></tr><tr><td align="left">_ <em>LINE</em> _</td><td align="left">An integer constant representing the line number in the current source code file</td></tr><tr><td align="left">_ <em>STDC</em> _</td><td align="left">Set to 1 to indicate the implementation conforms to the C Standard</td></tr><tr><td align="left">_ <em>STDC_HOSTED</em> _</td><td align="left">Set to 1 for a hosted environment; 0 otherwise</td></tr><tr><td align="left">_ <em>STDC_VERSION</em> _</td><td align="left">For C99, set to 199901L; for C11, set to 201112L</td></tr><tr><td align="left">_ <em>TIME</em> _</td><td align="left">The time of translation in the form “hh:mm:ss”</td></tr></tbody></table><p>the C99 standard provides for one called <strong>_ <em>func</em> _</strong>. It expands to a string representing the name of the function containing the identifier. </p><p>For this reason, the identifier has to have function scope, whereas macros essentially have file scope. Therefore, <strong>_ <em>func</em> _</strong> is a C language predefined identifier rather than a <strong>predefined macro</strong>.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">why_me</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The file is %s.\n"</span>, __FILE__);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The date is %s.\n"</span>, __DATE__);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The version is %ld.\n"</span>, __STDC_VERSION__);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The line is %d.\n"</span>, __LINE__);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The function is %s.\n"</span>, __func__);    why_me();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">why_me</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The line is %d.\n"</span>, __LINE__);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The function is %s.\n"</span>, __func__);&#125;</code></pre><p>Result:</p><pre><code class="hljs c">The file is predef.c.The date is Dec  <span class="hljs-number">9</span> <span class="hljs-number">2020.</span>The version is <span class="hljs-number">201710.</span>The <span class="hljs-built_in">line</span> is <span class="hljs-number">8.</span>The function is main.The <span class="hljs-built_in">line</span> is <span class="hljs-number">15.</span>The function is why_me.</code></pre><h2 id="4-line-and-error"><a href="#4-line-and-error" class="headerlink" title="(4) #line and #error"></a>(4) #line and #error</h2><p>The <strong>#line</strong> directive lets you reset the line numbering and the filename as reported by the <strong>_ <em>LINE</em> _</strong> and *<em>_ <em>FILE</em> _ *</em>macros. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">line</span> 1000 <span class="hljs-comment">// reset current line number to 1000</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">line</span> 10 <span class="hljs-meta-string">"cool.c"</span> <span class="hljs-comment">// reset line number to 10, file name to cool.c</span></span></code></pre><p>The <strong>#error</strong> directive causes the preprocessor to issue an error message that includes any text in the directive. If possible, the compilation process should halt. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">why_me</span><span class="hljs-params">()</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _ _STDC_VERSION_ _ != 201112L</span><span class="hljs-meta">#<span class="hljs-meta-keyword">error</span> Not C11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><span class="hljs-function"></span>&#123;    ...&#125;</code></pre><p>Attempting to compile the program <code>predef.c</code>could then produce results like this:</p><pre><code class="hljs bash">$ gcc predef.cpredef.c:4:2: error: <span class="hljs-comment">#error Not C11</span>    4 | <span class="hljs-comment">#error Not C11</span>      |  ^~~~~$ gcc -std=c11 predef.c //normal</code></pre><h2 id="5-pragma"><a href="#5-pragma" class="headerlink" title="(5) #pragma"></a>(5) #pragma</h2><p>The <strong>#pragma</strong> lets you place compiler instructions in the source code.</p><p>For example, while C99 was being developed, it was referred to as C9X, and one compiler used the following pragma to turn on C9X support:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> c9x on</span></code></pre><p>Generally, each compiler has its own set of pragmas. C99 also provides the _Pragma preprocessor operator. It converts a string into a regular pragma.</p><pre><code class="hljs c">_Pragma(<span class="hljs-string">"nonstandardtreatmenttypeB on"</span>)</code></pre><p>is equivalent to the following:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> nonstandardtreatmenttypeB on</span></code></pre><p>Because the operator doesn’t use the <strong># symbol</strong>, you can use it as part of a macro expansion:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRAGMA(X) <span class="hljs-meta-keyword">_Pragma</span>(#X)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIMRG(X) PRAGMA(STDC CX_LIMITED_RANGE X)</span></code></pre><h2 id="6-Generic-Selection-C11"><a href="#6-Generic-Selection-C11" class="headerlink" title="(6) Generic Selection (C11)"></a>(6) Generic Selection (C11)</h2><p>In programming, the term <strong>generic programming</strong> indicates code that is not specific to a particular type but which, once a type is specified, can be translated into code for that type.</p><p>A generic selection expression looks like this:</p><pre><code class="hljs c">_Generic(x, <span class="hljs-keyword">int</span>: <span class="hljs-number">0</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span>: <span class="hljs-number">2</span>, <span class="hljs-keyword">default</span>: <span class="hljs-number">3</span>)</code></pre><p>Here <strong>_Generic</strong> is a new C11 keyword. The parentheses following <strong>_Generic</strong> contain several comma-separated terms. </p><p>The first term is an expression, and each remaining item is a type followed by a colon followed by a value, such as float: 1. The type of the first term is matched to one of the labels, and the value of the whole expression is the value following the matched label. </p><p>A generic selection statement is a little like a <strong>switch</strong> statement, except that the <strong>type of an expression</strong> rather than the** value of an expression** is matched to a label.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MYTYPE(X) _Generic((X),\</span><span class="hljs-keyword">int</span>: <span class="hljs-string">"int"</span>,\<span class="hljs-keyword">float</span> : <span class="hljs-string">"float"</span>,\<span class="hljs-keyword">double</span>: <span class="hljs-string">"double"</span>,\<span class="hljs-keyword">default</span>: <span class="hljs-string">"other"</span>\)</code></pre><h1 id="7-Inline-Functions-C99"><a href="#7-Inline-Functions-C99" class="headerlink" title="7. Inline Functions (C99)"></a>7. Inline Functions (C99)</h1><p>What the C99 and C11 standards actually say is this: “Making a function an inline function suggests that calls to the function be as fast as possible. The extent to which such suggestions are effective is implementation-defined.” </p><p>So making a function an inline function may cause the compiler to replace the function call with inline code and/or perform some other sorts of optimizations, or it may have no effect.</p><p>There are different ways to create inline function definitions. The standard says that a function with internal linkage can be made inline and that the definition for the inline function must be in the same file in which the function is used. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eatline</span><span class="hljs-params">()</span> <span class="hljs-comment">// inline definition/prototype</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">'\n'</span>)        <span class="hljs-keyword">continue</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ...    eatline(); <span class="hljs-comment">// function call</span>    ...&#125;</code></pre><p>Because an inline function doesn’t have a separate block of code set aside for it, you can’t take its address. (Actually, you can take the address, but then the compiler will generate a non-inline function.) </p><p>Also, an inline function may not show up in a debugger.</p><p>An inline function should be short. </p><p>For the compiler to make inline optimizations, it has to know the contents of the function definition. This means the inline function definition has to be in the same file as the function call. For this reason, an inline function ordinarily has internal linkage. Therefore, if you have a multifile program, you need an inline definition in each file that calls the function. The simplest way to accomplish this is to put the inline function definition in a header file and then include the header file in those files that use the function.</p><h1 id="8-Noreturn-Functions-C11"><a href="#8-Noreturn-Functions-C11" class="headerlink" title="8. _Noreturn Functions (C11)"></a>8. _Noreturn Functions (C11)</h1><p> C11 adds a second function specifier, _Noreturn, to indicate a function that, upon completion, does not return to the <strong>calling function</strong>. </p><p>The exit() function is an example of a _Noreturn function, for once exit() is called, the calling function never resumes. </p><p>Note that this is different from the void return type. A typical void function does return to the calling function; it just doesn’t provide an assignable value.</p><p>The purpose of _Noreturn is to inform the user and the compiler that a particular function won’t return control to the calling program. Informing the user helps to prevent misuse of the function, and informing the compiler may enable it to make some code optimizations.</p><h1 id="9-The-General-Utilities-Library"><a href="#9-The-General-Utilities-Library" class="headerlink" title="9. The General Utilities Library"></a>9. The General Utilities Library</h1><h2 id="1-The-exit-and-atexit-Functions"><a href="#1-The-exit-and-atexit-Functions" class="headerlink" title="(1) The exit() and atexit() Functions"></a>(1) The exit() and atexit() Functions</h2><p>To use the atexit() function, simply pass it the address of the function you want called on exit. </p><pre><code class="hljs c"><span class="hljs-comment">/* byebye.c -- atexit() example */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sign_off</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">too_bad</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    atexit(sign_off); <span class="hljs-comment">/* register the sign_off() function */</span>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter an integer:"</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n) != <span class="hljs-number">1</span>)    &#123;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"That's no integer!"</span>);        atexit(too_bad); <span class="hljs-comment">/* register the too_bad() function */</span>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d is %s.\n"</span>, n, (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)? <span class="hljs-string">"even"</span> : <span class="hljs-string">"odd"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sign_off</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Thus terminates another magnificent program from"</span>);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"SeeSaw Software!"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">too_bad</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"SeeSaw Software extends its heartfelt condolences"</span>);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"to you upon the failure of your program."</span>);&#125;</code></pre><pre><code class="hljs c">Enter an integer:<span class="hljs-number">212</span><span class="hljs-number">212</span> is even.Thus terminates another magnificent program from <span class="hljs-comment">//sign_off</span>SeeSaw Software!</code></pre><pre><code class="hljs c">Here’s a second <span class="hljs-built_in">run</span>:Enter an integer:what?That<span class="hljs-number">'</span>s no integer!SeeSaw Software extends its heartfelt condolences <span class="hljs-comment">//too_bad</span>to you upon the failure of your program.Thus terminates another magnificent program from  <span class="hljs-comment">//sign_off</span>SeeSaw Software!</code></pre><p>Because the name of a function acts as an address when used as a function argument, use <code>sign_off</code> or <code>too_bad</code> as the argument. </p><p>Then atexit() registers that function in a list of functions to be executed when exit() is called.</p><p>ANSI guarantees that you can place at least 32 functions on the list. Each function is added with a separate call to atexit(). When the exit() function is finally called, it executes these functions, with the last function added being executed first.</p><p>The functions registered by atexit() should be type void functions taking no arguments. </p><p>Typically, they would perform housekeeping tasks, such as updating a program-monitoring file or resetting environmental variables.</p><p>Note that sign_off() is called even when exit() is not called explicitly; that’s because <strong>exit() is called implicitly when main() terminates</strong>.</p><p>After exit() executes the functions specified by atexit(), it does some tidying of its own. It flushes all output streams, closes all open streams, and closes temporary files created by calls to the standard I/O function tmpfile(). </p><p>Then exit() returns control to the host environment and, if possible, reports a termination status to the environment. </p><p>ANSI C defined a macro called EXIT_FAILURE that can be used portably to indicate failure. Similarly, it defined EXIT_SUCCESS to indicate success, but exit() also accepts 0 for that purpose. </p><p>Under ANSI C, using the exit() function in a nonrecursive main() function is equivalent to using the keyword return. However, exit() also terminates programs when used in functions other than main().</p><h1 id="10-The-Assert-Library"><a href="#10-The-Assert-Library" class="headerlink" title="10. The Assert Library"></a>10. The Assert Library</h1><p>The assert library, supported by the assert.h header file, is a small one designed to help with debugging programs. </p><p>It consists of a macro named assert(). It takes as its argument an integer expression. If the expression evaluates as false (nonzero), the assert() macro writes an error message to the standard error stream (stderr) and calls the abort() function, which terminates the program. (The abort() function is prototyped in the stdlib.h header file.) </p><p>The idea is to identify critical locations in a program where certain conditions should be true and to use the assert() statement to terminate the program if one of the specified conditions is not true. </p><p>Typically, the argument is a relational or logical expression. If assert() does abort the program, it first displays the test that failed, the name of the file containing the test, and a line number.</p><pre><code class="hljs c"><span class="hljs-comment">/* assert.c -- use assert() */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> x, y, z;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter a pair of numbers (0 0 to quit): "</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>, &amp;x, &amp;y) == <span class="hljs-number">2</span> &amp;&amp; (x != <span class="hljs-number">0</span> || y != <span class="hljs-number">0</span>))    &#123;        z = x * x - y * y; <span class="hljs-comment">/* should be + */</span>        assert(z &gt;= <span class="hljs-number">0</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"answer is %f\n"</span>, <span class="hljs-built_in">sqrt</span>(z));        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Next pair of numbers: "</span>);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Done"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function">Enter a pair of <span class="hljs-title">numbers</span> <span class="hljs-params">(<span class="hljs-number">0</span> <span class="hljs-number">0</span> to quit)</span>: </span><span class="hljs-function">4 3</span>answer is 2.645751Next pair of numbers: <span class="hljs-number">3</span> <span class="hljs-number">5</span>assert: assert.c:<span class="hljs-number">12</span>: main: Assertion `z &gt;= <span class="hljs-number">0'</span> failed.Aborted (core dumped)</code></pre><p> If you think you’ve eliminated the program bugs, place the macro definition<code>#define NDEBUG</code> before the location where assert.h is included and then recompile the program, and the compiler will deactivate all assert() statements in the file. </p><p>The assert() expression is a run-time check. C11 adds a feature, the <strong>_Static_assert</strong> declaration, that does a <strong>compile-time</strong> check. So, assert() can cause a running program to abort, while _Static_assert() can cause a program not to compile. </p><p>The latter takes two arguments. The first is a constant integer expression, and the second is a string. </p><p>If the first expression evaluates to 0 (or _False), the compiler displays the string and does not compile the program.</p><pre><code class="hljs c"><span class="hljs-comment">// statasrt.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;limits.h&gt;</span></span>_Static_assert(CHAR_BIT == <span class="hljs-number">16</span>, <span class="hljs-string">"16-bit char falsely assumed"</span>);<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">"char is 16 bits."</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs bash">statasrt.c:4:1: error: static assertion failed: <span class="hljs-string">"16-bit char falsely assumed"</span>    4 | _Static_assert(CHAR_BIT == 16, <span class="hljs-string">"16-bit char falsely assumed"</span>);      | ^~~~~~~~~~~~~~</code></pre><h1 id="11-memcpy-and-memmove-from-the-string-h-Library"><a href="#11-memcpy-and-memmove-from-the-string-h-Library" class="headerlink" title="11. memcpy() and memmove() from the string.h Library"></a>11. memcpy() and memmove() from the string.h Library</h1><p>You can’t assign one array to another, so we’ve been using loops to copy one array to another, element by element. </p><p>The one exception is that we’ve used the strcpy() and strncpy() functions for character arrays. </p><p>The memcpy() and memmove() functions offer you almost the same convenience for other kinds of arrays. </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">restrict</span> s2, <span class="hljs-keyword">size_t</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memmove</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>Both of these functions copy <code>n</code> bytes from the location pointed to by <code>s2</code> to the location pointed to by <code>s1</code>, and both return the value of <code>s1</code>. </p><p>The difference between the two, as indicated by the keyword <code>restrict</code>, is that memcpy() is free to assume that there is no overlap between the two memory ranges. </p><p>The memmove() function doesn’t make that assumption, so copying takes place as if all the bytes are first copied to a temporary buffer before being copied to the final destination. </p><p>What if you use memcpy() when there are overlapping ranges? The behavior is undefined, meaning it might work or it might not. </p><p>Because these functions are designed to work with any data type, the two pointer arguments are type pointer-to-void. C allows you to assign any pointer type to pointers of the void * type. </p><p>The other side of this tolerant acceptance is that these functions have no way of knowing what type of data is being copied. Therefore, they use the third argument to indicate the number of bytes to be copied. </p><p>Note that for an array, the number of bytes is not, in general, the number of elements. So if you were copying an array of 10 double values, you would use <code>10*sizeof(double)</code>, not 10, as the third argument.</p><h1 id="10-Variable-Arguments-stdarg-h"><a href="#10-Variable-Arguments-stdarg-h" class="headerlink" title="10. Variable Arguments: stdarg.h"></a>10. Variable Arguments: stdarg.h</h1><p>Earlier, this chapter discussed variadic macros—macros that can accept a variable number of arguments. The stdarg.h header file provides a similar capability for functions. But the usage is a bit more involved. You have to do the following:</p><ol><li>Provide a function prototype using an ellipsis.</li><li>Create a va_list type variable in the function definition.</li><li>Use a macro to initialize the variable to an argument list.</li><li>Use a macro to access the argument list.</li><li>Use a macro to clean up.</li></ol><p>The prototype for such a function should have a parameter list with at least one parameter followed by an ellipsis:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, ...)</span></span>; <span class="hljs-comment">// valid</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s, <span class="hljs-keyword">int</span> k, ...)</span></span>; <span class="hljs-comment">// valid</span><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c1, ..., <span class="hljs-keyword">char</span> c2)</span></span>; <span class="hljs-comment">// invalid, ellipsis not last</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f3</span><span class="hljs-params">(...)</span></span>; <span class="hljs-comment">// invalid, no parameter</span></code></pre><p>The rightmost parameter (the one just before the ellipses) plays a special role; the standard uses the term parmN as a name to use in discussion. </p><p>In the preceding examples, parmN would be n for the first case and k for the second case. </p><p>The actual argument passed to this parameter will be the number of arguments represented by the ellipses section. </p><pre><code class="hljs c">f1(<span class="hljs-number">2</span>, <span class="hljs-number">200</span>, <span class="hljs-number">400</span>); <span class="hljs-comment">// 2 additional arguments</span>f1(<span class="hljs-number">4</span>, <span class="hljs-number">13</span>, <span class="hljs-number">117</span>, <span class="hljs-number">18</span>, <span class="hljs-number">23</span>); <span class="hljs-comment">// 4 additional arguments</span></code></pre><p>Next, the va_list type, which is declared in the stdargs.h header file, represents a data object used to hold the parameters corresponding to the ellipsis part of the parameter list. The beginning of a definition of a variadic function would look something like this:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lim,...)</span></span><span class="hljs-function"></span>&#123;    va_list ap; <span class="hljs-comment">// declare object to hold arguments</span>&#125;</code></pre><p>In this example, lim is the parmN parameter, and it will indicate the number of arguments in the variable-argument list.</p><p>After this, the function will use the va_start() macro, also defined in stdargs.h, to copy the argument list to the va_list variable. The macro has two arguments: the va_list variable and the parmN parameter. Continuing with the previous example, the va_list variable is called ap and the parmN parameter is call lim, so the call would look like this:</p><pre><code class="hljs c">va_start(ap, lim); <span class="hljs-comment">// initialize ap to argument list</span></code></pre><p>The next step is gaining access to the contents of the argument list. This involves using va_arg(), another macro. It takes two arguments: a type va_list variable and a type name. </p><p>The first time it’s called, it returns the first item in the list; the next time it’s called, it returns the next item, and so on. The type argument specifies the type of value returned. </p><pre><code class="hljs c"><span class="hljs-keyword">double</span> tic;<span class="hljs-keyword">int</span> toc;...tic = va_arg(ap, <span class="hljs-keyword">double</span>); <span class="hljs-comment">// retrieve first argument</span>toc = va_arg(ap, <span class="hljs-keyword">int</span>); <span class="hljs-comment">// retrieve second argument</span></code></pre><p>Be careful. The argument type really has to match the specification. If the first argument is 10.0, the previous code for tic works fine. But if the argument is 10, the code may not work; the automatic conversion of double to int that works for assignment doesn’t take place here.</p><p>Finally, you should clean up by using the va_end() macro. </p><pre><code class="hljs c">va_end(ap); <span class="hljs-comment">// clean up</span></code></pre><p>After you do this, the variable ap may not be usable unless you use va_start to reinitialize it.</p><p>Because va_arg() doesn’t provide a way to back up to previous arguments, it may be useful to preserve a copy of the va_list type variable. C99 has added a macro for that purpose. It’s called va_copy(). </p><p>Its two arguments are both type va_list variables, and it copies the second argument to the first:</p><pre><code class="hljs c">va_list ap;va_list apcopy;<span class="hljs-keyword">double</span><span class="hljs-keyword">double</span> tic;<span class="hljs-keyword">int</span> toc;...va_start(ap, lim); <span class="hljs-comment">// initialize ap to argument list</span>va_copy(apcopy, ap); <span class="hljs-comment">// make apcopy a copy of ap</span>tic = va_arg(ap, <span class="hljs-keyword">double</span>); <span class="hljs-comment">// retrieve first argument</span>toc = va_arg(ap, <span class="hljs-keyword">int</span>); <span class="hljs-comment">// retrieve second argument</span></code></pre><p>At this point, you could still retrieve the first two items from apcopy, even though they have been removed from ap.</p><pre><code class="hljs c"><span class="hljs-comment">//varargs.c -- use variable number of arguments</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, ...)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> s,t;    s = sum(<span class="hljs-number">3</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">13.3</span>);    t = sum(<span class="hljs-number">6</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">2.1</span>, <span class="hljs-number">13.1</span>, <span class="hljs-number">4.1</span>, <span class="hljs-number">5.1</span>, <span class="hljs-number">6.1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"return value for "</span>    <span class="hljs-string">"sum(3, 1.1, 2.5, 13.3): %g\n"</span>, s);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"return value for "</span>    <span class="hljs-string">"sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): %g\n"</span>, t);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lim,...)</span></span><span class="hljs-function"></span>&#123;    va_list ap; <span class="hljs-comment">// declare object to hold arguments</span>    <span class="hljs-keyword">double</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> i;    va_start(ap, lim); <span class="hljs-comment">// initialize ap to argument list</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; lim; i++)        tot += va_arg(ap, <span class="hljs-keyword">double</span>); <span class="hljs-comment">// access each item in argument list</span>    va_end(ap); <span class="hljs-comment">// clean up</span>    <span class="hljs-keyword">return</span> tot;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bit Fidding</title>
    <link href="/2020/12/06/Bit-Fidding/"/>
    <url>/2020/12/06/Bit-Fidding/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 15 Bit Fidding</p><a id="more"></a><h1 id="1-Binary-Numbers-Bits-and-Bytes"><a href="#1-Binary-Numbers-Bits-and-Bytes" class="headerlink" title="1. Binary Numbers, Bits, and Bytes"></a>1. Binary Numbers, Bits, and Bytes</h1><h2 id="1-Binary-Integers"><a href="#1-Binary-Integers" class="headerlink" title="(1) Binary Integers"></a>(1) Binary Integers</h2><p>Usually, a <strong>byte</strong> contains 8 bits. C, remember, uses the term byte to denote the size used to hold a system’s character set, so a C byte could be 8 bits, 9 bits, 16 bits, or some other value.</p><p>However, the 8-bit byte is the byte used to describe memory chips and the byte used to describe data transfer rates. To keep matters simple, this chapter assumes an 8-bit byte.</p><h2 id="2-Signed-Integers"><a href="#2-Signed-Integers" class="headerlink" title="(2) Signed Integers"></a>(2) Signed Integers</h2><p>The representation of <strong>signed numbers</strong> is determined by the <strong>hardware</strong>, not by <strong>C</strong>. </p><h3 id="符号量表示法"><a href="#符号量表示法" class="headerlink" title="符号量表示法"></a>符号量表示法</h3><p>用1位（如， 高阶位） 储存符号， 只剩下7位表示数字本身（假设储存在1字节中，假设一个字节是8位） 。 用这种符号量（sign-magnitude） 表示法， 10000001表示−1，00000001表示1。 因此， 其表示范围−127～+127。</p><p><strong>缺点:</strong> 有两个0： +0和-0。 这很容易混淆， 而且用两个位组合来表示一个值也有些浪费。</p><h3 id="二进制补码表示法"><a href="#二进制补码表示法" class="headerlink" title="二进制补码表示法"></a>二进制补码表示法</h3><p>补码内容参看：</p><blockquote><p>深入理解计算机系统英文版第二版 – 第二章 p94</p></blockquote><p>该部分内容介绍参考<a href="https://www.cnblogs.com/ysocean/p/7531660.html#_label3" target="_blank" rel="noopener"> 深入理解计算机系统（2.4）——整数的表示（无符号编码和补码编码）</a></p><h3 id="二进制浮点型"><a href="#二进制浮点型" class="headerlink" title="二进制浮点型"></a>二进制浮点型</h3><p>该内容参看：</p><blockquote><p>深入理解计算机系统英文版第二版 – 第二章 p133</p></blockquote><p>该部分内容介绍参考<a href="https://www.cnblogs.com/ysocean/p/7531667.html" target="_blank" rel="noopener">深入理解计算机系统（2.7）——二进制小数和IEEE浮点标准</a></p><h1 id="2-C’s-Bitwise-Operators"><a href="#2-C’s-Bitwise-Operators" class="headerlink" title="2. C’s Bitwise Operators"></a>2. C’s Bitwise Operators</h1><blockquote><p>深入理解计算机系统英文版第二版 – 第二章 p85</p></blockquote><h2 id="1-Bitwise-Logical-Operators"><a href="#1-Bitwise-Logical-Operators" class="headerlink" title="(1) Bitwise Logical Operators"></a>(1) Bitwise Logical Operators</h2><h3 id="二进制反码或按位取反：-～"><a href="#二进制反码或按位取反：-～" class="headerlink" title="二进制反码或按位取反： ～"></a>二进制反码或按位取反： ～</h3><p>一元运算符<strong>～</strong>把1变为0， 把0变为1。</p><pre><code class="hljs c">~(<span class="hljs-number">10011010</span>) <span class="hljs-comment">// expression</span>(<span class="hljs-number">01100101</span>) <span class="hljs-comment">// resulting value</span></code></pre><h3 id="按位与：-amp"><a href="#按位与：-amp" class="headerlink" title="按位与： &amp;"></a>按位与： &amp;</h3><p>二元运算符<strong>&amp;</strong>通过逐位比较两个运算对象， 生成一个新值。<br>对于每个位， 只有两个运算对象中相应的位都为1时， 结果才为1（从真/假方面看，只有当两个位都为真时， 结果才为真）。 </p><h3 id="按位或："><a href="#按位或：" class="headerlink" title="按位或： |"></a>按位或： |</h3><p>二元运算符<strong>|</strong>， 通过逐位比较两个运算对象， 生成一个新值。<br>对于每个位， 如果两个运算对象中相应的位为1， 结果就为1（从真/假方面看， 如果两个运算对象中相应的一个位为真或两个位都为真， 那么结果为真） 。 </p><h3 id="按位异或："><a href="#按位异或：" class="headerlink" title="按位异或： ^"></a>按位异或： ^</h3><p>二元运算符<strong>^</strong>逐位比较两个运算对象。<br>只有当两个值<strong>相异</strong>时为真（值为1），同为1或同为0为假（值为0）。</p><h2 id="2-Masks"><a href="#2-Masks" class="headerlink" title="(2) Masks"></a>(2) Masks</h2><p>按位与运算符常用于掩码（mask） 。 所谓掩码指的是一些设置为开（1） 或关（0） 的位组合。 </p><p>例如， 假设定义符号常量MASK为2 （即，二进制形式为00000010） ， 只有1号位是1， 其他位都是0。 下面的语句：</p><pre><code class="hljs c">flags = flags &amp; MASK;</code></pre><p>把flags中除1号位以外的所有位都设置为0， 因为使用按位与运算符（&amp;） 任何位与0组合都得0。 1号位的值不变（如果1号位是1， 那么 1&amp;1得1； 如果 1号位是0， 那么 0&amp;1也得0） 。 这个过程叫作“使用掩码”， 因为掩码中的0隐藏了flags中相应的位。</p><p>可以这样类比： 把掩码中的0看作不透明， 1看作透明。 表达式flags &amp;MASK相当于用掩码覆盖在flags的位组合上， 只有MASK为1的位才可见。</p><h2 id="3-Turning-Bits-On-Setting-Bits"><a href="#3-Turning-Bits-On-Setting-Bits" class="headerlink" title="(3) Turning Bits On (Setting Bits)"></a>(3) Turning Bits On (Setting Bits)</h2><p>有时， 需要打开一个值中的特定位， 同时保持其他位不变。如：</p><pre><code class="hljs c">flags = flags | MASK;</code></pre><p>根据MASK中为1的位， 把flags中对应的位设置为1， 其他位不变。</p><h2 id="4-Turning-Bits-Off-Clearing-Bits"><a href="#4-Turning-Bits-Off-Clearing-Bits" class="headerlink" title="(4) Turning Bits Off (Clearing Bits)"></a>(4) Turning Bits Off (Clearing Bits)</h2><p>和打开特定的位类似， 有时也需要在不影响其他位的情况下关闭指定的位。 假设要关闭变量flags中的1号位。将 MASK设为只有1号位为0，其余全为1，则：</p><pre><code class="hljs c">flags = flags &amp; MASK;</code></pre><p>将1号位变为0，其余不变。</p><h2 id="5-Toggling-Bits"><a href="#5-Toggling-Bits" class="headerlink" title="(5) Toggling Bits"></a>(5) Toggling Bits</h2><p>切换位指的是打开已关闭的位， 或关闭已打开的位。 可以使用按位异或运算符（^） 切换位。</p><p>将 flag 中需要进行切换位的地方对应的mask的部分设为1，其余为0。</p><pre><code class="hljs c">flags ^= MASK;</code></pre><p>flags中与MASK为1的位相对应的位都被切换了， MASK为0的位相对应的位不变。</p><h2 id="6-Checking-the-Value-of-a-Bit"><a href="#6-Checking-the-Value-of-a-Bit" class="headerlink" title="(6)  Checking the Value of a Bit"></a>(6)  Checking the Value of a Bit</h2><p>有时， 需要检查某位的值。 例如， flags中1号位是否被设置为1。</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((flags &amp; MASK) == MASK)    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Wow!"</span>);</code></pre><p>将mask中检查的位设为1，其余设为0，这样确保其余位与mask相同，均为0，只比较检查的位。</p><h2 id="7-Bitwise-Shift-Operators"><a href="#7-Bitwise-Shift-Operators" class="headerlink" title="(7) Bitwise Shift Operators"></a>(7) Bitwise Shift Operators</h2><h3 id="左移：-lt-lt"><a href="#左移：-lt-lt" class="headerlink" title="左移： &lt;&lt;"></a>左移： &lt;&lt;</h3><p>左移运算符（&lt;&lt;） 将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数。 左侧运算对象移出左末端位的值丢失， 用0填充右边空出的位置。 </p><h3 id="右移：-gt-gt"><a href="#右移：-gt-gt" class="headerlink" title="右移： &gt;&gt;"></a>右移： &gt;&gt;</h3><p><strong>逻辑右移:</strong> 右移后左边的空出来位补0，对于 unsigned 数据为逻辑右移。</p><p><strong>算数右移:</strong> 右移后左边空出的数据全部用数据的最高位值填充。对于 signed 数据，可用逻辑右移或算数右移，但通常用算数右移。</p><p>测试对signed 和 unsigned 进行右移测试，得到，<strong>unsigned 采用逻辑右移，signed 采用算数右移</strong>。见下面程序：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0xfffffffe</span>;    <span class="hljs-keyword">unsigned</span> m = <span class="hljs-number">0xfffffffe</span>;    <span class="hljs-keyword">int</span> n1 = n &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> m1 = m &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> n2 = (<span class="hljs-keyword">unsigned</span>) n &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//对signed先强制转换为unsigned</span>    <span class="hljs-keyword">int</span> m2 = m &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"n1 = 0x%x, n2 = 0x%x\nm1 = 0x%x, m2 = 0x%x\n"</span>,n1,n2,m1,m2);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>结果：</p><pre><code class="hljs c">n1 = <span class="hljs-number">0xffffffff</span>, n2 = <span class="hljs-number">0x7fffffff</span>m1 = <span class="hljs-number">0x7fffffff</span>, m2 = <span class="hljs-number">0x7fffffff</span></code></pre><h2 id="8-Programming-Example"><a href="#8-Programming-Example" class="headerlink" title="(8) Programming Example"></a>(8) Programming Example</h2><p>以下程序实现功能：将一个 int 型数字转换为二进制</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;limits.h&gt;//for CHAR_BIT, #of bits per char</span></span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">itobs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span> *)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_bstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    char bin_str[CHAR_BIT *sizeof(int) + 1];    <span class="hljs-keyword">int</span> number;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter integers and see them in library."</span>);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Non-numeric input terminates program."</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;number)==<span class="hljs-number">1</span>)    &#123;        itobs(number,bin_str);        show_bstr(bin_str);        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Next interger:"</span>);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">itobs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> *ps)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = CHAR_BIT * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);    <span class="hljs-keyword">for</span>(i = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--, n &gt;&gt;= <span class="hljs-number">1</span>)        ps[i] = (<span class="hljs-number">01</span> &amp; n) + <span class="hljs-string">'0'</span>;    ps[<span class="hljs-built_in">size</span>] = <span class="hljs-string">'\0'</span>;    <span class="hljs-keyword">return</span> ps;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_bstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(str[i])    &#123;        <span class="hljs-built_in">putchar</span>(str[i]);        <span class="hljs-keyword">if</span>(++i % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; str[i])            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">' '</span>);   &#125;&#125;</code></pre><p>程序分析：</p><ol><li><code>CHAR_BIT</code> 为 <strong>limits.h</strong> 头文件中定义的宏，一个字节的比特数。</li><li><code>char bin_str[CHAR_BIT *sizeof(int) + 1];</code> 声明一个字符串数组存放转化后的二进制数，<code>CHAR_BIT *sizeof(int)</code> 得到 <strong>int</strong> 的比特数，还需要加1为存储字符串结束符。</li><li><code>char *itobs(int n, char *ps)</code> 函数中<code>ps[i] = (01 &amp; n) + &#39;0&#39;;</code> 语句中 01 值八进制数据，与 n 按位与后得到 n 的最低位，因为存储的是字符串，需要转化为 ascall 码，因此加 ‘0’得到实际的数值。</li></ol><p>下面是反转指定位数函数，将最后bits位的数反转：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">invert_end</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> bits)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> bitval = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (bits--&gt; <span class="hljs-number">0</span>)    &#123;        mask |= bitval;        bitval &lt;&lt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> num ^ mask;&#125;</code></pre><p>该函数中 bits 为需要反转的位数，反转最后 bits 位。</p><h1 id="3-Bit-Fields"><a href="#3-Bit-Fields" class="headerlink" title="3. Bit Fields"></a>3. Bit Fields</h1><p>The second method of <strong>manipulating bits</strong> is to use a <strong>bit field</strong>, which is just a set of neighboring bits within a <strong>signed int</strong> or an <strong>unsigned int</strong>. (C99 and C11 additionally allow <strong>type _Bool</strong> bit fields.) </p><p>A bit field is set up with a <strong>structure declaration</strong> that labels each field and determines its <strong>width</strong>. For example, the following declaration sets up four 1-bit fields:</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> autfd : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bldfc : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> undln : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> itals : <span class="hljs-number">1</span>;&#125; prnt;</code></pre><p>This definition causes <code>prnt</code> to contain four 1-bit fields. Now you can use the usual structure membership operator to assign values to individual fields:</p><pre><code class="hljs c">prnt.itals = <span class="hljs-number">0</span>;prnt.undln = <span class="hljs-number">1</span>;</code></pre><p>Because each of these particular fields is just 1 bit, 1 and 0 are the only values you can use for assignment. The variable <code>prnt</code> is stored in an int-sized memory cell, but only 4 bits are used in this example.</p><p>A structure with bit fields allows you to store several settings in a single unit.</p><p>Sometimes there are more than two choices for a setting, so you need more than a single bit to represent all the choices. That’s not a problem because fields aren’t limited to 1-bit sizes. </p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> code1 : <span class="hljs-number">2</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> code2 : <span class="hljs-number">2</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> code3 : <span class="hljs-number">8</span>;&#125; prcode;prcode.code1 = <span class="hljs-number">0</span>;prcode.code2 = <span class="hljs-number">3</span>;prcode.code3 = <span class="hljs-number">102</span>;</code></pre><p>Just make sure the value doesn’t exceed the capacity of the field.</p><p>If the total number of bits you declare exceeds the size of an unsigned int, then the next unsigned int storage location is used. </p><p>A single field is not allowed to overlap the boundary between two unsigned ints. </p><p>The compiler automatically shifts an overlapping field definition so that the field is aligned with the <strong>unsigned int</strong> boundary. </p><p>When this occurs, it leaves an <strong>unnamed hole</strong> in the first unsigned int. You can “pad” a field structure with <strong>unnamed holes</strong> by using <strong>unnamed field widths</strong>. </p><p>Using an unnamed field width of 0 forces the next field to align with the next integer:</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> field1 : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">2</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> field2 : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">0</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> field3 : <span class="hljs-number">1</span>;&#125; stuff;</code></pre><p>Here, there is a 2-bit gap between <code>stuff.field1</code> and <code>stuff.field2</code>, and <code>stuff.field3</code> is stored in the next int.</p><p>One important machine dependency is the order in which fields are placed into an int. On some machines, the order is left to right; on others, it is right to left.</p><p>Also, machines differ in the location of boundaries between fields. For these reasons, bit fields tend not to be very portable. </p><blockquote><p>深入理解计算机系统英文版第二版 – p73<br>字节存储顺序：从小到大，从大到小</p></blockquote><p>Often bit fields are used as a more <strong>compact</strong> way of storing data. Suppose, for example, you decided to represent the properties of an onscreen box. Let’s keep the graphics simple and suppose the box has the following properties:</p><ul><li>The box is opaque or transparent.</li><li>The fill color is selected from the following palette of colors: black, red, green, yellow, blue, magenta, cyan, or white.</li><li>The border can be shown or hidden.</li><li>The border color is selected from the same palette used for the fill color.</li><li>The border can use one of three line styles—solid, dotted, or dashed.<pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">box_props</span> &#123;</span><span class="hljs-keyword">bool</span> opaque : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fill_color : <span class="hljs-number">3</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">4</span>;<span class="hljs-keyword">bool</span> show_border : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> border_color : <span class="hljs-number">3</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> border_style : <span class="hljs-number">2</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">2</span>;&#125;;</code></pre>The padding brings the structure up to 16 bits. Without padding, the structure would be 10 bits. Keep in mind, however, that C uses <strong>unsigned int</strong> as the basic layout unit for structures with bit fields. So even if the sole member of a structure is a single 1-bit field, the structure will have the same size as an unsigned int, which is 32 bits on our system. Also, this coding assumes that the C99 _Bool type is available and is aliased as bool in <strong>stdbool.h</strong>.</li></ul><p>You can use a value of 1 for the <code>opaque</code> member to indicate that the box is opaque and a 0 value to indicate transparency. </p><p>You can do the same for the <code>show_border</code> member. </p><p>For <strong>colors</strong>, you can use a simple RGB (red-green-blue) representation. These are the primary colors for mixing light. A monitor blends red, green, and blue pixels to reproduce different colors. </p><p> Finally, you can choose to let 0, 1, and 2 represent the <strong>solid</strong>, <strong>dotted</strong>, and <strong>dashed</strong> styles; they can be used as values for the <code>border_style</code> member.</p><p><img src="_v_images/20201207230858132_355553505.png" srcset="/img/loading.gif" alt="Color"></p><pre><code class="hljs c"><span class="hljs-comment">/* dualview.c -- bit fields and bitwise operators */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;limits.h&gt;</span></span><span class="hljs-comment">/* BIT-FIELD CONSTANTS */</span><span class="hljs-comment">/* line styles */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOLID 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DOTTED 1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DASHED 2</span><span class="hljs-comment">/* primary colors */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLUE 4</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GREEN 2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RED 1</span><span class="hljs-comment">/* mixed colors */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLACK 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> YELLOW (RED | GREEN)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAGENTA (RED | BLUE)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CYAN (GREEN | BLUE)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WHITE (RED | GREEN | BLUE)</span><span class="hljs-comment">/* BITWISE CONSTANTS */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OPAQUE 0x1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILL_BLUE 0x8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILL_GREEN 0x4</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILL_RED 0x2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILL_MASK 0xE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BORDER 0x100</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BORDER_BLUE 0x800</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BORDER_GREEN 0x400</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BORDER_RED 0x200</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BORDER_MASK 0xE00</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_SOLID 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_DOTTED 0x1000</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_DASHED 0x2000</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STYLE_MASK 0x3000</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *colors[<span class="hljs-number">8</span>] = &#123;<span class="hljs-string">"black"</span>, <span class="hljs-string">"red"</span>, <span class="hljs-string">"green"</span>, <span class="hljs-string">"yellow"</span>,<span class="hljs-string">"blue"</span>, <span class="hljs-string">"magenta"</span>, <span class="hljs-string">"cyan"</span>, <span class="hljs-string">"white"</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">box_props</span> &#123;</span><span class="hljs-keyword">bool</span> opaque : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fill_color : <span class="hljs-number">3</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">4</span>;<span class="hljs-keyword">bool</span> show_border : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> border_color : <span class="hljs-number">3</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> border_style : <span class="hljs-number">2</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">2</span>;&#125;;<span class="hljs-keyword">union</span> Views <span class="hljs-comment">/* look at data as struct or as unsigned short */</span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">box_props</span> <span class="hljs-title">st_view</span>;</span>    <span class="hljs-keyword">unsigned</span> short us_view;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_settings</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct box_props * pb)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_settings1</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> short)</span></span>;<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">itobs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> * ps)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">/* create Views object, initialize struct box view */</span>    <span class="hljs-keyword">union</span> Views box = &#123;&#123;<span class="hljs-literal">true</span>, YELLOW , <span class="hljs-literal">true</span>, GREEN, DASHED&#125;&#125;;    <span class="hljs-keyword">char</span> bin_str[<span class="hljs-number">8</span> *<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) + <span class="hljs-number">1</span>];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Original box settings:\n"</span>);    show_settings(&amp;box.st_view);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nBox settings using unsigned int view:\n"</span>);    show_settings1(box.us_view);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"bits are %s\n"</span>,    itobs(box.us_view,bin_str));    box.us_view &amp;= ~FILL_MASK; <span class="hljs-comment">/* clear fill bits */</span>    box.us_view |= (FILL_BLUE | FILL_GREEN); <span class="hljs-comment">/* reset fill */</span>    box.us_view ^= OPAQUE; <span class="hljs-comment">/* toggle opacity */</span>    box.us_view |= BORDER_RED; <span class="hljs-comment">/* wrong approach */</span>    box.us_view &amp;= ~STYLE_MASK; <span class="hljs-comment">/* clear style bits */</span>    box.us_view |= B_DOTTED; <span class="hljs-comment">/* set style to dotted */</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nModified box settings:\n"</span>);    show_settings(&amp;box.st_view);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nBox settings using unsigned int view:\n"</span>);    show_settings1(box.us_view);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"bits are %s\n"</span>,    itobs(box.us_view,bin_str));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_settings</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct box_props * pb)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Box is %s.\n"</span>,    pb-&gt;opaque == <span class="hljs-literal">true</span> ? <span class="hljs-string">"opaque"</span>: <span class="hljs-string">"transparent"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The fill color is %s.\n"</span>, colors[pb-&gt;fill_color]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Border %s.\n"</span>,    pb-&gt;show_border == <span class="hljs-literal">true</span> ? <span class="hljs-string">"shown"</span> : <span class="hljs-string">"not shown"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The border color is %s.\n"</span>, colors[pb-&gt;border_color]);    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"The border style is "</span>);    <span class="hljs-keyword">switch</span>(pb-&gt;border_style)    &#123;        <span class="hljs-keyword">case</span> SOLID : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"solid.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> DOTTED : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dotted.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> DASHED : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dashed.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span> : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"unknown type.\n"</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_settings1</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> short us)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"box is %s.\n"</span>,    (us &amp; OPAQUE) == OPAQUE? <span class="hljs-string">"opaque"</span>: <span class="hljs-string">"transparent"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The fill color is %s.\n"</span>,    colors[(us &gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">07</span>]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Border %s.\n"</span>,    (us &amp; BORDER) == BORDER? <span class="hljs-string">"shown"</span> : <span class="hljs-string">"not shown"</span>);    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"The border style is "</span>);    <span class="hljs-keyword">switch</span>(us &amp; STYLE_MASK)    &#123;        <span class="hljs-keyword">case</span> B_SOLID : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"solid.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> B_DOTTED : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dotted.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> B_DASHED : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dashed.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span> : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"unknown type.\n"</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The border color is %s.\n"</span>,    colors[(us &gt;&gt; <span class="hljs-number">9</span>) &amp; <span class="hljs-number">07</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">itobs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> * ps)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = CHAR_BIT * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);    <span class="hljs-keyword">for</span> (i = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--, n &gt;&gt;= <span class="hljs-number">1</span>)        ps[i] = (<span class="hljs-number">01</span> &amp; n) + <span class="hljs-string">'0'</span>;    ps[<span class="hljs-built_in">size</span>] = <span class="hljs-string">'\0'</span>;    <span class="hljs-keyword">return</span> ps;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>File Input/Output</title>
    <link href="/2020/12/06/File-Input-Output/"/>
    <url>/2020/12/06/File-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 13 File Input/Output</p><a id="more"></a><h1 id="1-Communicating-with-Files"><a href="#1-Communicating-with-Files" class="headerlink" title="1. Communicating with Files"></a>1. Communicating with Files</h1><h2 id="1-File"><a href="#1-File" class="headerlink" title="(1) File"></a>(1) File</h2><p>A <strong>file</strong> is a named section of storage, usually on a disk, or, more recently, on a solid-state device.</p><p>C views a <strong>file</strong> as a continuous sequence of bytes, each of which can be read individually. C provides two ways to view files: the <strong>text view</strong> and the <strong>binary view</strong>.</p><p>All file content is in <strong>binary form</strong> (zeros and ones). But if a file primarily uses the <strong>binary codes</strong> for <strong>characters</strong> (for instance, <strong>ASCII</strong> or <strong>Unicode</strong>) to represent <strong>text</strong>, much as a <strong>C string</strong> does, then it is a <strong>text file</strong>; it has text content. </p><p>If the <strong>binary values</strong> in the file represent <strong>machinelanguage code</strong> or <strong>numeric data</strong> (using the same internal representation as, say, used for long or double values) or image or music encoding, the content is <strong>binary</strong>.</p><p>To bring some regularity to the handling of text files, C provides two ways of accessing a file: <strong>binary mode</strong> and <strong>text mode</strong>. </p><p>In the <strong>binary mode</strong>, each and every byte of the file is accessible to a program. </p><p>In the <strong>text mode</strong>, however, what the program sees can differ from what is in the file. </p><p>For example, a C program compiled on an older Macintosh and using text mode would convert \r to \n when reading a file in text mode and convert \n to \r when writing to a file. </p><h2 id="2-Standard-Files"><a href="#2-Standard-Files" class="headerlink" title="(2) Standard Files"></a>(2) Standard Files</h2><p>C programs automatically open three files on your behalf. They are termed the <strong>standard input</strong>, the <strong>standard output</strong>, and the <strong>standard error output</strong>. </p><p>The <strong>standard input</strong>, by default, is the normal input device for your system, usually your keyboard. Both the <strong>standard output</strong> and the <strong>standard error output</strong>, by default, are the normal output device for your system, usually your display screen.</p><p>The purpose of the <strong>standard error output</strong> file is to provide a logically distinct place to send error messages. If, for example, you use redirection to send output to a file instead of to the screen, output sent to the standard error output still goes to the screen. </p><h1 id="2-Standard-I-O"><a href="#2-Standard-I-O" class="headerlink" title="2. Standard I/O"></a>2. Standard I/O</h1><p>The <strong>standard I/O package</strong> has two advantages, besides <strong>portability</strong>, over low-level I/O. </p><p>First, it has many specialized functions that simplify handling different I/O problems. </p><p>Second, input and output are <strong>buffered</strong>. That is, information is transferred in large chunks (typically 512 bytes at a time or more) instead of a byte at a time. </p><h2 id="1-The-fopen-Function"><a href="#1-The-fopen-Function" class="headerlink" title="(1) The fopen() Function"></a>(1) The fopen() Function</h2><p>The program uses <strong>fopen()</strong> to open the file. This function is declared in <strong>stdio.h</strong>. </p><p>Its <strong>first argument</strong> is the name of the file to be opened; more exactly, it is the address of a string containing that name. The <strong>second argument</strong> is a string identifying the <strong>mode</strong> in which the file is to be opened.</p><table><thead><tr><th align="left">Mode String</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">“r”</td><td align="left"></td></tr><tr><td align="left">“w”</td><td align="left">Open a text file for writing, truncating an existing file to zero length, or creating the file if it does not exist.</td></tr><tr><td align="left">“a”</td><td align="left">Open a text file for writing, appending to the end of an existing file, or creating the file if it does not exist.</td></tr><tr><td align="left">“r+”</td><td align="left">Open a text file for update (that is, for both reading and writing).</td></tr><tr><td align="left">“w+</td><td align="left">Open a text file for update (reading and writing), first truncating the file to zero length if it exists or creating the file if it does not exist.</td></tr><tr><td align="left">“a+</td><td align="left">Open a text file for update (reading and writing), appending to the end of an existing file, or creating the file if it does not yet exist; the whole file can be read, but writing can only be appended.</td></tr><tr><td align="left">“rb”, “wb”, “ab”, “ab+”, “a+b”, “wb+”, “w+b”, “ab+”, “a+b”</td><td align="left">Like the preceding modes, except they use binary mode instead of text mode.</td></tr><tr><td align="left">“wx”, “wbx”, “w+x”, “wb+x” or “w+bx”</td><td align="left">(C11) Like the non-x modes, except they fail if the file already exists and they open a file in exclusive mode, if possible.</td></tr></tbody></table><p>After your program successfully opens a file, <strong>fopen()</strong> returns a <strong>file pointer</strong>, which the other I/O functions can then use to specify the file. The file pointer is of type <strong>pointer-to-FILE</strong>. The pointer points to a <strong>data object</strong> containing information about the file, including information about the buffer used for the file’s I/O. </p><p>The <strong>fopen()</strong> function returns the <strong>null pointer</strong> (also defined in stdio.h) if it cannot open the file. </p><h2 id="2-The-getc-and-putc-Functions"><a href="#2-The-getc-and-putc-Functions" class="headerlink" title="(2) The getc() and putc() Functions"></a>(2) The getc() and putc() Functions</h2><p>The two functions <strong>getc()</strong> and <strong>putc()</strong> work very much like <strong>getchar()</strong> and <strong>putchar()</strong>. The difference is that you must tell these newcomers <strong>which file to use</strong>. </p><pre><code class="hljs c">ch = getchar();<span class="hljs-comment">//get a character from the file identified by fp</span>ch = getc(fp);</code></pre><pre><code class="hljs c"><span class="hljs-comment">//put the character ch into the file identified by the FILE pointer fpout</span>putc(ch, fpout);</code></pre><p><code>putc(ch,stdout)</code> is the same as <code>putchar(ch)</code>. </p><h2 id="3-End-of-File"><a href="#3-End-of-File" class="headerlink" title="(3) End-of-File"></a>(3) End-of-File</h2><p>The <strong>getc()</strong> function returns the special value <strong>EOF</strong> if it tries to read a character and discovers it has reached the end of the file. So a C program discovers it has reached the end of a file only after it tries to read past the end of the file. </p><h2 id="4-The-fclose-Function"><a href="#4-The-fclose-Function" class="headerlink" title="(4) The fclose() Function"></a>(4) The fclose() Function</h2><p>The <strong>fclose(fp)</strong> function closes the file identified by <code>fp</code>, flushing buffers as needed. </p><p>The function <strong>fclose()</strong> returns a value of <strong>0</strong> if successful, and <strong>EOF</strong> if not:</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fclose(fp) != <span class="hljs-number">0</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error in closing file %s\n"</span>, argv[<span class="hljs-number">1</span>]);</code></pre><p>The <strong>fclose()</strong> function can fail if, for example, the disk is full, a removable storage device has been removed, or there has been an I/O error.</p><h2 id="5-Pointers-to-the-Standard-Files"><a href="#5-Pointers-to-the-Standard-Files" class="headerlink" title="(5) Pointers to the Standard Files"></a>(5) Pointers to the Standard Files</h2><p>The <strong>stdio.h</strong> file associates three file pointers with the three standard files automatically opened by C programs:</p><table><thead><tr><th align="left">Standard File</th><th align="left">File Pointer</th><th align="left">Normally</th></tr></thead><tbody><tr><td align="left">Standard input</td><td align="left">stdin</td><td align="left">Your keyboard</td></tr><tr><td align="left">Standard output</td><td align="left">stdout</td><td align="left"></td></tr><tr><td align="left">Standard error</td><td align="left">stderr</td><td align="left">Your screen</td></tr></tbody></table><p>These pointers are all type <strong>pointer-to-FILE</strong>, so they can be used as arguments to the <strong>standard I/O functions</strong>.</p><h1 id="3-File-I-O-fprintf-fscanf-fgets-and-fputs"><a href="#3-File-I-O-fprintf-fscanf-fgets-and-fputs" class="headerlink" title="3. File I/O: fprintf(), fscanf(), fgets(), and fputs()"></a>3. File I/O: fprintf(), fscanf(), fgets(), and fputs()</h1><h2 id="1-The-fprintf-and-fscanf-Functions"><a href="#1-The-fprintf-and-fscanf-Functions" class="headerlink" title="(1) The fprintf() and fscanf() Functions"></a>(1) The fprintf() and fscanf() Functions</h2><p>The file I/O functions <strong>fprintf()</strong> and <strong>fscanf()</strong> work just like <strong>printf()</strong> and <strong>scanf()</strong>, except that they require an additional first argument to identify the proper <strong>file</strong>.</p><pre><code class="hljs c"><span class="hljs-comment">/* addaword.c -- uses fprintf(), fscanf(), and rewind() */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 41</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    FILE *fp;    <span class="hljs-keyword">char</span> words[MAX];    <span class="hljs-keyword">if</span> ((fp = fopen(<span class="hljs-string">"wordy"</span>, <span class="hljs-string">"a+"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>,<span class="hljs-string">"Can't open \"wordy\" file.\n"</span>);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter words to add to the file; press the #"</span>);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"key at the beginning of a line to terminate."</span>);    <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">fscanf</span>(<span class="hljs-built_in">stdin</span>,<span class="hljs-string">"%40s"</span>, words) == <span class="hljs-number">1</span>) &amp;&amp; (words[<span class="hljs-number">0</span>] != <span class="hljs-string">'#'</span>))        <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">"%s\n"</span>, words);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"File contents:"</span>);    rewind(fp); <span class="hljs-comment">/* go back to beginning of file */</span>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">"%s"</span>,words) == <span class="hljs-number">1</span>)        <span class="hljs-built_in">puts</span>(words);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Done!"</span>);    <span class="hljs-keyword">if</span> (fclose(fp) != <span class="hljs-number">0</span>)        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Error closing file\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre><p>The <strong>rewind()</strong> command takes the program to the <strong>file beginning</strong> so that the final while loop can print the file contents.</p><h2 id="2-The-fgets-and-fputs-Functions"><a href="#2-The-fgets-and-fputs-Functions" class="headerlink" title="(2) The fgets() and fputs() Functions"></a>(2) The fgets() and fputs() Functions</h2><pre><code class="hljs c">fgets(buf, STLEN, fp);</code></pre><p><strong>The first argument</strong> of <strong>fgets()</strong>, as with the banished <strong>gets()</strong>, is the address (type <strong>char *</strong>) where input should be stored. </p><p><strong>The second argument</strong> is an integer representing the <strong>maximum size of the input string</strong>. </p><p><strong>The final argument</strong> is the <strong>file pointer</strong> identifying the file to be read. </p><p>The <strong>fgets()</strong> function reads input through the <strong>first newline character</strong>, until one fewer than the upper limit of characters is read, or until the end-of-file is found; <strong>fgets()</strong> then adds a <strong>terminating null character</strong> to form a string. </p><p>Therefore, the <strong>upper limit</strong> represents the <strong>maximum number of characters</strong> plus the <strong>null character</strong>. </p><p>If <strong>fgets()</strong> reads in a whole line before running into the character limit, it places the <strong>newline character</strong>, marking the end of the line into the string, just before the <strong>null character</strong>. </p><p>The <strong>fgets()</strong> function returns the value <strong>NULL</strong> when it encounters <strong>EOF</strong>. You can use this to check for the end of a file. Otherwise, it returns the address passed to it.</p><pre><code class="hljs c"><span class="hljs-built_in">fputs</span>(buf, fp);</code></pre><p>The <strong>fputs()</strong> function takes two arguments: first, an <strong>address of a string</strong> and then a <strong>file pointer</strong>.</p><p>It writes the string found at the pointed-to location into the indicated file. <strong>Unlike puts()</strong>, <strong>fputs()</strong> does not append a <strong>newline</strong> when it prints. </p><h1 id="4-fseek-and-ftell"><a href="#4-fseek-and-ftell" class="headerlink" title="4. fseek() and ftell()"></a>4. fseek() and ftell()</h1><p>The <strong>fseek()</strong> function enables you to treat a <strong>file</strong> like an <strong>array</strong> and move directly to any particular byte in a <strong>file</strong> opened by <strong>fopen()</strong>. </p><pre><code class="hljs c"><span class="hljs-comment">/* reverse.c -- displays a file in reverse order */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CNTL_Z <span class="hljs-meta-string">'\032'</span> <span class="hljs-comment">/* eof marker in DOS text files */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLEN 81</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> file[SLEN];    <span class="hljs-keyword">char</span> ch;    FILE *fp;    <span class="hljs-keyword">long</span> count, last;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter the name of the file to be processed:"</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%80s"</span>, file);    <span class="hljs-keyword">if</span> ((fp = fopen(file,<span class="hljs-string">"rb"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;   <span class="hljs-comment">/* read-only mode */</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"reverse can't open %s\n"</span>, file);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    fseek(fp, <span class="hljs-number">0L</span>, SEEK_END); <span class="hljs-comment">/* go to end of file */</span>    last = ftell(fp);    <span class="hljs-keyword">for</span> (count = <span class="hljs-number">1L</span>; count &lt;= last; count++)    &#123;        fseek(fp, -count, SEEK_END); <span class="hljs-comment">/* go backward */</span>        ch = getc(fp);        <span class="hljs-keyword">if</span> (ch != CNTL_Z &amp;&amp; ch != <span class="hljs-string">'\r'</span>) <span class="hljs-comment">/* MS-DOS files */</span>            <span class="hljs-built_in">putchar</span>(ch);    &#125;    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);    fclose(fp);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>The <strong>first of the three arguments</strong> to <strong>fseek()</strong> is a <strong>FILE pointer</strong> to the file being searched. The file should have been opened by using <strong>fopen()</strong>.</p><p>The <strong>second argument</strong> to <strong>fseek()</strong> is called the <strong>offset</strong>. This argument tells how far to move from the <strong>starting point</strong> (see the following list of mode starting points). The argument must be a <strong>long value</strong>. It can be <strong>positive</strong> (move forward), <strong>negative</strong> (move backward), or <strong>zero</strong> (stay put).</p><p><strong>The third argument</strong> is the <strong>mode</strong>, and it identifies the <strong>starting point</strong>. Since the <strong>ANSI standard</strong>, the <strong>stdio.h</strong> header file specifies the following manifest constants for the mode:</p><table><thead><tr><th align="left">Mode</th><th align="left">Measures Offset From</th></tr></thead><tbody><tr><td align="left">SEEK_SET</td><td align="left">Beginning of file</td></tr><tr><td align="left">SEEK_CUR</td><td align="left">Current position</td></tr><tr><td align="left">SEEK_END</td><td align="left">End of file</td></tr></tbody></table><p>Older implementations may lack these definitions and, instead, use the numeric values <code>0L</code>, <code>1L</code>, and <code>2L</code>, respectively, for these <strong>modes</strong>. The <code>L</code> suffix identifies type <strong>long values</strong>. </p><pre><code class="hljs c">fseek(fp, <span class="hljs-number">0L</span>, SEEK_SET); <span class="hljs-comment">// go to the beginning of the file</span>fseek(fp, <span class="hljs-number">10L</span>, SEEK_SET); <span class="hljs-comment">// go 10 bytes into the file</span>fseek(fp, <span class="hljs-number">2L</span>, SEEK_CUR); <span class="hljs-comment">// advance 2 bytes from the current position</span>fseek(fp, <span class="hljs-number">0L</span>, SEEK_END); <span class="hljs-comment">// go to the end of the file</span>fseek(fp, <span class="hljs-number">-10L</span>, SEEK_END); <span class="hljs-comment">// back up 10 bytes from the end of the file</span></code></pre><p>The value <strong>returned</strong> by <strong>fseek()</strong> is <strong>0</strong> if everything is okay, and <strong>-1</strong> if there is an error, such as attempting to move <strong>past the bounds</strong> of the <strong>file</strong>.</p><p>The <strong>ftell()</strong> function is type <strong>long</strong>, and it <strong>returns</strong> the <strong>current file location</strong>. Under <strong>ANSI C</strong>, it is declared in <strong>stdio.h</strong>. </p><p>As originally implemented in Unix, <strong>ftell()</strong> specifies the <strong>file position</strong> by returning the number of bytes from the <strong>beginning</strong>, with the <strong>first byte</strong> being byte <strong>0</strong>, and so on.</p><p>Under <strong>ANSI C</strong>, this definition applies to files opened in the <strong>binary mode</strong>, but not necessarily to files opened in the <strong>text mode</strong>. </p><p>The <strong>ftell()</strong> function may work <strong>differently</strong> in the <strong>text mode</strong> than in the <strong>binary mode</strong>. </p><h1 id="5-The-fgetpos-and-fsetpos-Functions"><a href="#5-The-fgetpos-and-fsetpos-Functions" class="headerlink" title="5. The fgetpos() and fsetpos() Functions"></a>5. The fgetpos() and fsetpos() Functions</h1><p>One potential problem with <strong>fseek()</strong> and ftell()<strong>** is that they **limit file sizes</strong> to values that can be represented by type <strong>long</strong>. </p><p><strong>ANSI C</strong> introduced two <strong>new positioning functions</strong> designed to work with <strong>larger file sizes</strong>. Instead of using a <strong>long</strong> value to represent a position, it uses a new type, called <strong>fpos_t</strong> (for file position type) for that purpose.</p><p>The <strong>fpos_t</strong> type is not a fundamental type; rather, it is defined in terms of other types. A variable or data object of <strong>fpos_t</strong> type can <strong>specify a location</strong> within a file, and it <strong>cannot be an array type</strong>, but its nature is not specified beyond that. </p><p><strong>ANSI C</strong> does define how <strong>fpos_t</strong> is used. The <strong>fgetpos()</strong> function has this prototype:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fgetpos</span><span class="hljs-params">(FILE * <span class="hljs-keyword">restrict</span> stream, <span class="hljs-keyword">fpos_t</span> * <span class="hljs-keyword">restrict</span> pos)</span></span>;</code></pre><p>When called, it places an <strong>fpos_t</strong> value in the location pointed to by <code>pos</code>; the value describes a location in the file. The function <strong>returns zero</strong> if successful and a <strong>nonzero</strong> value for failure.</p><p>The <strong>fsetpos()</strong> function has this prototype: </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fsetpos</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">fpos_t</span> *pos)</span></span>;</code></pre><p>When called, it uses the <strong>fpos_t</strong> value in the location pointed to by <code>pos</code> to set the file pointer to the location indicated by that value. The function <strong>returns zero</strong> if successful and a <strong>nonzero</strong> value for failure. The <strong>fpos_t</strong> value should have been obtained by a previous call to <strong>fgetpos()</strong>.</p><h1 id="6-Other-Standard-I-O-Functions"><a href="#6-Other-Standard-I-O-Functions" class="headerlink" title="6. Other Standard I/O Functions"></a>6. Other Standard I/O Functions</h1><h2 id="1-The-int-ungetc-int-c-FILE-fp-Function"><a href="#1-The-int-ungetc-int-c-FILE-fp-Function" class="headerlink" title="(1) The int ungetc(int c, FILE *fp) Function"></a>(1) The int ungetc(int c, FILE *fp) Function</h2><p>The <strong>int ungetc()</strong> function pushes the character specified by <code>c</code> back onto the input stream.</p><p>If you push a character onto the input stream, the next call to a standard input function reads that character.</p><p>The <strong>ANSI C</strong> standard guarantees <strong>only one pushback</strong> at a time. If an implementation permits you to push back <strong>several characters in a row</strong>, the input functions read them in the <strong>reversed order of pushing</strong>.</p><p><img src="_v_images/20201206172345396_1469727691.png" srcset="/img/loading.gif" alt="The ungetc() Function"></p><h2 id="2-The-int-fflush-Function"><a href="#2-The-int-fflush-Function" class="headerlink" title="(2) The int fflush() Function"></a>(2) The int fflush() Function</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fflush</span><span class="hljs-params">(FILE *fp)</span></span>;</code></pre><p>Calling the <strong>fflush()</strong> function causes any <strong>unwritten data in the output buffer</strong> to be sent to the <strong>output file</strong> identified by <code>fp</code>. This process is called <strong>flushing a buffer</strong>. </p><p>If <code>fp</code> is the <strong>null pointer</strong>, all output buffers are flushed. </p><p>The effect of using <strong>fflush()</strong> on an <strong>input stream</strong> is <strong>undefined</strong>. </p><h2 id="3-The-int-setvbuf-Function"><a href="#3-The-int-setvbuf-Function" class="headerlink" title="(3) The int setvbuf() Function"></a>(3) The int setvbuf() Function</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setvbuf</span><span class="hljs-params">(FILE * <span class="hljs-keyword">restrict</span> fp, <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> buf, <span class="hljs-keyword">int</span> mode, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span></span>;</code></pre><p>The <strong>setvbuf()</strong> function sets up an <strong>alternative buffer</strong> to be used by the standard I/O functions. It is called <strong>after the file has been opened</strong> and <strong>before any other operations have been performed</strong> on the stream. </p><p>The pointer <code>fp</code> identifies the stream, and <code>buf</code> points to the storage to be used. If the value of <code>buf</code> is <strong>not NULL</strong>, you must create the <strong>buffer</strong>. </p><p>For instance, you could declare an array of 1,024 chars and pass the address of that array. However, if you use <strong>NULL</strong> for the value of <code>buf</code>, the function allocates a <strong>buffer</strong> itself. The size variable tells <strong>setvbuf()</strong> how big the array is.</p><p>The <strong>mode</strong> is selected from the following choices: <strong>_IOFBF</strong> means <strong>fully buffered</strong> (buffer flushed when full), <strong>_IOLBF</strong> means <strong>line-buffered</strong> (buffer flushed when full or when a <strong>newline</strong> is written), and <strong>_IONBF</strong> means <strong>nonbuffered</strong>. </p><p>The function returns <strong>zero</strong> if successful, <strong>nonzero</strong> otherwise.</p><p>Suppose you have a program that works with stored data objects having, say, a size of 3,000 bytes each. You could use <strong>setvbuf()</strong> to create a <strong>buffer</strong> whose size is a multiple of the data object’s size. </p><h2 id="4-Binary-I-O-fread-and-fwrite"><a href="#4-Binary-I-O-fread-and-fwrite" class="headerlink" title="(4) Binary I/O: fread() and fwrite()"></a>(4) Binary I/O: fread() and fwrite()</h2><p>In general, <strong>fprintf()</strong> converts <strong>numeric values</strong> to <strong>character data</strong>, possibly <strong>altering the value</strong>.</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> num = <span class="hljs-number">1.</span>/<span class="hljs-number">3.</span>;<span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">"%f"</span>, num);</code></pre><p>saves <code>num</code> as a sequence of eight characters: <code>0.333333</code>. Using a <code>%.2f</code> specifier saves it as four characters: <code>0.33</code>.</p><p>Changing the specifier alters the amount of space needed to store the value; it can also result in different values being stored. After the value of <code>num</code> is stored as <code>0.33</code>, there is <strong>no way to get back the full precision</strong> when the file is read. </p><p>The <strong>most accurate and consistent</strong> way to store a number is to use the <strong>same pattern of bits</strong> that the computer does. Therefore, a <strong>double</strong> value should be stored in a size <strong>double unit</strong>. </p><p>When data is stored in a file using the same representation that the program uses, we say that the data is stored in <strong>binary form</strong>. There is <strong>no conversion from</strong> numeric forms to character sequences. </p><p>For <strong>standard I/O</strong>, the <strong>fread()</strong> and <strong>fwrite()</strong> functions provide this <strong>binary service</strong>.</p><p><img src="_v_images/20201206174743443_124649534.png" srcset="/img/loading.gif" alt="Binary and text output"></p><h3 id="The-size-t-fwrite-Function"><a href="#The-size-t-fwrite-Function" class="headerlink" title="The size_t fwrite() Function"></a>The size_t fwrite() Function</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">restrict</span> ptr, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">size_t</span> nmemb, FILE * <span class="hljs-keyword">restrict</span> fp)</span></span>;</code></pre><p>The <strong>fwrite()</strong> function <strong>writes binary data</strong> to a file. </p><p>The <strong>size_t</strong> type is defined in terms of the standard C types. It is the type returned by the <strong>sizeof</strong> operator. Typically, it is <strong>unsigned int</strong>, but an implementation can choose another type. </p><p>The pointer <code>ptr</code> is the address of the chunk of data to be written. </p><p>Also, <code>size</code> represents the size, in <strong>bytes</strong>, of the chunks to be written, and<br><code>nmemb</code> represents the number of chunks to be written. As usual, <code>fp</code> identifies the file to be written to. </p><p>For instance, to save a data object (such as an array) that is 256 bytes in size, you<br>can do this:</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> <span class="hljs-built_in">buffer</span>[<span class="hljs-number">256</span>];fwrite(<span class="hljs-built_in">buffer</span>, <span class="hljs-number">256</span>, <span class="hljs-number">1</span>, fp);</code></pre><p>This call writes one chunk of 256 bytes from buffer to the file. </p><p>Or, to save an array of 10 double values, you can do this:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> earnings[<span class="hljs-number">10</span>];fwrite(earnings, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>), <span class="hljs-number">10</span>, fp);</code></pre><p>This call writes data from the <code>earnings</code> array to the file in 10 chunks, each of size double.</p><p>One problem with <strong>fwrite()</strong> is that its <strong>first argument</strong> is <strong>not a fixed type</strong>. Under ANSI C function prototyping, these actual arguments are converted to the <strong>pointer-to-void</strong> type, which acts as a sort of catchall type for pointers. </p><p>The <strong>fwrite()</strong> function <strong>returns</strong> the <strong>number of items</strong> successfully written. Normally, this equals <code>nmemb</code>, but it can be less if there is a write error.</p><h3 id="The-size-t-fread-Function"><a href="#The-size-t-fread-Function" class="headerlink" title="The size_t fread() Function"></a>The size_t fread() Function</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * <span class="hljs-keyword">restrict</span> ptr, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">size_t</span> nmemb, FILE * <span class="hljs-keyword">restrict</span> fp)</span></span>;</code></pre><p>The <strong>fread()</strong> function takes the same set of arguments that <strong>fwrite()</strong> does. </p><p>This time <code>ptr</code> is the address of the memory storage into which file data is read, and <code>fp</code> identifies the file to be read. </p><p>For example, to recover the array of 10 doubles saved in the previous example, use this call:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> earnings[<span class="hljs-number">10</span>];fread(earnings, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>), <span class="hljs-number">10</span>, fp);</code></pre><p>This call copies 10 size <strong>double</strong> values into the <code>earnings</code> array.</p><p>The <strong>fread()</strong> function returns the <strong>number of items</strong> successfully read. Normally, this equals <code>nmemb</code>, but it can be less if there is a read error or if the <strong>end-of-file</strong> is reached.</p><h2 id="5-The-int-feof-FILE-fp-and-int-ferror-FILE-fp-Functions"><a href="#5-The-int-feof-FILE-fp-and-int-ferror-FILE-fp-Functions" class="headerlink" title="(5) The int feof(FILE *fp) and int ferror(FILE *fp) Functions"></a>(5) The int feof(FILE *fp) and int ferror(FILE *fp) Functions</h2><p>When the standard input functions return <strong>EOF</strong>, this usually means they have reached the <strong>end of a file</strong>. However, it can also indicate that a <strong>read error</strong> has occurred. </p><p>The <strong>feof()</strong> and <strong>ferror()</strong> functions enable you to <strong>distinguish between the two possibilities</strong>. </p><p>The <strong>feof()</strong> function returns a <strong>nonzero</strong> value if the last input call detected the <strong>end-of-file</strong>, and it returns <strong>zero</strong> otherwise. </p><p>The <strong>ferror()</strong> function returns a <strong>nonzero</strong> value if a read or write <strong>error</strong> has occurred, and it returns <strong>zero</strong> otherwise.</p><h2 id="6-An-fread-and-fwrite-Example"><a href="#6-An-fread-and-fwrite-Example" class="headerlink" title="(6) An fread() and fwrite() Example"></a>(6) An fread() and fwrite() Example</h2><pre><code class="hljs c"><span class="hljs-comment">/* append.c -- appends files to a file */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFSIZE 4096</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLEN 81</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(FILE *source, FILE *dest)</span></span>;<span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * st, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    FILE *fa, *fs; <span class="hljs-comment">// fa for append file, fs for source file</span>    <span class="hljs-keyword">int</span> files = <span class="hljs-number">0</span>; <span class="hljs-comment">// number of files appended</span>    <span class="hljs-keyword">char</span> file_app[SLEN]; <span class="hljs-comment">// name of append file</span>    <span class="hljs-keyword">char</span> file_src[SLEN]; <span class="hljs-comment">// name of source file</span>    <span class="hljs-keyword">int</span> ch;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter name of destination file:"</span>);    s_gets(file_app, SLEN);    <span class="hljs-keyword">if</span> ((fa = fopen(file_app, <span class="hljs-string">"a+"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Can't open %s\n"</span>, file_app);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-keyword">if</span> (setvbuf(fa, <span class="hljs-literal">NULL</span>, _IOFBF, BUFSIZE) != <span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">"Can't create output buffer\n"</span>, <span class="hljs-built_in">stderr</span>);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter name of first source file (empty line to quit):"</span>);    <span class="hljs-keyword">while</span> (s_gets(file_src, SLEN) &amp;&amp; file_src[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span>)    &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(file_src, file_app) == <span class="hljs-number">0</span>)            <span class="hljs-built_in">fputs</span>(<span class="hljs-string">"Can't append file to itself\n"</span>,<span class="hljs-built_in">stderr</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fs = fopen(file_src, <span class="hljs-string">"r"</span>)) == <span class="hljs-literal">NULL</span>)            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Can't open %s\n"</span>, file_src);        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span> (setvbuf(fs, <span class="hljs-literal">NULL</span>, _IOFBF, BUFSIZE) != <span class="hljs-number">0</span>)            &#123;                <span class="hljs-built_in">fputs</span>(<span class="hljs-string">"Can't create input buffer\n"</span>,<span class="hljs-built_in">stderr</span>);                <span class="hljs-keyword">continue</span>;            &#125;            append(fs, fa);            <span class="hljs-keyword">if</span> (ferror(fs) != <span class="hljs-number">0</span>)            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Error in reading file %s.\n"</span>,            file_src);            <span class="hljs-keyword">if</span> (ferror(fa) != <span class="hljs-number">0</span>)            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Error in writing file %s.\n"</span>,            file_app);            fclose(fs);            files++;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"File %s appended.\n"</span>, file_src);            <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Next file (empty line to quit):"</span>);        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Done appending. %d files appended.\n"</span>, files);    rewind(fa);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s contents:\n"</span>, file_app);    <span class="hljs-keyword">while</span> ((ch = getc(fa)) != EOF)        <span class="hljs-built_in">putchar</span>(ch);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Done displaying."</span>);    fclose(fa);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(FILE *source, FILE *dest)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">size_t</span> bytes;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> temp[BUFSIZE]; <span class="hljs-comment">// allocate once</span>    <span class="hljs-keyword">while</span> ((bytes = fread(temp,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>),BUFSIZE,source)) &gt; <span class="hljs-number">0</span>)        fwrite(temp, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), bytes, dest);&#125;<span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * st, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> * ret_val;    <span class="hljs-keyword">char</span> * <span class="hljs-built_in">find</span>;    ret_val = fgets(st, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span> (ret_val)    &#123;        <span class="hljs-built_in">find</span> = <span class="hljs-built_in">strchr</span>(st, <span class="hljs-string">'\n'</span>); <span class="hljs-comment">// look for newline</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>) <span class="hljs-comment">// if the address is not NULL,</span>            *<span class="hljs-built_in">find</span> = <span class="hljs-string">'\0'</span>; <span class="hljs-comment">// place a null character there</span>        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">'\n'</span>)                <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret_val;&#125;</code></pre><h2 id="7-Random-Access-with-Binary-I-O"><a href="#7-Random-Access-with-Binary-I-O" class="headerlink" title="(7) Random Access with Binary I/O"></a>(7) Random Access with Binary I/O</h2><pre><code class="hljs c"><span class="hljs-comment">/* randbin.c -- random access, binary i/o */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARSIZE 1000</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> numbers[ARSIZE];    <span class="hljs-keyword">double</span> value;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file = <span class="hljs-string">"numbers.dat"</span>;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">long</span> pos;    FILE *iofile;    <span class="hljs-comment">// create a set of double values</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; ARSIZE; i++)        numbers[i] = <span class="hljs-number">100.0</span> * i + <span class="hljs-number">1.0</span> / (i + <span class="hljs-number">1</span>);    <span class="hljs-comment">// attempt to open file</span>    <span class="hljs-keyword">if</span> ((iofile = fopen(file, <span class="hljs-string">"wb"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not open %s for output.\n"</span>, file);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-comment">// write array in binary format to file</span>    fwrite(numbers, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>), ARSIZE, iofile);    fclose(iofile);    <span class="hljs-keyword">if</span> ((iofile = fopen(file, <span class="hljs-string">"rb"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,        <span class="hljs-string">"Could not open %s for random access.\n"</span>, file);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-comment">// read selected items from file</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter an index in the range 0-%d.\n"</span>, ARSIZE<span class="hljs-number">-1</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;i) == <span class="hljs-number">1</span> &amp;&amp; i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; ARSIZE)    &#123;        pos = (<span class="hljs-keyword">long</span>)i * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>);<span class="hljs-comment">// calculate offset</span>        fseek(iofile, pos, SEEK_SET); <span class="hljs-comment">// go there</span>        fread(&amp;value, <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">double</span>), <span class="hljs-number">1</span>, iofile);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The value there is %f.\n"</span>, value);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Next index (out of range to quit):\n"</span>);    &#125;    <span class="hljs-comment">// finish up</span>    fclose(iofile);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Character Strings and String Functions</title>
    <link href="/2020/12/01/Character-Strings-and-String-Functions/"/>
    <url>/2020/12/01/Character-Strings-and-String-Functions/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 11 Character Strings and String Functions</p><a id="more"></a><h1 id="1-Representing-Strings-and-String-I-O"><a href="#1-Representing-Strings-and-String-I-O" class="headerlink" title="1. Representing Strings and String I/O"></a>1. Representing Strings and String I/O</h1><p>The <strong>puts()</strong> function, like <strong>printf()</strong>, belongs to the the <strong>stdio.h</strong> family of <strong>input/output</strong> functions. It only displays <strong>strings</strong>, and, unlike <strong>printf()</strong>, it automatically <strong>appends a newline</strong> to the string it displays. </p><p>There are many ways to define a string. The principal ways are using string constants, using char arrays, and using char pointers. </p><p>A program should make sure there is a place to store a string.</p><h2 id="1-Character-String-Literals-String-Constants"><a href="#1-Character-String-Literals-String-Constants" class="headerlink" title="(1) Character String Literals (String Constants)"></a>(1) Character String Literals (String Constants)</h2><p>A <strong>string literal</strong>, also termed a <strong>string constant</strong>, is anything enclosed in <strong>double quotation marks</strong>. The enclosed characters, plus a terminating <code>\0</code> character automatically provided by the compiler, are stored in memory as a character string. </p><p><strong>Character string constants</strong> are placed in the <strong>static storage class</strong>, which means that if you use a <strong>string constant</strong> in a function, the string is <strong>stored just once</strong> and <strong>lasts for the duration of the program</strong>, even if the function is called several times. </p><h2 id="2-Character-String-Arrays-and-Initialization"><a href="#2-Character-String-Arrays-and-Initialization" class="headerlink" title="(2) Character String Arrays and Initialization"></a>(2) Character String Arrays and Initialization</h2><p>When you define a <strong>character string array</strong>, you must let the compiler know <strong>how much space</strong> is needed. </p><h1 id="2-Array-Versus-Pointer"><a href="#2-Array-Versus-Pointer" class="headerlink" title="2. Array Versus Pointer"></a>2. Array Versus Pointer</h1><p>In short, initializing the <strong>array</strong> copies a <strong>string</strong> from <strong>static storage</strong> to the <strong>array</strong>, whereas initializing the <strong>pointer</strong> merely copies the <strong>address</strong> of the <strong>string</strong>.</p><h2 id="1-Array-and-Pointer-Differences"><a href="#1-Array-and-Pointer-Differences" class="headerlink" title="(1) Array and Pointer Differences"></a>(1) Array and Pointer Differences</h2><p>The chief <strong>difference</strong> is that the <strong>array name</strong> is a <strong>constant</strong>, but the <strong>pointer</strong> is a variable. </p><p>In short, don’t use a <strong>pointer to a string literal</strong> if you plan to alter the string.</p><h2 id="2-Arrays-of-Character-Strings"><a href="#2-Arrays-of-Character-Strings" class="headerlink" title="(2) Arrays of Character Strings"></a>(2) Arrays of Character Strings</h2><p><img src="https://img-blog.csdnimg.cn/20190615215441173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="3-String-Input"><a href="#3-String-Input" class="headerlink" title="3. String Input"></a>3. String Input</h1><p>If you want to read a <strong>string</strong> into a program, you must first <strong>set aside space</strong> to store the <strong>string</strong> and then use an <strong>input function</strong> to fetch the string.</p><h2 id="1-Creating-Space"><a href="#1-Creating-Space" class="headerlink" title="(1) Creating Space"></a>(1) Creating Space</h2><p>The first order of business is setting up a place to put the string after it is read. </p><h2 id="2-The-Unfortunate-gets-Function"><a href="#2-The-Unfortunate-gets-Function" class="headerlink" title="(2) The Unfortunate gets() Function"></a>(2) The Unfortunate gets() Function</h2><p> It reads an entire <strong>line up</strong> through the <strong>newline character</strong>, <strong>discards</strong> the <strong>newline character</strong>, stores the remaining characters, <strong>adding a null character</strong> to create a C <strong>string</strong>. </p><p>It’s often paired with <strong>puts()</strong>, which displays a <strong>string</strong>, <strong>adding a newline</strong>. </p><p>The problem is that <strong>gets()</strong> doesn’t check to see if the input line actually fits into the array. </p><h2 id="3-The-fgets-Function"><a href="#3-The-fgets-Function" class="headerlink" title="(3) The fgets() Function"></a>(3) The fgets() Function</h2><p>The <strong>fgets()</strong> function meets the possible <strong>overflow</strong> problem by taking a second argument that <strong>limits the number of characters</strong> to be read. </p><p>This function is designed for <strong>file input</strong>, which makes it a little more awkward to use. Here is how <strong>fgets()</strong> differs from <strong>gets()</strong>:</p><ul><li><p>It takes a <strong>second argument</strong> indicating the <strong>maximum number of characters to read</strong>. If this argument has the value <strong>n</strong>, <strong>fgets()</strong> reads up to <strong>n-1</strong> characters or through the <strong>newline character</strong>, whichever comes first.</p></li><li><p>If <strong>fgets()</strong> reads the <strong>newline</strong>, it <strong>stores it in the string</strong>, unlike <strong>gets()</strong>, which discards it.</p></li><li><p>It takes a <strong>third argument</strong> indicating <strong>which file to read</strong>. To read from the <strong>keyboard</strong>, use <strong>stdin</strong> (for standard input) as the argument; this identifier is defined in <code>stdio.h</code>.</p><h3 id="Null-and-NULL"><a href="#Null-and-NULL" class="headerlink" title="Null and NULL"></a>Null and NULL</h3><p>The <strong>null character</strong>, or <strong>‘\0’</strong>, is the character used to mark the end of a <strong>C string</strong>. It’s the character whose code is <strong>zero</strong>. Because that isn’t the code of any character, it won’t show up accidentally in some other part of the string.</p></li></ul><p>The <strong>null pointer</strong>, or <strong>NULL</strong>, <strong>has a value</strong> that doesn’t correspond to a <strong>valid address</strong> of data. It’s often used by functions that otherwise return valid addresses to indicate some special occurrence, such as encountering <strong>end-of-file</strong> or failing to perform as expected.</p><p>So the <strong>null character</strong> is an <strong>integer type</strong>, while the <strong>null pointer</strong> is a <strong>pointer type</strong>. </p><h2 id="4-The-s-gets-Function"><a href="#4-The-s-gets-Function" class="headerlink" title="(4) The s _ gets() Function"></a>(4) The s _ gets() Function</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* st, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> * ret_val;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    ret_val = fgets(st, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span> (ret_val) <span class="hljs-comment">// i.e., ret_val != NULL</span>    &#123;        <span class="hljs-keyword">while</span> (st[i] != <span class="hljs-string">'\n'</span> &amp;&amp; st[i] != <span class="hljs-string">'\0'</span>)            i++;        <span class="hljs-keyword">if</span> (st[i] == <span class="hljs-string">'\n'</span>)            st[i] = <span class="hljs-string">'\0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">// must have words[i] == '\0'</span>            <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">'\n'</span>)                <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret_val;&#125;</code></pre><h1 id="4-String-Output"><a href="#4-String-Output" class="headerlink" title="4. String Output"></a>4. String Output</h1><h2 id="1-The-puts-Function"><a href="#1-The-puts-Function" class="headerlink" title="(1) The puts() Function"></a>(1) The puts() Function</h2><p>The <strong>puts()</strong> function is very easy to use. Just give it the <strong>address of a string</strong> for an argument.</p><p><strong>puts()</strong> automatically <strong>appends a newline</strong> when it displays a string.</p><h2 id="2-The-fputs-Function"><a href="#2-The-fputs-Function" class="headerlink" title="(2) The fputs() Function"></a>(2) The fputs() Function</h2><p>The <strong>fputs()</strong> function is the <strong>file-oriented</strong> version of <strong>puts()</strong>. The main differences are these:</p><ul><li><p>The <strong>fputs()</strong> function takes a <strong>second argument</strong> indicating the <strong>file</strong> to which to <strong>write</strong>. You can use <strong>stdout</strong> (for standard output), which is defined in <code>stdio.h</code>, as an argument to output to your display.</p></li><li><p>Unlike <strong>puts()</strong>, <strong>fputs()</strong> does not automatically append a <strong>newline</strong> to the output.</p></li></ul><p>Note that <strong>gets()</strong> discards a <strong>newline</strong> on input, but <strong>puts()</strong> adds a <strong>newline</strong> on output. On the other hand, <strong>fgets()</strong> stores the <strong>newline</strong> on input, and <strong>fputs()</strong> doesn’t add a <strong>newline</strong> on output. </p><p><strong>gets()</strong> returns the <strong>null pointer</strong> if it encounters <strong>end-of-file</strong>. The <strong>null pointer *<em>evaluates as *</em>zero</strong>, or <strong>false</strong>, so that terminates the loop.</p><h1 id="5-String-Functions"><a href="#5-String-Functions" class="headerlink" title="5. String Functions"></a>5. String Functions</h1><h2 id="1-The-strlen-Function"><a href="#1-The-strlen-Function" class="headerlink" title="(1) The strlen() Function"></a>(1) The strlen() Function</h2><p>The <strong>strlen()</strong> function, finds the <strong>length</strong> of a string. </p><h2 id="2-The-strcat-Function"><a href="#2-The-strcat-Function" class="headerlink" title="(2) The strcat() Function"></a>(2) The strcat() Function</h2><p>The <strong>strcat()</strong> (for string concatenation) function takes <strong>two strings for arguments</strong>. A copy of the second string is tacked onto the end of the first, and this combined version becomes the new first string. </p><p>The second string is <strong>not altered</strong>. The <strong>strcat()</strong> function is type <code>char *</code> (that is, a pointer-to-char).</p><p>It <strong>returns</strong> the value of its <strong>first argument</strong>—the <strong>address</strong> of the first character of the string to which the second string is appended.</p><h2 id="3-The-strncat-Function"><a href="#3-The-strncat-Function" class="headerlink" title="(3) The strncat() Function"></a>(3) The strncat() Function</h2><p>Alternatively, you can use <strong>strncat()</strong>, which takes a second argument indicating the <strong>maximum number of characters</strong> to add. For example, <code>strncat(bugs, addon, 13)</code> will add the contents of the <code>addon</code> string to bugs, stopping when it reaches <code>13</code> additional characters or the <strong>null character</strong>, whichever comes first. </p><h2 id="4-The-strcmp-Function"><a href="#4-The-strcmp-Function" class="headerlink" title="(4) The strcmp() Function"></a>(4) The strcmp() Function</h2><p>These results suggest that <strong>strcmp()</strong> returns a <strong>negative number</strong> if the <strong>first string precedes the second</strong> alphabetically and that it <strong>returns a positive number</strong> if the order is the other way.  It returns <strong>0</strong> if they are the <strong>same</strong>.</p><p>The <strong>strcmp()</strong> function is for <strong>comparing strings</strong>, not <strong>characters</strong>.</p><h2 id="5-The-strncmp-Variation"><a href="#5-The-strncmp-Variation" class="headerlink" title="(5) The strncmp() Variation"></a>(5) The strncmp() Variation</h2><p>The <strong>strncmp()</strong> function compares the strings until they differ or until it has compared a number of characters specified by a third argument.</p><h2 id="6-The-sprintf-Function"><a href="#6-The-sprintf-Function" class="headerlink" title="(6) The sprintf() Function"></a>(6) The sprintf() Function</h2><p>The <strong>sprintf()</strong> function is declared in <code>stdio.h</code> instead of <code>string.h</code>. It works like <strong>printf()</strong>, but it <strong>writes</strong> to a string instead of writing to a display. </p><h2 id="7-Other-String-Functions"><a href="#7-Other-String-Functions" class="headerlink" title="(7) Other String Functions"></a>(7) Other String Functions</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2)</span></span>;</code></pre><p>This function <strong>copies *<em>the string (including the *</em>null character</strong>) pointed to by <code>s2</code> to the location pointed to by <code>s1</code>. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strncpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>This function <strong>copies</strong> to the location pointed to by <code>s1</code> no more than <code>n</code> characters from the string pointed to by <code>s2</code>. The return value is <code>s1</code>. No characters after a <strong>null character</strong> are copied and, if the source string is shorter than <code>n</code> characters, the <strong>target string</strong> is padded with <strong>null characters</strong>. If the source string has <code>n</code> or more characters, <strong>no null character is copied</strong>. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2)</span></span>;</code></pre><p>The string pointed to by <code>s2</code> is copied to the <strong>end of the string</strong> pointed to by <code>s1</code>. The first character of the <code>s2</code> string is copied <strong>over the null character</strong> of the <code>s1</code> string. The <strong>return value</strong> is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strncat</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>No more than the first <code>n</code> characters of the <code>s2</code> string are appended to the <code>s1</code> string, with the first character of the <code>s2</code> string being copied <strong>over the null character</strong> of the <code>s1</code> string. The <strong>null character</strong> and any characters following it in the <code>s2</code> string are <strong>not copied</strong>, and a <strong>null character</strong> is appended to the result. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>positive value</strong> if the <code>s1</code> string follows the <code>s2</code> string in the machine collating sequence, the value <strong>0</strong> if the two strings are <strong>identical</strong>, and a <strong>negative</strong> value if the <strong>first string</strong> precedes the <strong>second string</strong> in the machine collating sequence.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strncmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>This function works like <strong>strcmp()</strong>, except that the comparison stops after <code>n</code> characters or when the first <strong>null character</strong> is encountered, whichever comes first.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s, <span class="hljs-keyword">int</span> c)</span></span>;</code></pre><p>This function <strong>returns a pointer to the first location</strong> in the string <code>s</code> that holds the character <code>c</code>. (The terminating <strong>null character</strong> is part of the string, so it can be searched for.) The function returns the <strong>null pointer</strong> if the character is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strpbrk</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>pointer to the first location</strong> in the string <code>s1</code> that holds <strong>any character</strong> found in the <code>s2</code> string. The function returns the <strong>null pointer</strong> if no character is found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strrchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s, <span class="hljs-keyword">int</span> c)</span></span>;</code></pre><p>This function returns a <strong>pointer to the last occurrence of the character</strong> <code>c</code> in the strings. (The terminating <strong>null character</strong> is part of the string, so it can be searched for.) The function returns the <strong>null pointer</strong> if the character is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>pointer to the first occurrence</strong> of string <code>s2</code> in string <code>s1</code>. The function returns the <strong>null pointer</strong> if the string is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s)</span></span>;</code></pre><p>This function returns the <strong>number of characters</strong>, not including the terminating <strong>null character</strong>, found in the <strong>strings</strong>.</p><h1 id="6-Command-Line-Arguments"><a href="#6-Command-Line-Arguments" class="headerlink" title="6. Command-Line Arguments"></a>6. Command-Line Arguments</h1><p><img src="_v_images/20201201201425398_503175558.png" srcset="/img/loading.gif" alt=""><br>A C program reads these items by using arguments to <strong>main()</strong>.</p><pre><code class="hljs c"><span class="hljs-comment">/* 11.31 repeat.c -- main() with arguments */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> count;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"The command line has %d arguments:\n"</span>, argc - <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (count = <span class="hljs-number">1</span>; count &lt; argc; count++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: %s\n"</span>, count, argv[count]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs bash">$ repeat Resistance is futile</code></pre><p>repeat is the name of the program.</p><pre><code class="hljs vim"><span class="hljs-built_in">argv</span>[<span class="hljs-number">0</span>] points <span class="hljs-keyword">to</span> <span class="hljs-built_in">repeat</span> (<span class="hljs-keyword">for</span> most systems)<span class="hljs-built_in">argv</span>[<span class="hljs-number">1</span>] points <span class="hljs-keyword">to</span> Resistance<span class="hljs-built_in">argv</span>[<span class="hljs-number">2</span>] points <span class="hljs-keyword">to</span> <span class="hljs-keyword">is</span><span class="hljs-built_in">argv</span>[<span class="hljs-number">3</span>] points <span class="hljs-keyword">to</span> futile</code></pre><p>output:</p><pre><code class="hljs c">The command <span class="hljs-built_in">line</span> has <span class="hljs-number">3</span> arguments:<span class="hljs-number">1</span>: Resistance<span class="hljs-number">2</span>: is<span class="hljs-number">3</span>: futile</code></pre><p>C compilers allow <strong>main()</strong> to have <strong>no arguments</strong> or else to have <strong>two arguments</strong>. (Some implementations allow additional arguments, but that would be an extension of the standard.) </p><p>With two arguments, the <strong>first argument</strong> is the number of strings in the command line. </p><p>The system uses <strong>spaces</strong> to tell when one string ends and the next begins. Therefore, the repeat example has <strong>four strings</strong>, including the command <strong>name</strong>. </p><p>The program stores the command line strings in memory and stores the <strong>address of each string</strong> in an <strong>array of pointers</strong>. </p><p>The address of this array is stored in the <strong>second argument</strong>.</p><h1 id="7-String-to-Number-Conversions"><a href="#7-String-to-Number-Conversions" class="headerlink" title="7. String-to-Number Conversions"></a>7. String-to-Number Conversions</h1><h2 id="1-atoi"><a href="#1-atoi" class="headerlink" title="(1) atoi( )"></a>(1) atoi( )</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*str)</span></span>;</code></pre><p>It takes a <strong>string</strong> str as  an argument and returns the corresponding <strong>integer value</strong>.  The <code>stdlib.h</code> header contains the function declaration<br>for <strong>atoi()</strong>.</p><p>该函数会扫描字符串，跳过空白字符，直到遇到数字或者正负符号才开始转换，一直到遇到非数字或者字符串结束符 <strong>‘\0’</strong> 结束扫描，如果一开始扫描到是非数字，则结束扫描，未扫描到数字返回数字 <strong>0</strong>，否则返回转换后的数字，能识别<strong>正负号</strong>。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> i,j;  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)  &#123;    j = atoi(argv[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %-10scorresponding integer: %d\n"</span>,argv[i], j);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>output:</p><pre><code class="hljs c">./atoi1.o jds323sd <span class="hljs-number">898</span>dsj23 js<span class="hljs-number">-98</span>dk +<span class="hljs-number">23</span>sd33 <span class="hljs-number">-92</span>d89s i<span class="hljs-number">-988</span>sj<span class="hljs-built_in">string</span>: jds323sd  corresponding integer: <span class="hljs-number">0</span><span class="hljs-built_in">string</span>: <span class="hljs-number">898</span>dsj23  corresponding integer: <span class="hljs-number">898</span><span class="hljs-built_in">string</span>: js<span class="hljs-number">-98</span>dk   corresponding integer: <span class="hljs-number">0</span><span class="hljs-built_in">string</span>: +<span class="hljs-number">23</span>sd33   corresponding integer: <span class="hljs-number">23</span><span class="hljs-built_in">string</span>: <span class="hljs-number">-92</span>d89s   corresponding integer: <span class="hljs-number">-92</span><span class="hljs-built_in">string</span>: i<span class="hljs-number">-988</span>sj   corresponding integer: <span class="hljs-number">0</span></code></pre><p>Implementation of <strong>atoi()</strong>:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *st)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sign, ret;    ret = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(*st))        st++;    sign = (*st == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(*st == <span class="hljs-string">'+'</span> || *st == <span class="hljs-string">'-'</span>)        st++;    <span class="hljs-keyword">for</span>( ; *st; st++)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*st))            ret = *st - <span class="hljs-string">'0'</span> + ret * <span class="hljs-number">10</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">return</span> sign * ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)    &#123;        n = atoi(argv[i]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %10sint: %d;\n"</span>, argv[i], n);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>output:</p><pre><code class="hljs c">./atoi.o sdj87<span class="hljs-number">-08</span> <span class="hljs-number">98</span>sjd09 <span class="hljs-number">-98</span>sd88 <span class="hljs-number">-09</span>sdj88<span class="hljs-built_in">string</span>:   sdj87<span class="hljs-number">-08</span><span class="hljs-keyword">int</span>: <span class="hljs-number">0</span>;<span class="hljs-built_in">string</span>:    <span class="hljs-number">98</span>sjd09<span class="hljs-keyword">int</span>: <span class="hljs-number">98</span>;<span class="hljs-built_in">string</span>:    <span class="hljs-number">-98</span>sd88<span class="hljs-keyword">int</span>: <span class="hljs-number">-98</span>;<span class="hljs-built_in">string</span>:   <span class="hljs-number">-09</span>sdj88<span class="hljs-keyword">int</span>: <span class="hljs-number">-9</span>;```                                                                                                                                                                                ## (<span class="hljs-number">2</span>) atof() ```c<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">atof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;</code></pre><p>该函数将参数 <strong>str</strong> 所指向的字符串转换为一个<strong>double</strong> 型浮点数。</p><p>浮点数合法表示:</p><pre><code class="hljs angelscript"><span class="hljs-number">3.123</span><span class="hljs-number">.2</span><span class="hljs-number">-.32</span><span class="hljs-number">2e-2</span><span class="hljs-number">2.E-2</span><span class="hljs-number">.3e-2</span></code></pre><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *ret, *<span class="hljs-built_in">find</span>;    ret = fgets(s, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span>(ret)    &#123;        <span class="hljs-built_in">find</span> = <span class="hljs-built_in">strchr</span>(s, <span class="hljs-string">'\n'</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>)        &#123;            *<span class="hljs-built_in">find</span> = <span class="hljs-string">'\0'</span>;        &#125;        <span class="hljs-keyword">else</span>        <span class="hljs-keyword">while</span>(getchar() != <span class="hljs-string">'\n'</span>)            <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> n;    <span class="hljs-keyword">char</span> s[<span class="hljs-number">10</span>];    <span class="hljs-keyword">while</span>(s_gets(s, <span class="hljs-number">10</span>) &amp;&amp; s[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span>)    &#123;        n = atof(s);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %s, float: %f\n"</span>, s, n); <span class="hljs-comment">//printf()输出双精度也是%f,输出形式为小数点形式</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Answer:</p><pre><code class="hljs c"><span class="hljs-number">.023e-3</span><span class="hljs-number">.2</span>sj<span class="hljs-built_in">string</span>: <span class="hljs-number">.023e-3</span><span class="hljs-number">.2</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000023</span><span class="hljs-number">-.32</span><span class="hljs-number">.3e2</span><span class="hljs-built_in">string</span>: <span class="hljs-number">-.32</span><span class="hljs-number">.3e2</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">-0.320000</span>sj3<span class="hljs-built_in">string</span>: sj3, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span>.e3<span class="hljs-built_in">string</span>: .e3, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span><span class="hljs-number">0.e3</span><span class="hljs-built_in">string</span>: <span class="hljs-number">0.e3</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span><span class="hljs-number">2.e-3</span><span class="hljs-number">.32</span><span class="hljs-built_in">string</span>: <span class="hljs-number">2.e-3</span><span class="hljs-number">.32</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.002000</span><span class="hljs-number">.22e-3</span><span class="hljs-built_in">string</span>: <span class="hljs-number">.22e-3</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000220</span></code></pre><p>Implementation of <strong>atof()</strong>:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEN 10</span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myatof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> s[LEN];    <span class="hljs-keyword">double</span> num;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter strings, enter a newline to quit:"</span>);    <span class="hljs-keyword">while</span>(s_gets(s,LEN) &amp;&amp; s[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span>)    &#123;        num = myatof(s);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %s, corresponding number: %f;\n"</span>, s,num);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *ret, *<span class="hljs-built_in">find</span>;    ret = fgets(s, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span>(ret)    &#123;        <span class="hljs-built_in">find</span> = <span class="hljs-built_in">strchr</span>(s,<span class="hljs-string">'\n'</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>)            *<span class="hljs-built_in">find</span> = <span class="hljs-string">'\0'</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">while</span>(getchar() != <span class="hljs-string">'\n'</span>)                <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myatof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sign, sign_e;    <span class="hljs-keyword">int</span> hasdot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> hasE = <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span> intpart = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">double</span> decpart = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">int</span> decdigit = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span> ret;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(*str))<span class="hljs-comment">//跳过开始的空格</span>        str++;      <span class="hljs-comment">//判断符号</span>    sign = (*str == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;    <span class="hljs-comment">//跳过符号位</span>    <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'-'</span> || *str == <span class="hljs-string">'+'</span>)        str++;    <span class="hljs-keyword">for</span>(;*str;str++)     &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*str)) <span class="hljs-comment">//计算整数部分</span>            intpart = <span class="hljs-number">10</span> * intpart + *str - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'.'</span>) <span class="hljs-comment">//小数点</span>        &#123;          hasdot = <span class="hljs-number">1</span>;          str++;          <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'e'</span> || *str == <span class="hljs-string">'E'</span>)<span class="hljs-comment">//科学计数法</span>        &#123;            hasE = <span class="hljs-number">1</span>;            str++;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//不合要求字符，退出</span>            <span class="hljs-keyword">return</span> sign * intpart;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">425 退出上面函数有一下情况：</span><span class="hljs-comment">426  1. 数字加非法字符：2s 直接计算结果后退出</span><span class="hljs-comment">427  2. 数字加小数点：2.</span><span class="hljs-comment">428  3. 数字加e或E：2e</span><span class="hljs-comment">429  4. e或E：e</span><span class="hljs-comment">430  5. 小数点：.</span><span class="hljs-comment">431  6. 非法字符：s 直接退出</span><span class="hljs-comment">432 */</span>        <span class="hljs-keyword">for</span>( ; *str; str++)    &#123;        <span class="hljs-keyword">if</span>(hasdot &amp;&amp; <span class="hljs-built_in">isdigit</span>(*str)) <span class="hljs-comment">//两种表达：2.3 .3; </span>        <span class="hljs-comment">//2.34小数部分计算：3 / 10  + 4 / (10 *10)</span>        <span class="hljs-comment">//pow() 函数位于math.h头文件中，计算幂，pow(10,2) == 10 * 10，但编译时要加lm</span>            decpart += (*str - <span class="hljs-string">'0'</span>) / <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span> , decdigit++);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasdot &amp;&amp; (*str == <span class="hljs-string">'e'</span> || *str ==<span class="hljs-string">'E'</span>))        <span class="hljs-comment">//情况：2.3e，.3e，.e;最后一种 .e 不合法，但最终计算结果还是为0</span>        &#123;            hasE = <span class="hljs-number">1</span>;            str++;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hasE) <span class="hljs-comment">//用科学计数法，但是前面没有小数点，情况：3e3 e3 3e- 3e+ 3e. 3ek </span>            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//遇到不合要求字符 3k 3.k 3.3k .k; 不存在有科学计数法 e 或 E情况 </span>            <span class="hljs-keyword">return</span> sign * (intpart + decpart);    &#125;    <span class="hljs-comment">//退出有一下情况：</span>    <span class="hljs-comment">// 1. 扫描数字直到结束 1.23</span>    <span class="hljs-comment">// 2. 科学计数法，前面数字部分有小数点 或者没有</span>    <span class="hljs-comment">// 3. 扫描不合法字符退出函数</span>    sign_e = (*str == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>; <span class="hljs-comment">//指数部分符号</span>    <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'+'</span> || *str == <span class="hljs-string">'-'</span>)        str++;    <span class="hljs-keyword">for</span>( ; *str; str++)<span class="hljs-comment">//识别指数部分</span>    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*str))            <span class="hljs-built_in">exp</span> = <span class="hljs-built_in">exp</span> * <span class="hljs-number">10</span> + *str - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//非法字符</span>            <span class="hljs-keyword">break</span>;    &#125;    ret = sign * ( (intpart + decpart) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span> , sign_e * <span class="hljs-built_in">exp</span>) );    <span class="hljs-keyword">return</span> ret;&#125;</code></pre><h2 id="3-atol"><a href="#3-atol" class="headerlink" title="(3)  atol()"></a>(3)  atol()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">atol</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;</code></pre><p>该函数将参数 <strong>str</strong> 所指向的字符串转换为<strong>long int</strong>。</p><h2 id="4-strtol"><a href="#4-strtol" class="headerlink" title="(4) strtol()"></a>(4) strtol()</h2><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strtol</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr, <span class="hljs-keyword">int</span> <span class="hljs-keyword">base</span></span>)</span>;</code></pre><p><strong>string to long int</strong>，该函数把参数 <strong>str</strong> 所指向的字符串根据给定的 <strong>base</strong> 转换为<strong>long int</strong>，<strong>base</strong> 必须介于 <strong>2</strong> 和 <strong>36</strong>（包含）之间，或者是特殊值 <strong>0</strong>。<br>&nbsp;<br>参数说明:<br><strong>str</strong>: 要转换的字符串，起始扫描时会跳过开头的空白字符，直到遇到数字或者正负符号开始做转换，知道遇到不合条件字符或者字符串结束字符才结束。<br>&nbsp;<br><strong>endptr</strong>: 指向指针的指针，<strong>*endptr</strong> 为指向第一个非法字符。<br>&nbsp;<br><strong>base</strong>: 基数。代表将 <strong>str</strong> 进行转换采用的进制。范围为 <strong>2~36</strong>，或者 <strong>0</strong>；<br>如 <strong>base</strong> 是 <strong>0</strong>，默认采用 <strong>10</strong> 进制，但如果遇到 <strong>‘0x’</strong> 或者 <strong>‘0X’</strong> 前置的字符，采用 <strong>16</strong> 进制，遇到 <strong>‘0’</strong> 前置非第一种情况，则用 <strong>8</strong> 进制。<br>&nbsp;<br><strong>返回值</strong>: 函数返回转换后的长整型数字，若无有效数字，返回 <strong>0</strong>。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> *end1, *end2;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> n1, n2;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)    &#123;         n1 = strtol(argv[i], &amp;end1, <span class="hljs-number">10</span>);        n2 = strtol(argv[i], &amp;end2, <span class="hljs-number">16</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string%d: %15s, base 10 input, base 10 output: %ld, stopped at %s"</span>        <span class="hljs-string">" (%d);\n"</span>,i, argv[i], n1, end1, *end1);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string%d: %15s, base 16 input, base 10 output: %ld, stopped at %s"</span>         <span class="hljs-string">" (%d);\n"</span>,i, argv[i], n2, end2, *end2);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="5-strtod"><a href="#5-strtod" class="headerlink" title="(5) strtod()"></a>(5) strtod()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">strtod</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr)</span></span>;</code></pre><p><strong>string to double</strong>，将参数 <strong>str</strong> 所指向的字符串转换为<strong>double</strong>型浮点数。</p><p>该函数返回转换后的<strong>double</strong>浮点数，如果没有执行有效的转换，则返回零（<strong>0.0</strong>）。</p><h2 id="6-strtoul"><a href="#6-strtoul" class="headerlink" title="(6) strtoul()"></a>(6) strtoul()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strtoul</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr, <span class="hljs-keyword">int</span> base)</span></span>;</code></pre><p><strong>string to unsigned long int</strong>，参数<strong>str</strong>所指向的字符串根据给定的<strong>base</strong>转换为<strong>unsigned long int</strong>型，<strong>base</strong>必须介于 <strong>2</strong> 和 <strong>36</strong>（包含）之间，或者是特殊值<strong>0</strong>。</p><p>该函数返回转换后的<strong>unsigned long int</strong>长整数，如果没有执行有效的转换，则返回 <strong>0</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arrays and Pointers</title>
    <link href="/2020/11/30/Arrays-and-Pointers/"/>
    <url>/2020/11/30/Arrays-and-Pointers/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 10 Arrays and Pointers</p><a id="more"></a><h1 id="1-Arrays"><a href="#1-Arrays" class="headerlink" title="1. Arrays"></a>1. Arrays</h1><p>An array is composed of a series of elements of <strong>one data type</strong>.</p><h2 id="1-Initialization"><a href="#1-Initialization" class="headerlink" title="(1) Initialization"></a>(1) Initialization</h2><pre><code class="hljs c"><span class="hljs-keyword">int</span> powers[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>&#125;; <span class="hljs-comment">/* ANSI C and later */</span></code></pre><p>As you can see, you initialize an array by using a <strong>comma-separated</strong> list of values enclosed in braces. You can use spaces between the values and the commas, if you want.</p><p>Sometimes you might use an array that’s intended to be a <strong>read-only</strong> array. In such cases, you can, and should, use the <strong>const</strong> keyword when you declare and initialize the array.</p><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;</code></pre><p><strong>C99</strong> added a new capability: <strong>designated initializers</strong>. This feature allows you to pick and choose which elements are initialized.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>, [<span class="hljs-number">4</span>] = <span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>, [<span class="hljs-number">1</span>] = <span class="hljs-number">29</span>&#125;;</code></pre><p><strong>First</strong>, if the code follows a designated initializer with further values, as in the sequence [4] = 31,30,31, these further values are used to initialize the subsequent elements. That is, after initializing <code>days[4]</code> to <code>31</code>, the code initializes <code>days[5]</code> and <code>days[6]</code> to <code>30</code> and <code>31</code>, respectively. </p><p><strong>Second</strong>, if the code initializes a particular element to a value <strong>more than once</strong>, the <strong>last initialization</strong> is the one that takes effect.</p><h2 id="2-Assigning-Array-Values"><a href="#2-Assigning-Array-Values" class="headerlink" title="(2) Assigning Array Values"></a>(2) Assigning Array Values</h2><p><strong>C doesn’t let you assign one array to another as a unit. Nor can you use the list-in-braces form except when initializing.</strong></p><pre><code class="hljs c"><span class="hljs-keyword">int</span> oxen[SIZE] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>&#125;; <span class="hljs-comment">/* ok here */</span><span class="hljs-keyword">int</span> yaks[SIZE];yaks = oxen; <span class="hljs-comment">/* not allowed */</span>yaks[SIZE] = oxen[SIZE]; <span class="hljs-comment">/* out of range */</span> oxen[SIZE<span class="hljs-number">-1</span>] is the last element of <span class="hljs-built_in">array</span> oxenyaks[SIZE] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>&#125;; <span class="hljs-comment">/* doesn't work */</span></code></pre><p><strong>Why can’t assign one array to another as a unit</strong><br>From <code>The C Programming Language</code></p><blockquote><p>There is one difference between an <strong>array name</strong> and a <strong>pointer</strong> that must be kept in mind. A <strong>pointer</strong> is a variable. But an <strong>array name</strong> is not a variable;</p></blockquote><blockquote><p>The <strong>array name</strong> is the <strong>address</strong> of the zeroth element.</p></blockquote><p>理解：<br>数组名为第一个元素的地址，是常量，不能被赋值。</p><h2 id="3-Array-Bounds"><a href="#3-Array-Bounds" class="headerlink" title="(3) Array Bounds"></a>(3) Array Bounds</h2><p>The compiler doesn’t check to see <strong>whether the indices are valid</strong>. The result of using a bad index is, in the language of the C standard, undefined. That means when you run the program, it might seem to work, it might work oddly, or it might abort.</p><h2 id="4-Multidimensional-Arrays"><a href="#4-Multidimensional-Arrays" class="headerlink" title="(4) Multidimensional Arrays"></a>(4) Multidimensional Arrays</h2><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> rain[YEARS][MONTHS] =&#123;&#123;<span class="hljs-number">4.3</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">2.4</span>,<span class="hljs-number">3.5</span>,<span class="hljs-number">6.6</span>&#125;,&#123;<span class="hljs-number">8.5</span>,<span class="hljs-number">8.2</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">1.6</span>,<span class="hljs-number">2.4</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">5.2</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">1.4</span>,<span class="hljs-number">7.3</span>&#125;,&#123;<span class="hljs-number">9.1</span>,<span class="hljs-number">8.5</span>,<span class="hljs-number">6.7</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">2.1</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">1.1</span>,<span class="hljs-number">2.3</span>,<span class="hljs-number">6.1</span>,<span class="hljs-number">8.4</span>&#125;,&#123;<span class="hljs-number">7.2</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">8.4</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">1.7</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">6.2</span>&#125;,&#123;<span class="hljs-number">7.6</span>,<span class="hljs-number">5.6</span>,<span class="hljs-number">3.8</span>,<span class="hljs-number">2.8</span>,<span class="hljs-number">3.8</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.3</span>,<span class="hljs-number">2.6</span>,<span class="hljs-number">5.2</span>&#125;&#125;;</code></pre><h1 id="2-Pointers-and-Arrays"><a href="#2-Pointers-and-Arrays" class="headerlink" title="2. Pointers and Arrays"></a>2. Pointers and Arrays</h1><p>An <strong>array name</strong> is also the address of the first element of the array. </p><p>That is, if <code>flizny</code> is an <strong>array</strong>, the following is true:</p><pre><code class="hljs c">flizny == &amp;flizny[<span class="hljs-number">0</span>]; <span class="hljs-comment">// name of array is the address of the first element</span></code></pre><p>Both are <strong>constants</strong> because they <strong>remain fixed</strong> for the duration of the program. </p><pre><code class="hljs c">dates + <span class="hljs-number">2</span> == &amp;date[<span class="hljs-number">2</span>] <span class="hljs-comment">// same address</span>*(dates + <span class="hljs-number">2</span>) == dates[<span class="hljs-number">2</span>] <span class="hljs-comment">// same value</span></code></pre><pre><code class="hljs c"><span class="hljs-comment">/* day_mon3.c -- uses pointer notation */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MONTHS 12</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<span class="hljs-keyword">int</span> index;<span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; MONTHS; index++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Month %2d has %d days.\n"</span>, index +<span class="hljs-number">1</span>,*(days + index)); <span class="hljs-comment">// same as days[index]</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Here, <code>days</code> is the address of the first element of the array, <code>days + index</code> is the address of element <code>days[index]</code>, and <code>*(days + index)</code> is the value of that element, just as <code>days[index]</code> is. </p><h1 id="3-Functions-Arrays-and-Pointers"><a href="#3-Functions-Arrays-and-Pointers" class="headerlink" title="3. Functions, Arrays, and Pointers"></a>3. Functions, Arrays, and Pointers</h1><pre><code class="hljs c"><span class="hljs-keyword">int</span>* ar:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;</code></pre><p>The form <code>int* ar</code> always means that ar is type <strong>pointer-to-int</strong>. The form <code>int ar[]</code> also means that <code>ar</code> is type <strong>pointer-to-int</strong>, but only when used to declare <strong>formal parameters</strong>. </p><p>The idea is that the second form reminds the reader that not only does <code>ar</code> point to an int, it points to an int that’s an element of an array.</p><p>In this context, and only in this context, C interprets <code>int ar[]</code> to mean the same as <code>int* ar</code>; that is, <code>ar</code> is type <strong>pointer-to-int</strong>.</p><p>Because <strong>prototypes</strong> allow you to omit a name, all four of the following prototypes are equivalent:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *, <span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [], <span class="hljs-keyword">int</span>)</span></span>;</code></pre><p>You <strong>can’t omit names</strong> in function definitions, so, for definitions, the following two forms are equivalent:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// code goes here</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;&#123;<span class="hljs-comment">// code goes here</span>&#125;</code></pre><p><strong>Dereferencing an Uninitialized Pointer:</strong> Do not dereference an uninitialized pointer. For example, consider the following:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt; <span class="hljs-comment">// an uninitialized pointer</span>*pt = <span class="hljs-number">5</span>; <span class="hljs-comment">// a terrible error</span></code></pre><p>The second line means store the value <code>5</code> in the location to which <code>pt</code> points. But <code>pt</code>, being <strong>uninitialized</strong>, has a random value, so there is no knowing where the <code>5</code> will be placed. It might go somewhere harmless, it might overwrite data or code, or it might cause the program to crash. </p><h1 id="4-Using-Pointer-Parameters"><a href="#4-Using-Pointer-Parameters" class="headerlink" title="4. Using Pointer Parameters"></a>4. Using Pointer Parameters</h1><p>A function working on an array needs to know where to start and stop. </p><p>The two expressions <code>ar[i]</code> and <code>*(ar+i)</code> are equivalent in meaning. Both work if ar is the name of an <strong>array</strong>, and both work if ar is a <strong>pointer</strong> variable.<br>However, using an expression such as <code>ar++</code> only works if <code>ar</code> is a <strong>pointer</strong> variable.</p><p>You must use <strong>pointers</strong> if you want a function to affect variables in the calling function. The second use is in functions designed to manipulate arrays.</p><h1 id="5-Protecting-Array-Contents"><a href="#5-Protecting-Array-Contents" class="headerlink" title="5. Protecting Array Contents"></a>5. Protecting Array Contents</h1><p>The usual rule is to pass quantities by value unless the program needs to alter the value, in which case you pass a pointer. </p><p>Arrays don’t give you that choice; you must pass a pointer. The reason is efficiency. </p><p>If a function passed an array by value, it would have to allocate enough space to hold a copy of the original array and then copy all the data from the original array to the new array. </p><p>It is much quicker to pass the address of the array and have the function work with the original data.</p><h1 id="6-Using-const-with-Formal-Parameters"><a href="#6-Using-const-with-Formal-Parameters" class="headerlink" title="6. Using const with Formal Parameters"></a>6. Using const with Formal Parameters</h1><p>If a function’s intent is that it not change the contents of the array, use the keyword <strong>const</strong> when declaring the formal parameter in the prototype and in the <strong>function definition</strong>. </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>; <span class="hljs-comment">/* prototype */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">/* definition */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; n; i++)        total += ar[i];    <span class="hljs-keyword">return</span> total;&#125;</code></pre><p>It’s important to understand that using <strong>const</strong> this way <strong>does not require that the original array be constant</strong>; it just says that the function has to treat the array as though it were constant. </p><p>It prevents a function from modifying data in the calling function. </p><p><strong>There are some rules you should know about pointer assignments and const.</strong></p><p><strong>First</strong>, it’s valid to <strong>assign</strong> the <strong>address</strong> of either <strong>constant data</strong> or <strong>non-constant</strong> data to a <strong>pointer-to-constant</strong>:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> locked[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0.08</span>, <span class="hljs-number">0.075</span>, <span class="hljs-number">0.0725</span>, <span class="hljs-number">0.07</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *pc = rates; <span class="hljs-comment">// valid</span>pc = locked; <span class="hljs-comment">// valid</span>pc = &amp;rates[<span class="hljs-number">3</span>]; <span class="hljs-comment">// valid</span></code></pre><p><strong>However</strong>, only the addresses of <strong>non-constant data</strong> can be assigned to <strong>regular pointers</strong>:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> locked[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0.08</span>, <span class="hljs-number">0.075</span>, <span class="hljs-number">0.0725</span>, <span class="hljs-number">0.07</span>&#125;;<span class="hljs-keyword">double</span> *pnc = rates; <span class="hljs-comment">// valid</span>pnc = locked; <span class="hljs-comment">// not valid</span>pnc = &amp;rates[<span class="hljs-number">3</span>]; <span class="hljs-comment">// valid</span></code></pre><p>This is a reasonable rule. Otherwise, you could use the pointer to change data that was supposed to be constant.</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">double</span>* <span class="hljs-keyword">const</span> pc = rates; <span class="hljs-comment">// pc points to beginning of the array</span>pc = &amp;rates[<span class="hljs-number">2</span>]; <span class="hljs-comment">// not allowed to point elsewhere</span>*pc = <span class="hljs-number">92.99</span>; <span class="hljs-comment">// ok -- changes rates[0]</span></code></pre><h1 id="7-Pointers-and-Multidimensional-Arrays"><a href="#7-Pointers-and-Multidimensional-Arrays" class="headerlink" title="7. Pointers and Multidimensional Arrays"></a>7. Pointers and Multidimensional Arrays</h1><p><img src="https://img-blog.csdnimg.cn/20190604210825828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1-Pointers-to-Multidimensional-Arrays"><a href="#1-Pointers-to-Multidimensional-Arrays" class="headerlink" title="(1) Pointers to Multidimensional Arrays"></a>(1) Pointers to Multidimensional Arrays</h2><pre><code class="hljs c"><span class="hljs-keyword">int</span> (*pz)[<span class="hljs-number">2</span>]; <span class="hljs-comment">// pz points to an array of 2 ints</span></code></pre><p>This statement says that <code>pz</code> is a pointer to an array of two ints. </p><p><code>[ ]</code> has a higher precedence than <code>*</code>. Therefore, with a declaration such as:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span>* pax[<span class="hljs-number">2</span>]; <span class="hljs-comment">// pax is an array of two pointers-to-int</span></code></pre><p>You can use notation such as <code>pz[2][1]</code>, even though <code>pz</code> is a <strong>pointer</strong>, not an <strong>array</strong> name. </p><p>More generally, you can represent individual elements by using <strong>array notation</strong> or <strong>pointer notation</strong> with either an <strong>array</strong> name or a <strong>pointer</strong>:</p><pre><code class="hljs c">zippo[m][n] == *(*(zippo + m) + n)pz[m][n] == *(*(pz + m) + n)</code></pre><h2 id="2-Pointer-Compatibility"><a href="#2-Pointer-Compatibility" class="headerlink" title="(2) Pointer Compatibility"></a>(2) Pointer Compatibility</h2><p>The rules for assigning one <strong>pointer</strong> to another are tighter than the rules for <strong>numeric types</strong>. </p><p>For example, you can assign an <strong>int</strong> value to a <strong>double</strong> variable without using a <strong>type conversion</strong>, but you can’t do the same for <strong>pointers</strong> to these two types:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;<span class="hljs-keyword">double</span> x;<span class="hljs-keyword">int</span> * p1 = &amp;n;<span class="hljs-keyword">double</span>* pd = &amp;x;x = n; <span class="hljs-comment">// implicit type conversion</span>pd = p1; <span class="hljs-comment">// compile-time error</span></code></pre><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt;<span class="hljs-keyword">int</span> (*pa)[<span class="hljs-number">3</span>];<span class="hljs-keyword">int</span> ar1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<span class="hljs-keyword">int</span> ar2[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> **p2; <span class="hljs-comment">// a pointer to a pointer</span>Then we have the following:pt = &amp;ar1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>pt = ar1[<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>pt = ar1; <span class="hljs-comment">// not valid</span>pa = ar1; <span class="hljs-comment">// both pointer-to-int[3]</span>pa = ar2; <span class="hljs-comment">// not valid</span>p2 = &amp;pt; <span class="hljs-comment">// both pointer-to-int *</span>*p2 = ar2[<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>p2 = ar2; <span class="hljs-comment">// not valid</span></code></pre><h2 id="3-Functions-and-Multidimensional-Arrays"><a href="#3-Functions-and-Multidimensional-Arrays" class="headerlink" title="(3) Functions and Multidimensional Arrays"></a>(3) Functions and Multidimensional Arrays</h2><p>You can declare a function parameter of this type like this:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">somefunction</span><span class="hljs-params">( <span class="hljs-keyword">int</span> (*pt)[<span class="hljs-number">4</span>])</span></span>; <span class="hljs-comment">// pt is a pointer to an array of four ints.</span></code></pre><p>Alternatively, if (and only if) <code>pt</code> is a <strong>formal parameter</strong> to a function, you can declare it as follows:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">somefunction</span><span class="hljs-params">( <span class="hljs-keyword">int</span> pt[][<span class="hljs-number">4</span>] )</span></span>;</code></pre><p><strong>Note that the first set of brackets is empty. The empty brackets identify pt as being a pointer.</strong></p><p>Recall that the compiler converts <strong>array</strong> notation to <strong>pointer</strong> notation. This means, for example, that <code>ar[1]</code> will become <code>ar+1</code>. For the compiler to evaluate this, it needs to know the size object to which ar points. </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[][<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// valid declaration</span></code></pre><p>says that <code>ar</code> points to an array of four ints.</p><p>You can also include a size in the other bracket pair, as shown here, but the compiler ignores it: </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// valid declaration, 3 ignored</span></code></pre><p>In general, to declare a <strong>pointer</strong> corresponding to an <strong>N-dimensional array</strong>, <strong>you must supply values for all but the leftmost set of brackets</strong>:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum4d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[][<span class="hljs-number">12</span>][<span class="hljs-number">20</span>][<span class="hljs-number">30</span>], <span class="hljs-keyword">int</span> rows)</span></span>;</code></pre><p>That’s because the <strong>first set of brackets</strong> indicates a <strong>pointer</strong>, whereas the rest of the brackets describe the type of data object <strong>being pointed to</strong>, as the following equivalent prototype illustrates:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum4d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*ar)[<span class="hljs-number">12</span>][<span class="hljs-number">20</span>][<span class="hljs-number">30</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// ar a pointer</span></code></pre><p>Here, ar points to a <code>12×20×30</code> array of ints.</p><h2 id="4-Variable-Length-Arrays-VLAs"><a href="#4-Variable-Length-Arrays-VLAs" class="headerlink" title="(4) Variable-Length Arrays (VLAs)"></a>(4) Variable-Length Arrays (VLAs)</h2><p><strong>VLAs Do Not Change Size</strong>:<br>The term <strong>variable in variable-length array</strong> does not mean that you can modify the length of the array after you create it. Once created, a <strong>VLA</strong> keeps the <strong>same size</strong>. What the term variable does mean is that you can use a variable when specifying the array dimensions when <strong>first creating the array</strong>.</p><p>First, here’s how to declare a function with a <strong>two-dimensional VLA</strong> argument:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">int</span> ar[rows][cols])</span></span>; <span class="hljs-comment">// ar a VLA</span></code></pre><p>One point to note is that a <strong>VLA</strong> declaration in a function definition parameter list doesn’t actually create an array. Just as with the old syntax, the <strong>VLA</strong> name really is a <strong>pointer</strong>. This means a function with a <strong>VLA</strong> parameter actually works with the data in the <strong>original array</strong>, and therefore has the ability to <strong>modify the array</strong> passed as an argument. </p><pre><code class="hljs c"><span class="hljs-keyword">int</span> thing[<span class="hljs-number">10</span>][<span class="hljs-number">6</span>];twoset(<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,thing);...<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">twoset</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> ar[n][m])</span> <span class="hljs-comment">// ar a pointer to</span></span><span class="hljs-function"><span class="hljs-comment">// an array of m ints</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp[n][m]; <span class="hljs-comment">// temp an n x m array of int</span>    temp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// set an element of temp to 2</span>    ar[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// set thing[0][0] to 2</span>&#125;</code></pre><p>When <code>twoset()</code> is called as shown, <code>ar</code> becomes a pointer to <code>thing[0]</code>, and <code>temp</code> is created as a <code>10×6</code>array. Because both <code>ar</code> and <code>thing</code> are pointers to <code>thing[0]</code>, <code>ar[0][0]</code> accesses the same data location as <code>thing[0][0]</code>.</p><p><strong>Variable-length</strong> arrays also allow for <strong>dynamic memory allocation</strong>. This means you can specify the size of the array while the program is running. </p><h1 id="8-Compound-Literals"><a href="#8-Compound-Literals" class="headerlink" title="8. Compound Literals"></a>8. Compound Literals</h1><p>Suppose you want to pass a value to a function with an <strong>int</strong> parameter; you can pass an <strong>int</strong> variable, but you also can pass an <strong>int constant</strong>, such as <strong>5</strong>. Before <strong>C99</strong>, the situation for a function with an <strong>array argument</strong> was different; you could pass an <strong>array</strong>, but there was no equivalent to an <strong>array constant</strong>. <strong>C99</strong> changed that with the addition of compound literals. </p><p><strong>Literals</strong> are <strong>constants</strong> that aren’t symbolic. For example, <strong>5</strong> is a type <strong>int literal</strong>, <strong>81.3</strong> is a <strong>type double literal</strong>, <strong>‘Y’</strong> is a type <strong>char literal</strong>, and <strong>“elephant”</strong> is a <strong>string literal</strong>. </p><p>For <strong>arrays</strong>, a <strong>compound literal</strong> looks like an <strong>array initialization list</strong> preceded by a type name that is enclosed in parentheses. For example, here’s an ordinary array declaration:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> diva[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;</code></pre><p>And here’s a compound literal that creates a nameless array containing the same two int values:</p><pre><code class="hljs c">(<span class="hljs-keyword">int</span> [<span class="hljs-number">2</span>])&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125; <span class="hljs-comment">// a compound literal</span></code></pre><p>Because these <strong>compound literals</strong> are nameless, you can’t just create them in one statement and then use them later. Instead, you have to use them somehow when you make them.<br>One way is to use a *<em>pointer *</em>to keep track of the location. That is, you can do something like this:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt1;pt1 = (<span class="hljs-keyword">int</span> [<span class="hljs-number">2</span>]) &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;</code></pre><p>Another thing you could do with a <strong>compound literal</strong> is pass it as an actual argument to a function with a matching formal parameter:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;...<span class="hljs-keyword">int</span> total3;total3 = sum((<span class="hljs-keyword">int</span> [])&#123;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>&#125;, <span class="hljs-number">6</span>);</code></pre><p>Keep in mind that a <strong>compound literal</strong> is a means for providing values that are needed only <strong>temporarily</strong>. It has block scope. That means its existence is not guaranteed once program execution leaves the block in which the compound literal is defined, that is, the innermost pair of braces containing the definition.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Functions</title>
    <link href="/2020/11/30/Functions/"/>
    <url>/2020/11/30/Functions/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 9 Functions</p><a id="more"></a><h1 id="1-Function-Arguments"><a href="#1-Function-Arguments" class="headerlink" title="1. Function Arguments"></a>1. Function Arguments</h1><h2 id="1-Defining-a-Function-with-an-Argument-Formal-Parameters"><a href="#1-Defining-a-Function-with-an-Argument-Formal-Parameters" class="headerlink" title="(1) Defining a Function with an Argument: Formal Parameters"></a>(1) Defining a Function with an Argument: Formal Parameters</h2><p>Formal parameters are local variables, private to the function.  </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dubs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span></span>;</code></pre><h2 id="2-Calling-a-Function-with-an-Argument-Actual-Arguments"><a href="#2-Calling-a-Function-with-an-Argument-Actual-Arguments" class="headerlink" title="(2) Calling a Function with an Argument: Actual Arguments"></a>(2) Calling a Function with an Argument: Actual Arguments</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_n_char</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> num)</span></span>;show_n_char(SPACE, <span class="hljs-number">12</span>);</code></pre><p>The <strong>actual arguments</strong> are the <code>space</code> character and <code>12</code>. These values are assigned to the corresponding <strong>formal parameters</strong> in <strong>show_n_char()</strong>—the variables <code>ch</code> and <code>num</code>. </p><p>In short, the <strong>formal parameter</strong> is a variable in the <strong>called function</strong>, and the <strong>actual argument</strong> is the particular value assigned to the function variable by the <strong>calling function</strong>. </p><p>The <strong>actual argument</strong> can be a constant, a variable, or an even more elaborate expression. Regardless of which it is, the <strong>actual argument</strong> is evaluated, and <strong>its value is copied to the corresponding formal parameter for the function</strong>.</p><p><strong>Because the called function works with data copied from the calling function, the original data in the calling function is protected from whatever manipulations the called function applies to the copies.</strong></p><h1 id="2-Returning-a-Value-from-a-Function-with-return"><a href="#2-Returning-a-Value-from-a-Function-with-return" class="headerlink" title="2. Returning a Value from a Function with return"></a>2. Returning a Value from a Function with return</h1><p>Using <strong>return</strong> has one other effect. It terminates the function and returns control to the next statement in the calling function. <strong>This occurs even if the return statement is not the last in the function.</strong></p><h1 id="3-Finding-Addresses-The-amp-Operator"><a href="#3-Finding-Addresses-The-amp-Operator" class="headerlink" title="3. Finding Addresses: The &amp; Operator"></a>3. Finding Addresses: The &amp; Operator</h1><p>One of the most important C concepts (and sometimes one of the most perplexing) is the <strong>pointer</strong>, which is a variable used to store an address.  </p><p>The unary <strong>&amp;</strong> operator gives you the address where a variable is stored. </p><h1 id="4-Pointers-A-First-Look"><a href="#4-Pointers-A-First-Look" class="headerlink" title="4. Pointers: A First Look"></a>4. Pointers: A First Look</h1><p>Basically, a <strong>pointer</strong> is a variable (or, more generally, a data object) whose value is a memory address. </p><pre><code class="hljs c">ptr = &amp;pooh; <span class="hljs-comment">// assigns pooh's address to ptr</span></code></pre><p>We say that ptr  “points to” pooh. The difference between ptr and &amp;pooh is that <strong>ptr</strong> is a variable, and <strong>&amp;pooh</strong> is a constant. </p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pi; <span class="hljs-comment">// pi is a pointer to an integer variable</span><span class="hljs-keyword">char</span> * pc; <span class="hljs-comment">// pc is a pointer to a character variable</span><span class="hljs-keyword">float</span> * pf, * pg; <span class="hljs-comment">// pf, pg are pointers to float variables</span></code></pre><p>A <strong>pointer</strong> really is a new type, not an <strong>integer</strong> type. Therefore, as mentioned before, ANSI C provides the <strong>%p</strong> form specifically for pointers.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Character Input/Output</title>
    <link href="/2020/11/29/Character-Input-Output/"/>
    <url>/2020/11/29/Character-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 8 Character Input/Output and Input Validation</p><a id="more"></a><h1 id="1-Single-Character-I-O-getchar-and-putchar"><a href="#1-Single-Character-I-O-getchar-and-putchar" class="headerlink" title="1. Single-Character I/O: getchar() and putchar()"></a>1. Single-Character I/O: getchar() and putchar()</h1><p><strong>getchar()</strong> and <strong>putchar()</strong> perform input and output one character at a time. </p><p>All it does is fetch characters from <strong>keyboard input</strong> and send them to the screen. This process is called <strong>echoing the input</strong>. </p><h1 id="2-Buffers"><a href="#2-Buffers" class="headerlink" title="2. Buffers"></a>2. Buffers</h1><h2 id="1-unbuffered-or-direct-input"><a href="#1-unbuffered-or-direct-input" class="headerlink" title="(1) unbuffered (or direct) input"></a>(1) unbuffered (or direct) input</h2><p>The characters you type are <strong>immediately made available</strong> to the waiting program. </p><h2 id="2-buffered-input"><a href="#2-buffered-input" class="headerlink" title="(2)  buffered input"></a>(2)  buffered input</h2><p>The characters you type are <strong>collected and stored in an area of temporary storage</strong> called a <strong>buffer</strong>.  Pressing <strong>Enter</strong> causes the block of characters you typed to be made available to your program. </p><h3 id="fully-buffered-I-O"><a href="#fully-buffered-I-O" class="headerlink" title="fully buffered I/O"></a>fully buffered I/O</h3><p>The <strong>buffer</strong> is flushed (the contents are sent to their destination) when it is <strong>full</strong>. This kind of buffering usually occurs with <strong>file input</strong>. </p><p>The buffer size depends on the system, but 512 bytes and 4096 bytes are common values. </p><h3 id="line-buffered-I-O"><a href="#line-buffered-I-O" class="headerlink" title="line-buffered I/O"></a>line-buffered I/O</h3><p>The <strong>buffer</strong> is flushed whenever a <strong>newline character shows up</strong>. <strong>Keyboard input</strong> is normally <strong>line buffered</strong>, so that pressing <strong>Enter</strong> flushes the buffer.</p><h1 id="3-Files-Streams-and-Keyboard-Input"><a href="#3-Files-Streams-and-Keyboard-Input" class="headerlink" title="3. Files, Streams, and Keyboard Input"></a>3. Files, Streams, and Keyboard Input</h1><h2 id="1-file"><a href="#1-file" class="headerlink" title="(1)  file"></a>(1)  file</h2><p>A <strong>file</strong> is an area of memory in which information is stored. </p><p>Conceptually, the C program deals with a <strong>stream</strong> instead of directly with a file. </p><h2 id="2-stream"><a href="#2-stream" class="headerlink" title="(2) stream"></a>(2) stream</h2><p>A <strong>stream</strong> is an idealized flow of data to which the actual input or output is mapped.</p><h1 id="4-The-End-of-File"><a href="#4-The-End-of-File" class="headerlink" title="4. The End of File"></a>4. The End of File</h1><p>A computer operating system needs some way to tell where each file begins and ends. </p><p>One method to detect the end of a file is to place a <strong>special character</strong> in the file to <strong>mark the end</strong>.</p><p>A second approach is for the operating system to store information on the size of the file.</p><p>C handles this variety of methods by having the  <strong>getchar()</strong>  function return a special value when the end of a file is reached, regardless of how the operating system actually detects the end of file. The name given to this value is <strong>EOF</strong> (end of file). </p><p>Therefore, the <strong>return value</strong> for <strong>getchar()</strong> when it detects an end of file is <strong>EOF</strong>. The <strong>scanf()</strong> function also returns <strong>EOF</strong> on detecting the end of a file. </p><p>Typically, <strong>EOF</strong> is defined in the <strong>stdio.h</strong> file as follows:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOF (-1)</span></code></pre><p>Normally, <strong>getchar()</strong> returns a value in the range <strong>0</strong> through <strong>127</strong>, because those are values corresponding to the standard character set, but it might return values from <strong>0</strong> through <strong>255</strong> if the system recognizes an extended character set. </p><p>In either case, the value <strong>-1</strong> does not correspond to any character, so it can be used to signal the end of a file.<br>&nbsp;</p><pre><code class="hljs c"><span class="hljs-comment">/* echo_eof.c -- repeats input to end of file */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ch;    <span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)        <span class="hljs-built_in">putchar</span>(ch);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>Note:</strong></p><ul><li>You don’t have to define <strong>EOF</strong> because <strong>stdio.h</strong> takes care of that.</li><li>You don’t have to worry about the actual value of <strong>EOF</strong>, because the <strong>#define</strong> statement in <strong>stdio.h</strong> enables you to use the symbolic representation <strong>EOF</strong>. You shouldn’t write code that assumes <strong>EOF</strong> has a particular value.</li><li><strong>getchar()</strong> is actually type int itself, so it can read the EOF character.</li><li>The fact that <strong>getchar()</strong> is type <strong>int</strong> is why some compilers warn of possible data loss if you assign the <strong>getchar()</strong> return value to a type <strong>char</strong> variable.</li><li>The fact that <strong>ch</strong> is an <strong>integer</strong> doesn’t faze <strong>putchar()</strong>. It still prints the character equivalent.</li><li>To use this program on <strong>keyboard input</strong>, you need a way to type the <strong>EOF</strong> character. On <strong>most Unix and Linux systems</strong>, for example, pressing <strong>Ctrl+D</strong> at the <strong>beginning of a line</strong> causes the <strong>end-of-file signal</strong> to be transmitted. Many <strong>microcomputing systems</strong> recognize <strong>Ctrl+Z</strong> at the beginning of a line as an end-of-file signal; some interpret a <strong>Ctrl+Z</strong> anywhere as an <strong>end-of-file signal</strong>.</li></ul><h1 id="5-Redirection"><a href="#5-Redirection" class="headerlink" title="5. Redirection"></a>5. Redirection</h1><p><strong>Redirecting</strong> input enables your program to use a <strong>file</strong> instead of the <strong>keyboard</strong> for input, and redirecting output enables it to use a <strong>file</strong> instead of the <strong>screen</strong> for output.</p><h2 id="1-Redirecting-Input"><a href="#1-Redirecting-Input" class="headerlink" title="(1) Redirecting Input"></a>(1) Redirecting Input</h2><p>The program runs as described earlier, taking its input from the keyboard. Now suppose you want to use the program on a <strong>text file</strong> called <code>words</code>. </p><p>A <strong>text file</strong> is one containing text—that is, data stored as <strong>human-readable characters</strong>. It could be an essay or a program in C, for example. A file containing machine language instructions, such as the file holding the executable version<br>of a program, is not a text file. </p><p>All you need to do is enter this command instead of the previous one:</p><pre><code class="hljs bash">echo_eof &lt; words</code></pre><p>The <code>&lt;</code> symbol is a <strong>Unix and Linux and DOS/Windows redirection operator</strong>. It causes the <code>words</code> file to be associated with the <strong>stdin stream</strong>, channeling the file contents into the <code>echo_eof</code> program. </p><p>The <code>echo_eof</code> program itself doesn’t know (or care) that the input is coming from a file instead of the keyboard. All it knows is that a stream of characters is being fed to it, so it reads them and prints them one character at a time until the end of file shows up. </p><p>Because C puts files and I/O devices on the same footing, the file is now the I/O device. </p><h2 id="2-Redirecting-Output"><a href="#2-Redirecting-Output" class="headerlink" title="(2) Redirecting Output"></a>(2) Redirecting Output</h2><p>Now suppose you want to have <code>echo_eof</code> send your keyboard input to a file called <code>mywords</code>.</p><p>Then you can enter the following and begin typing:</p><pre><code class="hljs bash">echo_eof &gt; mywords</code></pre><p>The <code>&gt;</code> is a second <strong>redirection operator</strong>. It causes a new file called <code>mywords</code> to be created for your use, and then it *<em>redirects the output *</em>of <code>echo_eof</code> (that is, a copy of the characters you type) to that file. </p><p>If you already have a file with the name <code>mywords</code>, normally it would be <strong>erased</strong> and then <strong>replaced</strong> by the new one. (Many operating systems, however, give you the option of protecting existing files by making them <strong>read-only</strong>.) </p><p>All that appears on your screen are the letters as you type them, and the copies go to the file instead. To end the program, press <strong>Ctrl+D</strong>.</p><h2 id="3-Combined-Redirection"><a href="#3-Combined-Redirection" class="headerlink" title="(3) Combined Redirection"></a>(3) Combined Redirection</h2><p>Now suppose you want to make a copy of the file mywords and call it savewords. Just issue this next command:</p><pre><code class="hljs bash">echo_eof &lt; mywords &gt; savewords</code></pre><p>or:</p><pre><code class="hljs bash">echo_eof &gt; savewords &lt; mywords</code></pre><p><strong>Beware: *<em>Don’t use the *</em>same file for both input and output</strong> to the same command.</p><pre><code class="hljs bash">echo_eof &lt; mywords &gt; mywords....&lt;--WRONG</code></pre><p>The reason is that <code>&gt;</code> mywords causes the original mywords to be <strong>truncated to zero length</strong> before it is ever used as input.</p><p><strong>Rules:</strong></p><ul><li>A <strong>redirection operator</strong> connects an <strong>executable program</strong> (including standard operating system commands) with a <strong>data file</strong>. It cannot be used to connect one data file to another, nor can it be used to connect one program to another program.</li><li>Input cannot be taken from <strong>more than one file</strong>, nor can output be directed to more than one file by using these operators.</li><li>Normally, <strong>spaces between the names and operators are optional</strong>, except occasionally when some characters with special meaning to the Unix shell or Linux shell or the Windows Command Prompt mode are used. We could, for example, have used <code>echo_ eof&lt;words</code>.</li></ul><p>Unix, Linux, and Windows/DOS also feature the <code>&gt;&gt;</code> operator, which enables you to <strong>add data</strong> to the end of an <strong>existing file</strong>, and the pipe operator (<code>|</code>), which enables you to connect the <strong>output of one program</strong> to the <strong>input of a second program</strong>. </p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Branching and Jumps</title>
    <link href="/2020/11/29/Branching-and-Jumps/"/>
    <url>/2020/11/29/Branching-and-Jumps/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 7 C Control Statements: Branching and Jumps</p><a id="more"></a><h1 id="1-getchar-and-putchar"><a href="#1-getchar-and-putchar" class="headerlink" title="1.  getchar() and putchar()"></a>1.  getchar() and putchar()</h1><p>The <strong>getchar()</strong> function takes no arguments, and it <strong>returns</strong> the next character from input.<br>&nbsp;<br>The <strong>putchar()</strong> function prints its argument.<br>&nbsp;<br>Because these functions deal only with characters, they are faster and more compact than the more general <strong>scanf()</strong> and <strong>printf()</strong> functions.<br>&nbsp;<br>Characters are really stored as <strong>integers</strong>. <strong>getchar( )</strong> is actually type <strong>int</strong> itself.</p><h1 id="2-The-ctype-h-Family-of-Character-Functions"><a href="#2-The-ctype-h-Family-of-Character-Functions" class="headerlink" title="2. The ctype.h Family of Character Functions"></a>2. The ctype.h Family of Character Functions</h1><p>C has a standard set of functions for analyzing characters; the <strong>ctype.h</strong> header file contains the prototypes.<br>&nbsp;<br>Note that the mapping functions don’t modify the original argument; instead, they return the modified value. </p><pre><code class="hljs c"><span class="hljs-built_in">tolower</span>(ch); <span class="hljs-comment">// no effect on ch</span>ch = <span class="hljs-built_in">tolower</span>(ch); <span class="hljs-comment">// convert ch to lowercase</span></code></pre><table><thead><tr><th align="left">Name</th><th align="left">True If the Argument Is</th></tr></thead><tbody><tr><td align="left">isalnum()</td><td align="left">Alphanumeric (alphabetic or numeric)</td></tr><tr><td align="left">isalpha()</td><td align="left">Alphabetic</td></tr><tr><td align="left">isblank()</td><td align="left">A standard blank character (space, horizontal tab, or newline) or any additional locale-specific character so specified</td></tr><tr><td align="left">iscntrl()</td><td align="left">A control character, such as Ctrl+B</td></tr><tr><td align="left">isdigit()</td><td align="left">A digit</td></tr><tr><td align="left">isgraph()</td><td align="left">Any printing character other than a space</td></tr><tr><td align="left">islower()</td><td align="left">A lowercase character</td></tr><tr><td align="left">isprint()</td><td align="left">A printing character</td></tr><tr><td align="left">ispunct()</td><td align="left">A punctuation character (any printing character other than a space or an alphanumeric character)</td></tr><tr><td align="left">isspace()</td><td align="left">A whitespace character (a space, newline, formfeed, carriage return, vertical tab, horizontal tab, or, possibly, other locale-defined character)</td></tr><tr><td align="left">isupper()</td><td align="left">An uppercase character</td></tr><tr><td align="left">isxdigit()</td><td align="left">A hexadecimal-digit character</td></tr></tbody></table><table><thead><tr><th align="left">Name</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">tolower()</td><td align="left">If the argument is an uppercase character, this function returns the lowercase version; otherwise, it just returns the original argument.</td></tr><tr><td align="left">toupper()</td><td align="left">If the argument is a lowercase character, this function returns the uppercase version; otherwise, it just returns the original argument.</td></tr></tbody></table><h1 id="3-Logical-Operators"><a href="#3-Logical-Operators" class="headerlink" title="3. Logical Operators"></a>3. Logical Operators</h1><table><thead><tr><th align="left">Operator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">and</td></tr><tr><td align="left">||</td><td align="left">or</td></tr><tr><td align="left">!</td><td align="left">not</td></tr></tbody></table><h2 id="1-Precedence"><a href="#1-Precedence" class="headerlink" title="(1) Precedence"></a>(1) Precedence</h2><p>The <strong>!</strong> operator has a very high precedence—higher than <strong>multiplication</strong>, the same as the <strong>increment operators</strong>, and just below that of <strong>parentheses</strong>. The <strong>&amp;&amp;</strong> operator has higher precedence than <strong>||</strong>.</p><h2 id="2-Order-of-Evaluation"><a href="#2-Order-of-Evaluation" class="headerlink" title="(2) Order of Evaluation"></a>(2) Order of Evaluation</h2><p>The <strong>&amp;&amp;</strong> and <strong>||</strong> operators are sequence points, so all side effects take place before a program moves from one operand to the next. </p><pre><code class="hljs c"><span class="hljs-keyword">while</span> ( x++ &lt; <span class="hljs-number">10</span> &amp;&amp; x + y &lt; <span class="hljs-number">20</span>)</code></pre><p>The fact that the <strong>&amp;&amp;</strong> operator is a sequence point guarantees that <code>x</code> is incremented before the expression on the right is evaluated.</p><h1 id="4-A-Word-Count-Program"><a href="#4-A-Word-Count-Program" class="headerlink" title="4. A Word-Count Program"></a>4. A Word-Count Program</h1><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STOP <span class="hljs-meta-string">'\x1b'</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> c;  <span class="hljs-comment">//read in character</span>    <span class="hljs-keyword">char</span> prev; <span class="hljs-comment">//previous character read</span>    <span class="hljs-keyword">long</span> n_chars = <span class="hljs-number">0L</span>; <span class="hljs-comment">//number of characters</span>    <span class="hljs-keyword">long</span> n_alphabets = <span class="hljs-number">0L</span>; <span class="hljs-comment">//alphabetic</span>    <span class="hljs-keyword">long</span> n_digits = <span class="hljs-number">0L</span>; <span class="hljs-comment">//digits</span>    <span class="hljs-keyword">long</span> n_spaces = <span class="hljs-number">0L</span>;    <span class="hljs-keyword">long</span> n_punctuations = <span class="hljs-number">0L</span>;    <span class="hljs-keyword">int</span> n_lines = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> n_words = <span class="hljs-number">0</span>;    <span class="hljs-keyword">bool</span> inword = <span class="hljs-literal">false</span>;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter text to be analyzed (Esc to terminate):\n"</span>);    prev = <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">while</span> ((c = getchar()) != STOP)    &#123;        n_chars++;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalpha</span>(c))           n_alphabets++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))            n_digits++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ispunct</span>(c))            n_punctuations++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c))            n_spaces++;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'\n'</span>)            n_lines++;        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isspace</span>(c) &amp;&amp; !inword)         &#123;            inword = <span class="hljs-literal">true</span>;            n_words++;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c) &amp;&amp; inword)         &#123;            inword = <span class="hljs-literal">false</span>; <span class="hljs-comment">//reached end of a word</span>        &#125;        prev = c;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Charaters = %ld, alphabets = %ld, digits = %ld,\</span><span class="hljs-string">    punctuations = %ld, spaces = %ld,  words = %d, lines = %d\n"</span>,    n_chars,n_alphabets,n_digits,n_punctuations,n_spaces,n_words,n_lines);    <span class="hljs-comment">/*return 0; */</span>&#125;</code></pre><p>Output:</p><pre><code class="hljs c"><span class="hljs-function">Enter <span class="hljs-built_in">text</span> to be <span class="hljs-title">analyzed</span> <span class="hljs-params">(Esc to <span class="hljs-built_in">terminate</span>)</span>:</span><span class="hljs-function">Reason is a</span><span class="hljs-function">powerful servant but</span>an inadequate master.<span class="hljs-number">2</span> - <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;*** :) ***^[Charaters = <span class="hljs-number">77</span>, alphabets = <span class="hljs-number">45</span>, digits = <span class="hljs-number">3</span>, punctuations = <span class="hljs-number">12</span>, spaces = <span class="hljs-number">17</span>,  words = <span class="hljs-number">17</span>, lines = <span class="hljs-number">5</span></code></pre><h1 id="5-The-Conditional-Operator"><a href="#5-The-Conditional-Operator" class="headerlink" title="5. The Conditional Operator: ?:"></a>5. The Conditional Operator: ?:</h1><p>C offers a shorthand way to express one form of the <strong>if else</strong> statement. It is called a conditional expression and uses the <strong>?:</strong> conditional operator. </p><pre><code class="hljs c">expression1 ? expression2 : expression3</code></pre><p>If expression1 is true (nonzero), the whole conditional expression has the same value as expression2. If expression1 is false (zero), the whole conditional expression has the same value as expression3.</p><h1 id="6-Loop-Aids-continue-and-break"><a href="#6-Loop-Aids-continue-and-break" class="headerlink" title="6. Loop Aids: continue and break"></a>6. Loop Aids: continue and break</h1><h2 id="1-The-continue-Statement"><a href="#1-The-continue-Statement" class="headerlink" title="(1) The continue Statement"></a>(1) The continue Statement</h2><p>The continue statement causes the program to <strong>skip over</strong> the rest of the loop, which is devoted to processing valid input. Instead, the program <strong>starts the next loop cycle</strong> by attempting to read the next input value. </p><p><strong>continue</strong> works for the while, do while, for, and not for the switch function.</p><p><strong>continue</strong> terminates the current loop, but not the entire loop.</p><pre><code class="hljs c"><span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">10</span>; count++)&#123;ch = getchar();<span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'\n'</span>)<span class="hljs-keyword">continue</span>;<span class="hljs-built_in">putchar</span>(ch);&#125;</code></pre><p>In this case, when the <strong>continue</strong> statement is executed, <strong>first count is incremented</strong> and then it’s compared to 10.</p><h2 id="2-The-break-Statement"><a href="#2-The-break-Statement" class="headerlink" title="(2) The break Statement"></a>(2) The break Statement</h2><p>A <strong>break</strong> statement in a loop causes the program to break free of the loop that encloses it and to proceed to the next stage of the program. </p><p>break works for while, do while, for and switch functions.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> i;  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  &#123;    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)    <span class="hljs-keyword">break</span>;  &#125;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %d\n"</span>,i);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>In this case, when the program executes the <strong>break</strong> statement, it breaks out of the for loop <strong>without adding i</strong>.  </p><h1 id="7-The-goto-Statement"><a href="#7-The-goto-Statement" class="headerlink" title="7. The goto Statement"></a>7. The goto Statement</h1><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &gt; <span class="hljs-number">12</span>)    <span class="hljs-keyword">goto</span> a;<span class="hljs-keyword">goto</span> b;a: cost = cost * <span class="hljs-number">1.05</span>;flag = <span class="hljs-number">2</span>;b: bill = cost * flag;</code></pre><p>It is the same as:</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &gt; <span class="hljs-number">12</span>)&#123;    cost = cost * <span class="hljs-number">1.05</span>;    flag = <span class="hljs-number">2</span>;&#125;bill = cost * flag;</code></pre><p>When a <strong>goto</strong> is encountered, it jumps unconditionally to the statement where the <strong>label</strong> is, and then <strong>executes sequentially from there</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operators, Expressions, and Statements</title>
    <link href="/2020/11/28/Operators-Expressions-and-Statements/"/>
    <url>/2020/11/28/Operators-Expressions-and-Statements/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 5 Operators, Expressions, and Statements</p><a id="more"></a><h1 id="1-Fundamental-Operators"><a href="#1-Fundamental-Operators" class="headerlink" title="1. Fundamental Operators"></a>1. Fundamental Operators</h1><h2 id="1-Assignment-Operator"><a href="#1-Assignment-Operator" class="headerlink" title="(1) Assignment Operator: ="></a>(1) Assignment Operator: =</h2><p>The <code>=</code> symbol is called the assignment operator.</p><h3 id="Some-Terminology-Data-Objects-Lvalues-Rvalues-and-Operands"><a href="#Some-Terminology-Data-Objects-Lvalues-Rvalues-and-Operands" class="headerlink" title="Some Terminology: Data Objects, Lvalues, Rvalues, and Operands"></a>Some Terminology: Data Objects, Lvalues, Rvalues, and Operands</h3><p>Consider an assignment statement. Its purpose is to store a value at a memory location.<br>&nbsp;<br><strong>Data object</strong> is a general term for a region of data storage that can be used to hold values.<br>&nbsp;<br>C uses the term <strong>lvalue</strong> to mean any such name or expression that identifies a particular data object. <strong>Object</strong> refers to the actual data storage, but an <strong>lvalue</strong> is a <strong>label</strong> used to identify, or locate, that storage.</p><p>The term <strong>rvalue</strong> refers to quantities that can be assigned to modifiable <strong>lvalues</strong> but which are not themselves lvalues. <strong>Rvalues</strong> can be constants, variables, or any other expression that yields a value. </p><h2 id="2-Division-Operator"><a href="#2-Division-Operator" class="headerlink" title="(2) Division Operator: /"></a>(2) Division Operator: /</h2><p>Division works differently for integer types than it does for floating types. Floating-type division gives a floating-point answer, but integer division yields an integer answer.</p><p>Integer division does not round to the nearest integer, but always truncates (that is, discards the entire fractional part).</p><pre><code class="hljs c"><span class="hljs-number">5</span>/<span class="hljs-number">2</span> = <span class="hljs-number">2</span><span class="hljs-number">-5</span>/<span class="hljs-number">2</span> = <span class="hljs-number">-2</span><span class="hljs-number">5</span>/(<span class="hljs-number">-2</span>) = <span class="hljs-number">-2</span></code></pre><h2 id="3-Modulus-Operator"><a href="#3-Modulus-Operator" class="headerlink" title="(3) Modulus Operator: %"></a>(3) Modulus Operator: %</h2><p>The modulus operator is used in <strong>integer arithmetic</strong>. It gives the remainder that results when the integer to its left is divided by the integer to its right. For example, 13 % 5 (read as “13 modulo 5”) has the value 3.</p><p>You get a negative modulus value if the first operand is negative, and you get a positive modulus otherwise.</p><pre><code class="hljs c"><span class="hljs-number">5</span>%<span class="hljs-number">2</span> = <span class="hljs-number">1</span><span class="hljs-number">-5</span>%<span class="hljs-number">2</span> = <span class="hljs-number">-1</span><span class="hljs-number">5</span>%(<span class="hljs-number">-2</span>) = <span class="hljs-number">1</span></code></pre><h2 id="4-Increment-and-Decrement-Operators-and-–"><a href="#4-Increment-and-Decrement-Operators-and-–" class="headerlink" title="(4) Increment and Decrement Operators: ++ and –"></a>(4) Increment and Decrement Operators: ++ and –</h2><p>The increment operator performs a simple task; it increments (increases) the value of its operand by 1. </p><pre><code class="hljs pgsql">a_post = a++; // postfix: a <span class="hljs-keyword">is</span> changed <span class="hljs-keyword">after</span> its <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> usedb_pre= ++b;// prefix: b <span class="hljs-keyword">is</span> changed <span class="hljs-keyword">before</span> its <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> used(a + b)++; //invalid</code></pre><p>You can get fooled if you try to do too much at once with the increment operators.</p><pre><code class="hljs c"><span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">21</span>)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%10d %10d\n"</span>, num, num*num++);&#125;</code></pre><p>In C, the compiler can choose which arguments in a function to evaluate first.</p><pre><code class="hljs c">ans = num/<span class="hljs-number">2</span> + <span class="hljs-number">5</span>*(<span class="hljs-number">1</span> + num++);</code></pre><p>You would think that it would find num/2 first and then move on, but it might do the last term first.</p><h2 id="5-The-Comma-Operator"><a href="#5-The-Comma-Operator" class="headerlink" title="(5) The Comma Operator"></a>(5) The Comma Operator</h2><p>First, it guarantees that the expressions it separates are evaluated in a <strong>left-to-right order</strong>.<br>Second, the <strong>value of the whole comma expression</strong> is the value of the <strong>right-hand member</strong>.</p><pre><code class="hljs c">x = (y = <span class="hljs-number">3</span>, (z = ++y + <span class="hljs-number">2</span>) + <span class="hljs-number">5</span>);<span class="hljs-comment">//x = (z = ++y + 2) + 5;</span></code></pre><h1 id="2-Operator-Precedence"><a href="#2-Operator-Precedence" class="headerlink" title="2. Operator Precedence"></a>2. Operator Precedence</h1><table><thead><tr><th align="center">Operators (decreasing precedence)</th><th align="center">Associativity</th></tr></thead><tbody><tr><td align="center">+ - (unary)</td><td align="center">Left to right</td></tr><tr><td align="center">* /</td><td align="center">Left to right</td></tr><tr><td align="center">+ - (binary)</td><td align="center">Left to right</td></tr><tr><td align="center">=</td><td align="center">Left to right</td></tr><tr><td align="center">,</td><td align="center">Left to right</td></tr></tbody></table><h1 id="3-Expressions-and-Statements"><a href="#3-Expressions-and-Statements" class="headerlink" title="3. Expressions and Statements"></a>3. Expressions and Statements</h1><h2 id="1-Expressions"><a href="#1-Expressions" class="headerlink" title="(1) Expressions"></a>(1) Expressions</h2><p>An expression consists of a combination of operators and operands.<br>&nbsp;<br>An important property of C is that every C expression has a value. </p><h2 id="2-Statements"><a href="#2-Statements" class="headerlink" title="(2) Statements"></a>(2) Statements</h2><p>Statements are the primary building blocks of a program. A program is a series of statements with some necessary punctuation. A statement is a complete instruction to the computer. In C, statements are indicated by a <strong>semicolon</strong> at the end. </p><h1 id="4-Type-Conversions"><a href="#4-Type-Conversions" class="headerlink" title="4. Type Conversions"></a>4. Type Conversions</h1><h2 id="1-Automatic-Type-Conversions"><a href="#1-Automatic-Type-Conversions" class="headerlink" title="(1) Automatic Type Conversions"></a>(1) Automatic Type Conversions</h2><ol><li>When appearing in an <strong>expression</strong>, <strong>char</strong> and <strong>short</strong>, both <strong>signed</strong> and <strong>unsigned</strong>, are <strong>automatically</strong> converted to <strong>int</strong> or, if necessary, to <strong>unsigned int</strong>. (If <strong>short</strong> is the same size as <strong>int</strong>, <strong>unsigned short</strong> is larger than <strong>int</strong>; in that case, <strong>unsigned short</strong> is converted to <strong>unsigned int</strong>.) Under <strong>K&amp;R</strong> C, but not under current C, <strong>float</strong> is automatically converted to <strong>double</strong>. Because they are conversions to larger types, they are called <strong>promotions</strong>.</li><li>In any <strong>operation</strong> involving <strong>two types</strong>, both values are converted to the <strong>higher ranking</strong> of the two types.</li><li>The <strong>ranking of types</strong>, from <strong>highest to lowest</strong>, is <strong>long double</strong>, <strong>double</strong>, <strong>float</strong>, <strong>unsigned long long</strong>, <strong>long long</strong>, <strong>unsigned long</strong>, <strong>long</strong>, <strong>unsigned int</strong>, and <strong>int</strong>. One possible <strong>exception</strong> is when <strong>long and int are the same size</strong>, in which case <strong>unsigned int</strong> outranks <strong>long</strong>. The <strong>short</strong> and <strong>char</strong> types don’t appear in this list because they would have been already promoted to int or perhaps <strong>unsigned int</strong>.</li><li>In an <strong>assignment statement</strong>, the final result of the calculations is converted to the type of <strong>the variable being assigned a value</strong>. This process can result in <strong>promotion</strong>, as described in rule 1, or <strong>demotion</strong>, in which a value is converted to a lower-ranking type.</li><li>When passed as <strong>function arguments</strong>, <strong>char</strong> and <strong>short</strong> are converted to <strong>int</strong>, and <strong>float</strong> is converted to <strong>double</strong>. This <strong>automatic promotion</strong> is overridden by function prototyping.</li></ol><h2 id="2-The-Cast-Operator"><a href="#2-The-Cast-Operator" class="headerlink" title="(2) The Cast Operator"></a>(2) The Cast Operator</h2><p>The parentheses and type name together constitute a cast operator.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>)<span class="hljs-number">1.6</span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Charater Strings and Formatted Input/Output</title>
    <link href="/2020/11/28/Charater-Strings-and-Formatted-Input-Output/"/>
    <url>/2020/11/28/Charater-Strings-and-Formatted-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 4 Charater Strings and Formatted Input/Output</p><a id="more"></a><h1 id="1-Character-Strings"><a href="#1-Character-Strings" class="headerlink" title="1. Character Strings"></a>1. Character Strings</h1><p> A character string is a series of one or more characters. </p><h2 id="1-Type-char-Arrays-and-the-Null-Character"><a href="#1-Type-char-Arrays-and-the-Null-Character" class="headerlink" title="(1) Type char Arrays and the Null Character"></a>(1) Type char Arrays and the Null Character</h2><p>C has no special variable type for strings. Instead, strings are stored in an array of type char. Characters in a string are stored in adjacent memory cells, one character per cell, and an array consists of adjacent memory locations.<br><img src="https://img-blog.csdnimg.cn/20190521222859479.png" srcset="/img/loading.gif" alt=""><br>The <strong>null character</strong> is not the digit zero; it is the nonprinting character whose <strong>ASCII</strong> code value (or equivalent) is <strong>0</strong>. Strings in C are always stored with this terminating null character. The presence of the null character means that the array must have <strong>at least one more cell</strong> than the number of characters to be stored. </p><h2 id="2-Using-Strings"><a href="#2-Using-Strings" class="headerlink" title="(2) Using Strings"></a>(2) Using Strings</h2><p>In general, <strong>scanf()</strong> is used with <strong>%s</strong> to read only a <strong>single word</strong>, not a whole phrase, as a string. C has other input-reading functions, such as <strong>fgets()</strong>, for handling general strings.</p><h2 id="3-Strings-Versus-Characters"><a href="#3-Strings-Versus-Characters" class="headerlink" title="(3) Strings Versus Characters"></a>(3) Strings Versus Characters</h2><p><img src="https://img-blog.csdnimg.cn/201905212249433.png" srcset="/img/loading.gif" alt="A word is the natural unit of memory for a given computer design.For 8-bit microcomputers,"></p><h1 id="2-The-strlen-Function"><a href="#2-The-strlen-Function" class="headerlink" title="2. The strlen() Function"></a>2. The strlen() Function</h1><p>The <strong>strlen()</strong> function gives the length of a string in characters.<br>The <strong>string.h</strong> file contains function prototypes for several string related functions, including <strong>strlen()</strong>.<br>&nbsp;<br>The <strong>strlen()</strong> gives you the exact number of characters (including spaces and punctuation) in the string. The <strong>sizeof</strong> operator gives you a number one <strong>larger</strong> because it also counts the <strong>invisible null character</strong> used to end the string.<br>&nbsp;<br>The <strong>C99</strong> and <strong>C11</strong> standards use a <strong>%zd</strong> specifier for the type used by the <strong>sizeof</strong> operator. This also applies for type returned by <strong>strlen()</strong>.<br>&nbsp;<br>The preceding chapter used <strong>sizeof</strong> with <strong>parentheses</strong>, but this example doesn’t. <strong>Parentheses</strong> are <strong>required for types</strong> but are <strong>optional for particular quantities</strong>. That is, you would use <strong>sizeof(char)</strong> or <strong>sizeof(float)</strong> but can use <strong>sizeof name</strong> or <strong>sizeof 6.28.</strong></p><h1 id="3-Constants-and-the-C-Preprocessor"><a href="#3-Constants-and-the-C-Preprocessor" class="headerlink" title="3. Constants and the C Preprocessor"></a>3. Constants and the C Preprocessor</h1><p>The <strong>preprocessor</strong> uses <strong>#include</strong> to incorporate information from another file, it also lets you define constants. Just add a line like the following at the top of the file containing your program:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TAXRATE 0.015</span></code></pre><p><strong>No semicolon</strong> is used because this is a substitution mechanism handled by the <strong>preprocessor</strong>, not a <strong>C</strong> statement.</p><h1 id="4-The-const-Modifier"><a href="#4-The-const-Modifier" class="headerlink" title="4. The const Modifier"></a>4. The const Modifier</h1><p><strong>C90</strong> added a second way to <strong>create symbolic constants</strong>—using the <strong>const</strong> keyword to convert a declaration for a <strong>variable</strong> into a declaration for a <strong>constant</strong>:</p><pre><code class="hljs c"><span class="hljs-comment">// MONTHS a symbolic constant for 12</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MONTHS = <span class="hljs-number">12</span>;</code></pre><p>This newer approach is more flexible than using <strong>#define</strong>; it lets you declare a type, and it allows better control over which parts of a program can use the constant.</p><h1 id="5-Manifest-Constants-on-the-Job"><a href="#5-Manifest-Constants-on-the-Job" class="headerlink" title="5. Manifest Constants on the Job"></a>5. Manifest Constants on the Job</h1><p>The C header files <strong>limits.h</strong> and <strong>float.h</strong> supply detailed information about the <strong>size limits</strong> of <strong>integer</strong> types and <strong>floating</strong> types, respectively. </p><h1 id="6-The-printf-Function"><a href="#6-The-printf-Function" class="headerlink" title="6. The printf() Function"></a>6. The printf() Function</h1><p>The instructions you give <strong>printf()</strong> when you ask it to print a variable depend on the variable type. </p><table><thead><tr><th align="left">Conversion</th><th align="left">Output Specification</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">Floating-point-number, hexadecimal digits and p-notation(C99/C11).</td></tr><tr><td align="left">%A</td><td align="left">Floating-point-number, hexadecimal digits and p-notation(C99/C11).</td></tr><tr><td align="left">%c</td><td align="left">Single character.</td></tr><tr><td align="left">%d</td><td align="left">Single decimal integer.</td></tr><tr><td align="left">%e</td><td align="left">Floating-point number, e-notation.</td></tr><tr><td align="left">%E</td><td align="left">Floating-point number, e-notation.</td></tr><tr><td align="left">%f</td><td align="left">Floating-point number, decimal notation.</td></tr><tr><td align="left">%g</td><td align="left">Using %f or %e, depending on the value. The %e style is used if the exponent is less than -4 or greater than or equal to the presion.</td></tr><tr><td align="left">%G</td><td align="left">Using %f or %E, depending on the value. The %E style is used if the exponent is less than -4 or greater than or equal to the presion.</td></tr><tr><td align="left">%i</td><td align="left">Single decimal integer(same as %d).</td></tr><tr><td align="left">%o</td><td align="left">Unsigned octal integer.</td></tr><tr><td align="left">%p</td><td align="left">A pointer.</td></tr><tr><td align="left">%s</td><td align="left">Character string.</td></tr><tr><td align="left">%u</td><td align="left">Unsigned decimal integer.</td></tr><tr><td align="left">%x</td><td align="left">Unsigned hexadecimal integer, using hex digits 0f.</td></tr><tr><td align="left">%X</td><td align="left">Unsigned hexadecimal integer, using hex digits 0F.</td></tr><tr><td align="left">%%</td><td align="left">Prints a percent sign.</td></tr></tbody></table><h2 id="1-Conversion-Specification-Modifiers-for-printf"><a href="#1-Conversion-Specification-Modifiers-for-printf" class="headerlink" title="(1) Conversion Specification Modifiers for printf()"></a>(1) Conversion Specification Modifiers for printf()</h2><table><thead><tr><th align="left">Modifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">flag</td><td align="left">Five flags:-,+,space,#, and 0.</td></tr><tr><td align="left">digit(s)</td><td align="left">The minimun field width. A wilder field will be used if the printed number or string won’t fit in the field.</td></tr><tr><td align="left">.digit(s)</td><td align="left">Presions. For %e, %E, and %f conversions, the maximun number of significant digits. For %g and %G conversions, the maximun number of significant digits. For %s conversion, the maximun number of characters to be printed. For integer conversions, the minimun number of digits to apper: leading zeros are used if necessary to meet this minimum. Using only . implies a following zero, so %.f is the same as %.0f.</td></tr><tr><td align="left">h</td><td align="left">Used with an integer conversion specifier to indicate a short int or unsigned short int value.</td></tr><tr><td align="left">hh</td><td align="left">Used with an integer conversion specifier to indicate a signed char or unsigned char value.</td></tr><tr><td align="left">j</td><td align="left">Used with an integer conversion specifier to indicate an intmax_t or uintmax_t value; these are types defined in stdint.h.</td></tr><tr><td align="left">l</td><td align="left">Used with an integer conversion specifier to indicate a long int or unsigned long int.</td></tr><tr><td align="left">ll</td><td align="left">Used with an integer conversion specifier to indicate a long long int or unsigned long long int.(C99).</td></tr><tr><td align="left">L</td><td align="left">Used with a floating-point conversion specifier to indicate a long double value.</td></tr><tr><td align="left">t</td><td align="left">Used with an integer conversion specifier to indicate a ptrdiff_t value. This is the type corresponding to the difference between two pointers. (C99).</td></tr><tr><td align="left">z</td><td align="left">Used with an integer conversion specifier to indicate a size_t value. This is the type returned by sizeof. (C99).</td></tr></tbody></table><h2 id="2-The-printf-Flags"><a href="#2-The-printf-Flags" class="headerlink" title="(2) The printf( ) Flags"></a>(2) The printf( ) Flags</h2><table><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">The item is left-justified; that is, it is printed begining at the left of the field.</td></tr><tr><td align="left">+</td><td align="left">Signed values are displayed with a plus sign, if positive, and with a minus sign, if negative.</td></tr><tr><td align="left">space</td><td align="left">Signed values are displayed with a  leading space (but no sign) if positive and with a minus sign if negative. A + flag overrides a space.</td></tr><tr><td align="left">#</td><td align="left">Used  an alternative form for the conversion specification. Produces an initial 0 for the %o form and initial 0x for the %x or %X form, respectively. For all floating-point forms, # gurantees that a decimal-point character is printed, even if no digits follow. For %g and %G forms, it prevents traing zeros form being removed.</td></tr><tr><td align="left">0</td><td align="left">For numeric forms, pad the field width with leading zeros indtead of with spaces. This flag is ignored if a - flag is present or if, for an integer form, a precision is specified.</td></tr></tbody></table><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">float</span> f = <span class="hljs-number">321454.321345</span>;   <span class="hljs-keyword">float</span> f1 = <span class="hljs-number">12.2345678</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %04f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %06.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %6.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %-6.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"321454.321345 = %7f\n"</span>,f);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"321454.321345 = %7.3f\n"</span>,f);    <span class="hljs-keyword">int</span> n1 = <span class="hljs-number">3456</span>;  <span class="hljs-keyword">int</span> n2  = <span class="hljs-number">1</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3456 = %3.2d\n"</span>,n1);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3456 = %6.2d\n\n"</span>,n1);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 = %.4d\n"</span>,n2);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 = %3.2d\n\n"</span>,n2);    <span class="hljs-comment">//测试字符串宽度精度</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %9.3s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %9s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %3s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Output：</p><pre><code class="hljs c"><span class="hljs-number">2.3</span> = <span class="hljs-number">2.300000</span> <span class="hljs-comment">//%04f：输出宽度至少4，精度不限制时用默认的，浮点数默认精度6位，这里宽度指总的宽度（包括小数点和小数点后面的数）</span><span class="hljs-number">2.3</span> = <span class="hljs-number">002.30</span> <span class="hljs-comment">//%06.2f： 总共宽度至少6位，精度2位，因此左边补0</span><span class="hljs-number">2.3</span> =   <span class="hljs-number">2.30</span> <span class="hljs-comment">//%6.2f：总共宽度至少6位，精度2位，左边空两格，默认右对齐</span><span class="hljs-number">2.3</span> = <span class="hljs-number">2.30</span> <span class="hljs-comment">// %-6.2f：总共宽度至少6位，精度2位，右边空两格，加-号左对齐</span><span class="hljs-number">321454.321345</span> = <span class="hljs-number">321454.312500</span><span class="hljs-number">321454.321345</span> = <span class="hljs-number">321454.312</span><span class="hljs-number">3456</span> = <span class="hljs-number">3456</span>  <span class="hljs-comment">//%3.2d ，总宽度至少3</span><span class="hljs-number">3456</span> =   <span class="hljs-number">3456</span>  <span class="hljs-comment">//%6.2d ，总宽度至少6</span><span class="hljs-number">1</span> = <span class="hljs-number">0001</span> <span class="hljs-comment">//%.4d 有效位4位，只有1位，其余补0</span><span class="hljs-number">1</span> =  <span class="hljs-number">01</span>  <span class="hljs-comment">//%3.2d 总宽度3，有效位2，因此左边空1格，补一个0</span><span class="hljs-string">"printf"</span> =        pri <span class="hljs-comment">// %9.3s 总宽度至少9，有效3位，因此只现实3个字符</span><span class="hljs-string">"printf"</span> =    <span class="hljs-built_in">printf</span>  <span class="hljs-comment">// %9s，总宽度至少9，宽度9</span><span class="hljs-string">"printf"</span> = <span class="hljs-built_in">printf</span>   <span class="hljs-comment">// %3s，总宽度至少3，因此宽度为6</span></code></pre><h2 id="3-The-Return-Value-of-printf"><a href="#3-The-Return-Value-of-printf" class="headerlink" title="(3) The Return Value of printf()"></a>(3) The Return Value of printf()</h2><p>The <strong>printf()</strong> function also has a return value; it returns the <strong>number of characters</strong> it printed. </p><h2 id="4-Printing-Long-Strings"><a href="#4-Printing-Long-Strings" class="headerlink" title="(4) Printing Long Strings"></a>(4) Printing Long Strings</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's one way to print a "</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"long string.\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's another way to print a \</span><span class="hljs-string">long string.\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's the newest way to print a "</span><span class="hljs-string">"long string.\n"</span>); <span class="hljs-comment">/* ANSI C */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Method 1 is to use more than one <strong>printf()</strong> statement.<br>Method 2 is to terminate the end of the first line with a backslash/return combination.<br>Method 3, which ANSI C introduced, is <strong>string concatenation</strong>. If you follow one <strong>quoted</strong> string constant with another, separated only by <strong>whitespace</strong>, C treats the combination as a <strong>single string</strong>. </p><h1 id="7-scanf"><a href="#7-scanf" class="headerlink" title="7. scanf()"></a>7. scanf()</h1><p>It converts string input into various forms: integers, floating-point numbers, characters, and C strings.<br>&nbsp;<br>Rules:</p><blockquote><ul><li>If you use <strong>scanf()</strong> to read a value for one of the basic variable types, precede the variable name with an <strong>&amp;</strong>.</li><li>If you use <strong>scanf()</strong> to read a string into a <strong>character array</strong>, don’t use an <strong>&amp;</strong>.</li></ul></blockquote><h2 id="1-Conversion-Specifiers-for-scanf"><a href="#1-Conversion-Specifiers-for-scanf" class="headerlink" title="(1) Conversion Specifiers for scanf()"></a>(1) Conversion Specifiers for scanf()</h2><p>The <strong>scanf()</strong> function uses pretty much the same set of conversion specification characters as <strong>printf()</strong> does. The main difference is that <strong>printf()</strong> uses %f, %e, %E, %g, and %G for both type float and type double, whereas <strong>scanf()</strong> uses them just for type float, requiring the <strong>l</strong> modifier for double. </p><table><thead><tr><th align="left">Conversion Specifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">%c</td><td align="left">Interpret input as a character.</td></tr><tr><td align="left">%d</td><td align="left">Interpret input as a signed decimal integer.</td></tr><tr><td align="left">%e, %f, %g, %a</td><td align="left">Interpret input as a floating-point number (%a is C99).</td></tr><tr><td align="left">%E, %F, %G, %A</td><td align="left">Interpret input as a floating-point number (%A is C99).</td></tr><tr><td align="left">%i</td><td align="left">Interpret input as a signed decimal integer.</td></tr><tr><td align="left">%o</td><td align="left">Interpret input as a signed Octal integer.</td></tr><tr><td align="left">%p</td><td align="left">Intepret input as a pointer (an address).</td></tr><tr><td align="left">%s</td><td align="left">Intepret input as a string. Input begins with the first non-whitespace character and includes evertything up to the next whitespace character.</td></tr><tr><td align="left">%u</td><td align="left">Interpret input as a unsigned decimal integer.</td></tr><tr><td align="left">%x, %X</td><td align="left">Interpret input as a signed hexadecimal integer.</td></tr></tbody></table><h2 id="2-Conversion-Modifiers-for-scanf"><a href="#2-Conversion-Modifiers-for-scanf" class="headerlink" title="(2) Conversion Modifiers for scanf()"></a>(2) Conversion Modifiers for scanf()</h2><table><thead><tr><th align="left">Modifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">Suppress assignment.</td></tr><tr><td align="left">digit(s)</td><td align="left">Maximum field width. Input stops when the maximum field width is reached or when the first whitespace character is encountered, whichever comes first.</td></tr><tr><td align="left">hh</td><td align="left">Read an integer as a signed char or unsigned char.</td></tr><tr><td align="left">ll</td><td align="left">Read an integer as a long long or unsigned long long (C99).</td></tr><tr><td align="left">h, l or L</td><td align="left">“%hd” and “%hi” indicate that the value will be stored in a <strong>short int</strong>. “%ho”, “%hx”, and “%hu” indicate that the value will be stored in an <strong>unsigned short int</strong>. “%ld” and “%li” indicate that the value will be stored in a <strong>long</strong>. “%lo”, “%lx”, and “%lu” indicate that the value will be stored in <strong>unsigned long</strong>. “%le”, “%lf”, and “%lg” indicate that the value will be stored in type <strong>double</strong>. Using L instead of l with e, f, and g indicates that the value will be stored in type <strong>long double</strong>. In the absence of these modifiers, d, i, o, and x indicate type <strong>int</strong>, and e, f, and g indicate type <strong>float</strong>.</td></tr><tr><td align="left">j</td><td align="left">When followed by an integer specifier, indicates using the intmax_t or uintmax_t type (C99).</td></tr><tr><td align="left">z</td><td align="left">When followed by an integer specifier, indicates using the type returned by sizeof (C99).</td></tr><tr><td align="left">t</td><td align="left">When followed by an integer specifier, indicates using the type used to represent the difference between two pointers (C99).</td></tr></tbody></table><h2 id="3-The-scanf-View-of-Input"><a href="#3-The-scanf-View-of-Input" class="headerlink" title="(3) The scanf() View of Input"></a>(3) The scanf() View of Input</h2><p>It skips over whitespace characters (spaces, tabs, and newlines) until it finds a non-whitespace character. scanf() continues reading and saving characters until it encounters a nondigit. </p><p>&nbsp;<br>If you use a <strong>%c</strong> specifier, all input characters are fair game. If the next input character is a space or a newline, a space or a newline is assigned to the indicated variable; <strong>whitespace is not skipped</strong>.</p><h2 id="4-The-scanf-Return-Value"><a href="#4-The-scanf-Return-Value" class="headerlink" title="(4) The scanf() Return Value"></a>(4) The scanf() Return Value</h2><p>The <strong>scanf()</strong> function returns <strong>the number of items</strong> that it successfully reads. If it reads no items, which happens if you type a nonnumeric string when it expects a number, <strong>scanf()</strong> returns the value 0. It returns <strong>EOF</strong> when it detects the condition known as “end of file.” </p><h1 id="8-The-Modifier-with-printf-and-scanf"><a href="#8-The-Modifier-with-printf-and-scanf" class="headerlink" title="8. The * Modifier with printf() and scanf()"></a>8. The * Modifier with printf() and scanf()</h1><h2 id="1-The-Modifier-with-printf"><a href="#1-The-Modifier-with-printf" class="headerlink" title="(1) The * Modifier with printf()"></a>(1) The * Modifier with printf()</h2><p>Suppose that you don’t want to commit yourself to a field width in advance but rather you want the program to specify it. You can do this by using <code>*</code> instead of a number for the field width, but you also have to add an argument to tell what the field width should be.<br>&nbsp;<br>That is, if you have the conversion specifier <code>%*d</code>, the argument list should include a value for <code>*</code> and a value for <code>d</code>. </p><h2 id="2-The-Modifier-with-scanf"><a href="#2-The-Modifier-with-scanf" class="headerlink" title="(2) The * Modifier with scanf()"></a>(2) The * Modifier with scanf()</h2><p>The <code>*</code> serves quite a different purpose for <strong>scanf()</strong>. When placed between the <code>%</code> and the specifier letter, it causes that function to <strong>skip over corresponding input</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data and C</title>
    <link href="/2020/11/24/Data-and-C/"/>
    <url>/2020/11/24/Data-and-C/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 3 Data and C</p><a id="more"></a><h1 id="1-Bits-Bytes-and-Words"><a href="#1-Bits-Bytes-and-Words" class="headerlink" title="1. Bits, Bytes, and Words"></a>1. Bits, Bytes, and Words</h1><h2 id="1-Bit"><a href="#1-Bit" class="headerlink" title="(1) Bit"></a>(1) Bit</h2><p>The smallest unit of memory is called a <strong>bit</strong>. It can hold one of two values: 0 or 1.</p><h2 id="2-Byte"><a href="#2-Byte" class="headerlink" title="(2) Byte"></a>(2) Byte</h2><p><strong>byte</strong> is the usual unit of computer memory. For nearly all machines, a byte is 8 bits, and that is the standard definition, at least when used to measure storage.<br>&nbsp;<br>Because each bit can be either 0 or 1, there are 256 (that’s 2 times itself 8 times) possible bit patterns of 0s and 1s that can fit in an 8-bit byte.</p><h2 id="3-Word"><a href="#3-Word" class="headerlink" title="(3) Word"></a>(3) Word</h2><p>A <strong>word</strong> is the natural unit of memory for a given computer design.<br>&nbsp;<br>For 8-bit microcomputers, such as the original Apples, a word is just 8 bits. Since then, personal computers moved up to 16-bit words, 32-bit words, and, at the present, 64-bit words. Larger word sizes enable faster transfer of data and allow more memory to be accessed.</p><h1 id="2-Integer-Versus-Floating-Point-Types"><a href="#2-Integer-Versus-Floating-Point-Types" class="headerlink" title="2. Integer Versus Floating-Point Types"></a>2. Integer Versus Floating-Point Types</h1><h2 id="1-The-Integer"><a href="#1-The-Integer" class="headerlink" title="(1) The Integer"></a>(1) The Integer</h2><p>An <strong>integer</strong> is a number with no fractional part.</p><h2 id="2-The-Floating-Point-Number"><a href="#2-The-Floating-Point-Number" class="headerlink" title="(2) The Floating-Point Number"></a>(2) The Floating-Point Number</h2><p>A <strong>floating-point</strong> number more or less corresponds to what mathematicians call a real number.<br>&nbsp;<br>The key point here is that the scheme used to store a floating-point number is different from the one used to store an integer. <strong>Floating-point representation involves breaking up a number into a fractional part and an exponent part and storing the parts separately</strong>.<br>&nbsp;<br>For some arithmetic operations, such as subtracting one large number from another, floating-point numbers are subject to greater <strong>loss of precision</strong>. Because there is an infinite number of real numbers in any range，For example, 7.0 might be stored as a 6.99999 float value.</p><h1 id="3-Basic-C-Data-Types"><a href="#3-Basic-C-Data-Types" class="headerlink" title="3. Basic C Data Types"></a>3. Basic C Data Types</h1><h2 id="1-The-int-Type"><a href="#1-The-int-Type" class="headerlink" title="(1) The int Type"></a>(1) The int Type</h2><p>The <strong>int</strong> type is a signed integer. That means it must be an integer and it can be positive, negative, or zero.</p><h3 id="Octal-and-Hexadecimal"><a href="#Octal-and-Hexadecimal" class="headerlink" title="Octal and Hexadecimal"></a>Octal and Hexadecimal</h3><p>A prefix of <strong>0x</strong> or <strong>0X</strong> (zero-ex) means that you are specifying a <strong>hexadecimal</strong> value, so 16 is written as 0x10, or 0X10.<br>&nbsp;<br>A <strong>0</strong> (zero) prefix means that you are writing in <strong>octal</strong>. For example, the decimal value 16 is written as 020 in <strong>octal</strong>.</p><h3 id="Other-Integer-Types"><a href="#Other-Integer-Types" class="headerlink" title="Other Integer Types"></a>Other Integer Types</h3><p>C offers three adjective keywords to modify the basic integer type: <strong>short</strong>, <strong>long</strong>, and <strong>unsigned</strong>.<br>&nbsp;<br>To cause a small constant to be treated as type long, you can append an <strong>l</strong> (lowercase <strong>L</strong>) or <strong>L</strong> as a <strong>suffix</strong>. </p><p>Add a <strong>u</strong> or <strong>U</strong> to the <strong>suffix</strong> for <strong>unsigned long long</strong>, as in <code>5ull</code> or <code>10LLU</code> .<br>&nbsp;<br>Note that the <strong>short</strong> variable end is displayed the same whether you tell <strong>printf()</strong> that end is a <strong>short</strong> (the <strong>%hd</strong> specifier) or an <strong>int</strong> (the <strong>%d</strong> specifier). </p><p><strong>That’s because C automatically expands a type short value to a type int value when it’s passed as an argument to a function</strong>.</p><p><strong>The int type is intended to be the integer size that the computer handles most efficiently</strong>.</p><h2 id="2-Using-Characters-Type-char"><a href="#2-Using-Characters-Type-char" class="headerlink" title="(2) Using Characters: Type char"></a>(2) Using Characters: Type char</h2><p>The <strong>char</strong> type is used for storing characters such as <strong>letters</strong> and <strong>punctuation marks</strong>, but technically it is an <strong>integer</strong> type.<br>&nbsp;<br>To handle characters, the computer uses a <strong>numerical code</strong> in which certain integers represent certain characters. </p><p>The most commonly used code in the U.S. is the <code>ASCII</code> code.<br>&nbsp;<br>The standard <code>ASCII</code> code runs numerically from 0 to 127. This range is small enough that 7 bits can hold it. The char type is typically defined as an 8-bit unit of memory.<br>&nbsp;<br><strong>Character Constants and Initialization</strong>：A single character contained between single quotes is a C character constant.<br>&nbsp;<br>Because characters are really stored as numeric values, you can also use the numerical code to assign values:</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> grade = <span class="hljs-number">65</span>; <span class="hljs-comment">/* ok for ASCII, but poor style */</span></code></pre><p>Because 65 is the <code>ASCII</code> code for the letter <code>A</code>, this example assigns the value <code>A</code> to grade.<br>&nbsp;<br>C treats character constants as type <code>int</code> rather than type <code>char</code>. For example, on an <code>ASCII</code> system with a 32-bit int and an 8-bit char, the code.</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> grade = <span class="hljs-string">'B'</span>;</code></pre><p><strong>represents ‘B’ as the numerical value 66 stored in a 32-bit unit, but grade winds up with 66 stored in an 8-bit unit.</strong> </p><p>This characteristic of character constants makes it possible to define a character constant such as <code>&#39;FATE&#39;</code>, with four separate 8-bit <code>ASCII</code> codes stored in a 32-bit unit.</p><p>However, attempting to assign such a character constant to a char variable results in only the <strong>last 8 bits</strong> being used, so the variable gets the value <code>&#39;E&#39;</code>.</p><p><strong>Nonprinting Characters</strong><br>The first way we have already mentioned—just use the <code>ASCII</code> code.<br>&nbsp;<br>The second way to represent certain awkward characters in C is to use special symbol sequences. These are called <strong>escape sequences</strong>. </p><table><thead><tr><th align="left">Sequence</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">\a</td><td align="left">Aleart(ANSI C)</td></tr><tr><td align="left">\b</td><td align="left">Backspace</td></tr><tr><td align="left">\f</td><td align="left">Form feed</td></tr><tr><td align="left">\n</td><td align="left">Newline</td></tr><tr><td align="left">\r</td><td align="left">Carrigae return</td></tr><tr><td align="left">\t</td><td align="left">Horizontal tab</td></tr><tr><td align="left">\v</td><td align="left">Vertical tab</td></tr><tr><td align="left">\</td><td align="left">Backslash()</td></tr><tr><td align="left">&#39;</td><td align="left">Single quote(‘)</td></tr><tr><td align="left">&quot;</td><td align="left">Double quote(“)</td></tr><tr><td align="left">?</td><td align="left">Question mark(?)</td></tr><tr><td align="left">\0oo</td><td align="left">Octal value (o represents an octal digit.)</td></tr><tr><td align="left">\0hh</td><td align="left">Hexadecimal value (h represents a hexadecimal digit.)</td></tr></tbody></table><p>To represent alert character (<code>\a</code>), you could use the <code>ASCII</code> code instead: <code>&#39;007&#39;</code>. You can omit the leading zeros, so <code>&#39;\07&#39;</code> or even <code>&#39;\7&#39;</code>will do. This notation causes numbers to be interpreted as octal, even if there is no initial 0.</p><p><strong>Note:</strong> When a character, be it an <strong>escape sequence or not</strong>, is part of a string of characters enclosed in double quotes, <strong>don’t enclose it in single quotes</strong>.</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello!\007\n"</span>);</code></pre><p>will print </p><pre><code class="hljs c">Hello! <span class="hljs-keyword">and</span> <span class="hljs-built_in">beep</span></code></pre><h2 id="3-The-Bool-Type"><a href="#3-The-Bool-Type" class="headerlink" title="(3) The _Bool Type"></a>(3) The _Bool Type</h2><p>C uses the value $1$ for <strong>true</strong> and $0$ for <strong>false</strong>, the <strong>_Bool</strong> type really is just an <strong>integer</strong> type, but one that, in principle, only requires 1 bit of memory, because that is enough to cover the full range from $0$ to $1$.</p><h2 id="4-Portable-Types-stdint-h-and-inttypes-h"><a href="#4-Portable-Types-stdint-h-and-inttypes-h" class="headerlink" title="(4) Portable Types: stdint.h and inttypes.h"></a>(4) Portable Types: stdint.h and inttypes.h</h2><p>The same type name doesn’t necessarily mean the same thing on different systems, What C has done is create more names for the existing types. The trick is to define these new names in a header file called <strong>stdint.h</strong>. </p><p>For example, <code>int32_t</code> represents the type for a <strong>32-bit signed integer</strong>. The header file on a system that uses a 32-bit int could define <code>int32_t</code> as an <strong>alias for int</strong>. A different system, one with a 16-bit int and a 32-bit long, could define the same name, <code>int32_t</code>, as an <strong>alias for int</strong>. </p><h2 id="5-Types-float-double-and-long-double"><a href="#5-Types-float-double-and-long-double" class="headerlink" title="(5) Types float, double, and long double"></a>(5) Types float, double, and long double</h2><p>Here are two <strong>valid floating-point constants</strong>:</p><pre><code class="hljs angelscript"><span class="hljs-number">-1.56E+12</span><span class="hljs-number">3.14159</span><span class="hljs-number">.2</span><span class="hljs-number">4e16</span><span class="hljs-number">.8E-5</span><span class="hljs-number">100.</span></code></pre><p><strong>Rules:</strong></p><ul><li>You can leave out positive signs. </li><li>You can do without a <strong>decimal point</strong> (2E5) or an <strong>exponential part</strong> (19.28), but <strong>not both simultaneously</strong>. </li><li>You can <strong>omit a fractional part</strong> (3.E16) or <strong>an integer<br>part</strong> (.45E–6), but <strong>not both</strong> (that wouldn’t leave much!). </li><li>Don’t use spaces in a floating-point constant.</li></ul><p>By default, the compiler assumes <strong>floating-point constants</strong> are <strong>double</strong> precision.</p><p>C enables you to <strong>override</strong> this default by using an <strong>f</strong> or <strong>F</strong> <strong>suffix</strong> to make the compiler treat a <strong>floating-point</strong> constant as type <strong>float</strong>; examples are <code>2.3f</code> and <code>9.11E9F</code>. </p><p>An <strong>l</strong> or <strong>L</strong> <strong>suffix</strong> makes a number type <strong>long double</strong>; examples are <code>54.3l</code> and <code>4.32e4L</code>. </p><p>If the floating-point number has <strong>no suffix</strong>, it is type <strong>double</strong>.</p><h1 id="4-Format-Specifier"><a href="#4-Format-Specifier" class="headerlink" title="4. Format Specifier"></a>4. Format Specifier</h1><p>It indicates the form that <strong>printf()</strong> uses to display a value.</p><h2 id="1-d"><a href="#1-d" class="headerlink" title="(1) %d"></a>(1) %d</h2><p><strong>%d</strong> notation is used to indicate just where in a line the <strong>integer</strong> is to be printed.  <strong>d means decimal</strong><br>&nbsp;<br>Each <strong>%d</strong> in the format string must be matched by a corresponding <strong>int</strong> value in the list of items to be printed. </p><h2 id="2-Printing-short-long-long-long-and-unsigned-Types"><a href="#2-Printing-short-long-long-long-and-unsigned-Types" class="headerlink" title="(2) Printing short, long, long long, and unsigned Types"></a>(2) Printing short, long, long long, and unsigned Types</h2><p>To print an <strong>unsigned int</strong> number, use the <strong>%u</strong> notation. To print a <strong>long</strong> value, use the <strong>%ld</strong> format specifier.<br>&nbsp;<br>Note that although C allows both <strong>uppercase</strong> and <strong>lowercase</strong> letters for <strong>constant suffixes</strong>, these format specifiers use just <strong>lowercase</strong>.<br>&nbsp;<br>C has several additional <strong>printf()</strong> formats. First, you can use an <strong>h</strong> <strong>prefix</strong> for <strong>short</strong> types. Therefore, <strong>%hd</strong> displays a <strong>short integer</strong> in <strong>decimal</strong> form, and <strong>%ho</strong> displays a <strong>short integer in octal form</strong>. Both the <strong>h</strong> and <strong>l</strong> <strong>prefixes</strong> can be used with <strong>u</strong> for <strong>unsigned</strong> types. </p><h2 id="3-c"><a href="#3-c" class="headerlink" title="(3) %c"></a>(3) %c</h2><p>The <strong>printf()</strong> function uses <strong>%c</strong> to indicate that a <strong>character</strong> should be printed. </p><h2 id="4-Printing-Floating-Point-Values"><a href="#4-Printing-Floating-Point-Values" class="headerlink" title="(4) Printing Floating-Point Values"></a>(4) Printing Floating-Point Values</h2><p>The <strong>printf()</strong> function uses the <strong>%f</strong> format specifier to print type <strong>float</strong> and <strong>double</strong> numbers using <strong>decimal</strong> notation, and it uses <strong>%e</strong> to print them in <strong>exponential</strong> notation. </p><table><thead><tr><th align="left">Format</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">%f</td><td align="left"><strong>decimal</strong> notation(float, double)</td></tr><tr><td align="left">%e</td><td align="left"><strong>exponential</strong> notation(float, double)</td></tr><tr><td align="left">%a, %A</td><td align="left"><strong>hexadecimal p</strong> notation(float,double)</td></tr><tr><td align="left">%Lf, %Le, %La</td><td align="left"><strong>decimal</strong>, <strong>exponential</strong>, <strong>hexadecimal p</strong> notation(long double)</td></tr></tbody></table><h1 id="5-Type-Sizes"><a href="#5-Type-Sizes" class="headerlink" title="5. Type Sizes"></a>5. Type Sizes</h1><p>What type sizes does your system use?</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type int has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type char has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type long has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>));&#125;<span class="hljs-comment">//C has a built-in operator called sizeof that gives sizes in bytes. C99 and C11 provide a %zd specifier for this type used by sizeof.</span></code></pre><p>answer</p><pre><code class="hljs routeros">Type int has a size of 4 bytes.Type char has a size of 1 bytes.Type long has a size of 8 bytes.</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
