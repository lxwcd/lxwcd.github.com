<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Generic Algorithms</title>
    <link href="/2021/01/31/Generic-Algorithms/"/>
    <url>/2021/01/31/Generic-Algorithms/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 10 Sequential Containers</p><a id="more"></a><h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>Algorithms never change the size of the underlying container. Algorithms may change the values of the elements stored in the container, and they may move elements around within the container. They do not, however, ever add or remove elements directly.</p><h1 id="2-A-First-Look-at-the-Algorithms"><a href="#2-A-First-Look-at-the-Algorithms" class="headerlink" title="2.  A First Look at the Algorithms"></a>2.  A First Look at the Algorithms</h1><p>Although most algorithms are similar in that they operate over an input range, they differ in how they use the elements in that range. The most basic way to understand the algorithms is to know whether they read elements, write elements, or rearrange the order of the elements.</p><h2 id="1-Read-Only-Algorithms"><a href="#1-Read-Only-Algorithms" class="headerlink" title="(1) Read-Only Algorithms"></a>(1) Read-Only Algorithms</h2><p>The <code>find</code> function is one such algorithm.</p><p>Another read-only algorithm is <code>accumulate</code>, which is defined in the <code>numeric</code><br>header.</p><p>The <code>accumulate</code> function takes three arguments. The first two specify a range of elements to sum. The third is an initial value for the sum.</p><pre><code class="hljs cpp"><span class="hljs-comment">// sum the elements in vec starting the summation with the value 0</span><span class="hljs-keyword">int</span> sum = accumulate(vec.cbegin(), vec.cend(), <span class="hljs-number">0</span>);</code></pre><p>sets <code>sum</code> equal to the sum of the elements in <code>vec</code>, using <code>0</code> as the starting point for the summation.</p><p><strong>The type of the third argument to accumulate determines which addition operator is used and is the type that accumulate returns.</strong></p><h3 id="Algorithms-and-Element-Types"><a href="#Algorithms-and-Element-Types" class="headerlink" title="Algorithms and Element Types"></a>Algorithms and Element Types</h3><p>The fact that <code>accumulate</code> uses its third argument as the starting point for the summation has an important implication: It must be possible to add the element type to the type of the sum. That is, the elements in the sequence must match or be convertible to the type of the third argument. </p><p>In this example, the elements in <code>vec</code> might be ints, or they might be double, or long long, or any other type that can be added to an int.</p><p>As another example, because <code>string</code> has a <code>+</code> operator, we can concatenate the elements of a <code>vector</code> of strings by calling accumulate:</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> sum = accumulate(v.cbegin(), v.cend(), <span class="hljs-built_in">string</span>(<span class="hljs-string">""</span>));</code></pre><p>This call concatenates each element in <code>v</code> onto a <code>string</code> that starts out as the empty string. Note that we explicitly create a string as the third parameter. </p><p>Passing the empty string as a string literal would be a compile-time error:</p><pre><code class="hljs cpp"><span class="hljs-comment">// error: no + on const char*</span><span class="hljs-built_in">string</span> sum = accumulate(v.cbegin(), v.cend(), <span class="hljs-string">""</span>);</code></pre><p>Had we passed a string literal, the type of the object used to hold the <code>sum</code> would be <code>const char*</code>. That type determines which <code>+</code> operator is used. Because there is no <code>+</code> operator for type <code>const char*</code>, this call will not compile.</p><h3 id="Algorithms-That-Operate-on-Two-Sequences"><a href="#Algorithms-That-Operate-on-Two-Sequences" class="headerlink" title="Algorithms That Operate on Two Sequences"></a>Algorithms That Operate on Two Sequences</h3><p>Another read-only algorithm is <code>equal</code>, which lets us determine whether two sequences hold the same values. </p><p>It compares each element from the first sequence to the corresponding element in the second. It returns true if the corresponding elements are equal, false otherwise. </p><p>The algorithm takes three iterators: The first two (as usual) denote the range of elements in the first sequence; the third denotes the first element in the second sequence:</p><pre><code class="hljs cpp"><span class="hljs-comment">// roster2 should have at least as many elements as roster1</span>equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());</code></pre><p>Because <code>equal</code> operates in terms of iterators, we can call <code>equal</code> to compare elements in containers of different types. Moreover, the element types also need not be the same so long as we can use <code>==</code> to compare the element types. </p><p>For example, <code>roster1</code> could be a <code>vector&lt;string&gt;</code> and <code>roster2</code> a <code>list&lt;const char*&gt;</code>.</p><p><strong>Algorithms that take a single iterator denoting a second sequence assume that the second sequence is at least as large at the first.</strong></p><h2 id="2-Algorithms-That-Write-Container-Elements"><a href="#2-Algorithms-That-Write-Container-Elements" class="headerlink" title="(2) Algorithms That Write Container Elements"></a>(2) Algorithms That Write Container Elements</h2><p>Algorithms do not perform container operations, so they have no way themselves to change the size of a container.</p><p>The <code>fill</code> algorithm takes a pair of iterators that denote a range and a third argument that is a value. <code>fill</code> assigns the given value to each element in the input sequence:</p><p>The fill_n function takes a single iterator, a count, and a value.</p><pre><code class="hljs cpp">fill(vec.begin(), vec.end(), <span class="hljs-number">0</span>); <span class="hljs-comment">// reset each element to 0</span><span class="hljs-comment">// set a subsequence of the container to 10</span>fill(vec.begin(), vec.begin() + vec.size()/<span class="hljs-number">2</span>, <span class="hljs-number">10</span>);fill_n(vec.begin(), vec.size(), <span class="hljs-number">0</span>);</code></pre><h3 id="back-inserter"><a href="#back-inserter" class="headerlink" title="back_inserter"></a>back_inserter</h3><p>One way to ensure that an algorithm has enough elements to hold the output is to use an <code>insert</code> iterator. An <code>insert</code> iterator is an iterator that adds elements to a container.</p><p><code>back_inserter</code> takes a reference to a container and returns an <code>insert</code> iterator bound to that container. When we assign through that iterator, the assignment calls <code>push_back</code> to add an element with the given value to the container:</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec; <span class="hljs-comment">// empty vector</span><span class="hljs-keyword">auto</span> it = back_inserter(vec); <span class="hljs-comment">// assigning through it adds elements to vec</span>*it = <span class="hljs-number">42</span>; <span class="hljs-comment">// vec now has one element with value 42</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec; <span class="hljs-comment">// empty vector</span><span class="hljs-comment">// ok: back_inserter creates an insert iterator that adds elements to vec</span>fill_n(back_inserter(vec), <span class="hljs-number">10</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// appends ten elements to vec</span></code></pre><p>On each iteration, <code>fill_n</code> assigns to an element in the given sequence. Because we passed an iterator returned by <code>back_inserter</code>, each assignment will call <code>push_back</code> on <code>vec</code>. As a result, this call to <code>fill_n</code> adds ten elements to the end of <code>vec</code>, each of which has the value <code>0</code>.</p><h3 id="Copy-Algorithms"><a href="#Copy-Algorithms" class="headerlink" title="Copy Algorithms"></a>Copy Algorithms</h3><p>This algorithm takes three iterators. The first two denote an input range; the third denotes the beginning of the destination sequence. This algorithm copies elements from its input range into elements in the destination. It is essential that the destination passed to copy be at least as large as the input range.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a1[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-keyword">int</span> a2[<span class="hljs-keyword">sizeof</span>(a1)/<span class="hljs-keyword">sizeof</span>(*a1)]; <span class="hljs-comment">// a2 has the same size as a1</span><span class="hljs-comment">// ret points just past the last element copied into a2</span><span class="hljs-keyword">auto</span> ret = copy(begin(a1), end(a1), a2); <span class="hljs-comment">// copy a1 into a2</span></code></pre><p>Here we define an <code>array</code> named <code>a2</code> and use <code>sizeof</code> to ensure that <code>a2</code> has as many elements as the array <code>a1</code>.</p><p>The value returned by <code>copy</code> is the (incremented) value of its destination iterator. That is, <code>ret</code> will point just past the last element copied into <code>a2</code>. </p><pre><code class="hljs cpp"><span class="hljs-comment">// replace any element with the value 0 with 42</span>replace(ilst.begin(), ilst.end(), <span class="hljs-number">0</span>, <span class="hljs-number">42</span>);</code></pre><p>If we want to leave the original sequence unchanged, we can call <code>replace_copy</code>. That algorithm takes a third iterator argument denoting a destination in which to write the adjusted sequence:</p><pre><code class="hljs cpp"><span class="hljs-comment">// use back_inserter to grow destination as needed</span>replace_copy(ilst.cbegin(), ilst.cend(),            back_inserter(ivec), <span class="hljs-number">0</span>, <span class="hljs-number">42</span>);</code></pre><p>After this call, <code>ilst</code> is unchanged, and <code>ivec</code> contains a copy of <code>ilst</code> with the exception that every element in <code>ilst</code> with the value <code>0</code> has the value <code>42</code> in <code>ivec</code>.</p><h2 id="3-Algorithms-That-Reorder-Container-Elements"><a href="#3-Algorithms-That-Reorder-Container-Elements" class="headerlink" title="(3) Algorithms That Reorder Container Elements"></a>(3) Algorithms That Reorder Container Elements</h2><h3 id="Eliminating-Duplicates"><a href="#Eliminating-Duplicates" class="headerlink" title="Eliminating Duplicates"></a>Eliminating Duplicates</h3><p>To eliminate the duplicated words, we will first <code>sort</code> the <code>vector</code> so that duplicated words appear adjacent to each other. </p><p>Once the vector is sorted, we can use another library algorithm, named <code>unique</code>, to reorder the vector so that the unique elements appear in the first part of the vector. Because algorithms cannot do container operations, we’ll use the <code>erase</code> member of vector to actually remove the elements:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">elimDups</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; &amp;words)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// sort words alphabetically so we can find the duplicates</span>    sort(words.begin(), words.end());    <span class="hljs-comment">// unique reorders the input range so that each word appears once in the</span>    <span class="hljs-comment">// front portion of the range and returns an iterator one past the unique range</span>    <span class="hljs-keyword">auto</span> end_unique = unique(words.begin(), words.end());    <span class="hljs-comment">// erase uses a vector operation to remove the nonunique elements</span>    words.erase(end_unique, words.end());&#125;</code></pre><p>The unique algorithm rearranges the input range to “eliminate” adjacent duplicated entries, and returns an iterator that denotes the end of the range of the unique values. </p><p>After the call to <code>unique</code>, the vector holds The size of words is unchanged.</p><p>The order of those elements is changed—the adjacent duplicates have been “removed”. </p><p>We put <code>remove</code> in quotes because <code>unique</code> doesn’t remove any elements. Instead, it overwrites adjacent duplicates so that the unique elements appear at the front of the sequence.</p><p>The iterator returned by <code>unique</code> denotes one past the last unique element. The elements beyond that point still exist, but we don’t know what values they have.</p><h1 id="3-Customizing-Operations"><a href="#3-Customizing-Operations" class="headerlink" title="3. Customizing Operations"></a>3. Customizing Operations</h1><h2 id="1-Passing-a-Function-to-an-Algorithm"><a href="#1-Passing-a-Function-to-an-Algorithm" class="headerlink" title="(1) Passing a Function to an Algorithm"></a>(1) Passing a Function to an Algorithm</h2><p>A <code>predicate</code> is an expression that can be called and that returns a value that can be used as a condition. </p><p>The predicates used by library algorithms are either unary predicates (meaning they have a single parameter) or binary predicates (meaning they have two parameters). </p><pre><code class="hljs cpp"><span class="hljs-comment">// comparison function to be used to sort by word length</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> s1.size() &lt; s2.size();&#125;<span class="hljs-comment">// sort on word length, shortest to longest</span>sort(words.begin(), words.end(), isShorter);</code></pre><p>To keep the words of the same length in alphabetical order we can use the <code>stable_sort</code> algorithm. A <code>stable sort</code> maintains the original order among equal elements.</p><pre><code class="hljs cpp"><span class="hljs-comment">// put words in alphabetical order and remove duplicates</span>elimDups(words); <span class="hljs-comment">// resort by length, maintaining alphabetical order among words of the same length</span>stable_sort(words.begin(), words.end(), isShorter);</code></pre><h2 id="2-Lambda-Expressions"><a href="#2-Lambda-Expressions" class="headerlink" title="(2) Lambda Expressions"></a>(2) Lambda Expressions</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const in C VS C++</title>
    <link href="/2021/01/24/const-in-C-VS-C++/"/>
    <url>/2021/01/24/const-in-C-VS-C++/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><ol><li>const variables in c++ have internal linkage by default, while in c const global variables have default external linkage.</li></ol><p><a href="https://lxwcd.github.io/2020/12/29/Variables-and-Basic-Types/#3-const-Qualifier">const qualifier in c++</a></p><pre><code class="hljs cpp"><span class="hljs-comment">//c++ </span><span class="hljs-comment">// file_1.cc defines and initializes a const that </span><span class="hljs-comment">// is accessible to other files</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = fcn();<span class="hljs-comment">// file_1.h</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize; <span class="hljs-comment">// same bufSize as defined in file_1.cc</span></code></pre><p><a href="https://lxwcd.github.io/2021/01/07/Storage-Classes-Linkage-and-Memory-Management/#4-Static-Variables-with-External-Linkage">Static Variables with External Linkage in c</a></p><pre><code class="hljs c"><span class="hljs-comment">//c</span><span class="hljs-comment">/* file1.c -- defines some global constants */</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">3.14159</span>;<span class="hljs-comment">/* file2.c -- use global constants defined elsewhere */</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> PI;</code></pre><ol start="2"><li>A const variable in c is not a const expression<br><a href="https://lxwcd.github.io/2020/12/29/Variables-and-Basic-Types/#5-Constant-Expressions">constant expressions in c++</a></li></ol><p>A const object that is initialized from a constant expression is also a constant expression.</p><pre><code class="hljs cpp"><span class="hljs-comment">//c++</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max_files = <span class="hljs-number">20</span>; <span class="hljs-comment">// max_files is a constant expression</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> limit = max_files + <span class="hljs-number">1</span>; <span class="hljs-comment">// limit is a constant expression</span><span class="hljs-keyword">int</span> staff_size = <span class="hljs-number">27</span>; <span class="hljs-comment">// staff_size is not a constant expression</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = get_size(); <span class="hljs-comment">// sz is not a constant expression</span>``` In C the <span class="hljs-keyword">const</span> qualifier makes an object read-only but <span class="hljs-keyword">not</span> a constant expression.```c<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>;    <span class="hljs-keyword">int</span> a[i];    <span class="hljs-comment">//error in c storage size of ‘b’ isn’t constant</span>    <span class="hljs-comment">//correct in c++ </span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b[i];    a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    b[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * I;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, a[<span class="hljs-number">0</span>]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, b[<span class="hljs-number">0</span>]);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C++</category>
      
      <category>Supplement</category>
      
      <category>Supplement</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sequential Containers</title>
    <link href="/2021/01/24/Sequential-Containers/"/>
    <url>/2021/01/24/Sequential-Containers/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 9 Sequential Containers</p><a id="more"></a><h1 id="1-Overview-of-the-Sequential-Containers"><a href="#1-Overview-of-the-Sequential-Containers" class="headerlink" title="1. Overview of the Sequential Containers"></a>1. Overview of the Sequential Containers</h1><p><img src="_v_images/20210126210857370_861158007.png" srcset="/img/loading.gif" alt="Sequential Container Types"><br>With the exception of <code>array</code>, which is a fixed-size container, the containers provide efficient, flexible memory management.</p><p><code>string</code> and <code>vector</code> hold their elements in contiguous memory. Because elements are contiguous, it is fast to compute the address of an element from its index. However, adding or removing elements in the middle of one of these containers takes time: All the elements after the one inserted or removed have to be moved to maintain contiguity. </p><p>The <code>list</code> and <code>forward_list</code> containers are designed to make it fast to add or remove an element anywhere in the container. In exchange, these types do not support random access to elements: We can access an element only by iterating through the container.</p><p>A <code>deque</code> is a more complicated data structure. Like <code>string</code> and <code>vector</code>, <code>deque</code> supports fast random access. As with <code>string</code> and <code>vector</code>, adding or removing elements in the middle of a <code>deque</code> is a (potentially) expensive operation. However, adding or removing elements at either end of the <code>deque</code> is a fast operation, comparable to adding an element to a <code>list</code> or <code>forward_list</code>.</p><p>A <code>forward_list</code> is intended to be comparable to the best handwritten, singly linked list. Consequently, <code>forward_list</code> does not have the size operation because storing or computing its size would entail overhead compared to a handwritten list.</p><p>There are a few rules of thumb that apply to selecting which container to use:</p><ul><li><p>Unless you have a reason to use another container, use a <code>vector</code>.</p></li><li><p>If your program has lots of small elements and space overhead matters, don’t use <code>list</code> or <code>forward_list</code>.</p></li><li><p>If the program requires random access to elements, use a <code>vector</code> or a <code>deque</code>.</p></li><li><p>If the program needs to insert or delete elements in the middle of the container, use a <code>list</code> or <code>forward_list</code>.</p></li><li><p>If the program needs to insert or delete elements at the front and the back, but not in the middle, use a <code>deque</code>.</p></li><li><p>If the program needs to insert elements in the middle of the container only while reading input, and subsequently needs random access to the elements:</p><p>First, decide whether you actually need to add elements in the middle of a container. It is often easier to append to a vector and then call the library sort function (which we shall cover in § 10.2.3 (p. 384)) to reorder the container when you’re done with input.</p><p>If you must insert into the middle, consider using a list for the input phase. Once the input is complete, copy the list into a vector.</p><h1 id="2-Container-Library-Overview"><a href="#2-Container-Library-Overview" class="headerlink" title="2. Container Library Overview"></a>2. Container Library Overview</h1><p><img src="_v_images/20210126211123630_1152336192.png" srcset="/img/loading.gif" alt="Container Operations"><br><img src="_v_images/20210126211321870_70230926.png" srcset="/img/loading.gif" alt="Container Operations"><br><img src="_v_images/20210126211635356_1380290290.png" srcset="/img/loading.gif" alt="Defining and Initializing Containers"></p></li></ul><p>Almost any type can be used as the element type of a sequential container. </p><p>In particular, we can define a container whose element type is itself another container.</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; lines; <span class="hljs-comment">// vector of vectors</span></code></pre><p>Although we can store almost any type in a container, some container operations impose requirements of their own on the element type.</p><p>We can define a container for a type that does not support an operation-specific requirement, but we can use an operation only if the element type meets that operation’s requirements.</p><pre><code class="hljs cpp"><span class="hljs-comment">// assume noDefault is a type without a default constructor</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;noDefault&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>, init)</span></span>; <span class="hljs-comment">// ok: element initializer supplied</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;noDefault&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// error: must supply an element initializer</span></code></pre><h2 id="1-Iterators"><a href="#1-Iterators" class="headerlink" title="(1)  Iterators"></a>(1)  Iterators</h2><p>As with the containers, <strong>iterators</strong> have a common interface: If an iterator provides an operation, then the operation is supported in the same way for each iterator that supplies that operation. </p><p>For example, all the iterators on the standard container types let us access an element from a container, and they all do so by providing the dereference operator. </p><p>Similarly, the iterators for the library containers all define the increment operator to move from one element to the next.</p><p>The <code>forward_list</code> iterators do not support the decrement (–) operator. The iterator arithmetic operations apply only to iterators for string, vector, deque, and array. We cannot use these operations on iterators for any of the other container types.</p><p>An <strong>iterator range</strong> is denoted by a pair of iterators each of which refers to an element, or to one past the last element, in the same container.</p><p>This element range is called a left-inclusive interval. The standard mathematical notation for such a range is [begin, end).</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (begin != end) &#123;    *begin = val;     ++begin; &#125;</code></pre><h2 id="2-Container-Type-Members"><a href="#2-Container-Type-Members" class="headerlink" title="(2) Container Type Members"></a>(2) Container Type Members</h2><pre><code class="hljs cpp"><span class="hljs-comment">// iter is the iterator type defined by list&lt;string&gt;</span><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt;::iterator iter;<span class="hljs-comment">// count is the difference_type type defined by vector&lt;int&gt;</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::difference_type count;</code></pre><h2 id="3-begin-and-end-Members"><a href="#3-begin-and-end-Members" class="headerlink" title="(3) begin and end Members"></a>(3) begin and end Members</h2><p>The begin and end operations yield iterators that refer to the first and one past the last element in the container.</p><pre><code class="hljs cpp"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; a = &#123;<span class="hljs-string">"Milton"</span>, <span class="hljs-string">"Shakespeare"</span>, <span class="hljs-string">"Austen"</span>&#125;;<span class="hljs-keyword">auto</span> it1 = a.begin(); <span class="hljs-comment">// list&lt;string&gt;::iterator</span><span class="hljs-keyword">auto</span> it2 = a.rbegin(); <span class="hljs-comment">// list&lt;string&gt;::reverse_iterator</span><span class="hljs-keyword">auto</span> it3 = a.cbegin(); <span class="hljs-comment">// list&lt;string&gt;::const_iterator</span><span class="hljs-keyword">auto</span> it4 = a.crbegin();<span class="hljs-comment">// list&lt;string&gt;::const_reverse_iterator</span></code></pre><h2 id="4-Defining-and-Initializing-a-Container"><a href="#4-Defining-and-Initializing-a-Container" class="headerlink" title="(4) Defining and Initializing a Container"></a>(4) Defining and Initializing a Container</h2><p>Every container type defines a default constructor. With the exception of <code>array</code>, the default constructor creates an empty container of the specified type. </p><p>Again excepting array, the other constructors take arguments that specify the size of the container and initial values for the elements.</p><p>There are two ways to create a new container as a copy of another one: We can directly copy the container, or (excepting array) we can copy a range of elements denoted by a pair of iterators.</p><pre><code class="hljs cpp"><span class="hljs-comment">// each container has three elements, initialized from the given initializers</span><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; authors = &#123;<span class="hljs-string">"Milton"</span>, <span class="hljs-string">"Shakespeare"</span>, <span class="hljs-string">"Austen"</span>&#125;;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; articles = &#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"an"</span>, <span class="hljs-string">"the"</span>&#125;;<span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">list2</span><span class="hljs-params">(authors)</span></span>; <span class="hljs-comment">// ok: types match</span><span class="hljs-function"><span class="hljs-built_in">deque</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">authList</span><span class="hljs-params">(authors)</span></span>; <span class="hljs-comment">// error: container types don't match</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">words</span><span class="hljs-params">(articles)</span></span>; <span class="hljs-comment">// error: element types must match</span><span class="hljs-comment">// ok: converts const char* elements to string</span><span class="hljs-function">forward_list&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">words</span><span class="hljs-params">(articles.begin(), articles.end())</span></span>;</code></pre><p>We can use the constructor that takes a size argument if the element type is a builtin type or a class type that has a default constructor.</p><p>If the element type does not have a default constructor, then we must specify an explicit element initializer along with the size.</p><p>The constructors that take a size are valid only for sequential containers; they are not supported for the associative containers.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// ten int elements, each initialized to -1</span><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">"hi!"</span>)</span></span>; <span class="hljs-comment">// ten strings; each element is "hi!"</span><span class="hljs-function">forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// ten elements, each initialized to 0</span><span class="hljs-function"><span class="hljs-built_in">deque</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// ten elements, each an empty string</span></code></pre><p>To use an array type we must specify both the element type and the size:</p><pre><code class="hljs cpp"><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 42&gt; <span class="hljs-comment">// type is: array that holds 42 ints</span><span class="hljs-built_in">array</span>&lt;<span class="hljs-built_in">string</span>, 10&gt; <span class="hljs-comment">// type is: array that holds 10 strings</span><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt;::size_type i; <span class="hljs-comment">// array type includes element type and size</span><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>&gt;::size_type j; <span class="hljs-comment">// error: array&lt;int&gt; is not a type</span></code></pre><pre><code class="hljs cpp"><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; ia1; <span class="hljs-comment">// ten default-initialized ints</span><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; ia2 = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// list initialization</span><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; ia3 = &#123;<span class="hljs-number">42</span>&#125;; <span class="hljs-comment">// ia3[0] is 42, remaining elements are 0</span><span class="hljs-keyword">int</span> digs[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-keyword">int</span> cpy[<span class="hljs-number">10</span>] = digs; <span class="hljs-comment">// error: no copy or assignment for built-in arrays</span><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; digits = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; copy = digits; <span class="hljs-comment">// ok: so long as array types match</span></code></pre><h2 id="5-Assignment-and-swap"><a href="#5-Assignment-and-swap" class="headerlink" title="(5) Assignment and swap"></a>(5) Assignment and swap</h2><p><img src="_v_images/20210126212601559_928554306.png" srcset="/img/loading.gif" alt="Container Assignment Operations"></p><pre><code class="hljs cpp"><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; a1 = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; a2 = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// elements all have value 0</span>a1 = a2; <span class="hljs-comment">// replaces elements in a1</span>a2 = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// error: cannot assign to an array from a braced list</span></code></pre><pre><code class="hljs cpp"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; names;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; oldstyle;names = oldstyle; <span class="hljs-comment">// error: container types don't match</span><span class="hljs-comment">// ok: can convert from const char*to string</span>names.assign(oldstyle.cbegin(), oldstyle.cend());<span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">slist1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// one element, which is the empty string</span>slist1.assign(<span class="hljs-number">10</span>, <span class="hljs-string">"Hiya!"</span>); <span class="hljs-comment">// ten elements; each one is Hiya !</span></code></pre><p>The swap operation exchanges the contents of two containers of the same type. After the call to swap, the elements in the two containers are interchanged:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// vector with ten elements</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec2</span><span class="hljs-params">(<span class="hljs-number">24</span>)</span></span>; <span class="hljs-comment">// vector with 24 elements</span>swap(svec1, svec2);</code></pre><p>After the swap, <code>svec1</code> contains 24 string elements and <code>svec2</code> contains ten.</p><p>With the exception of arrays, swapping two containers is guaranteed to be fast—the elements themselves are not swapped; internal data structures are swapped.</p><p>Excepting array, swap does not copy, delete, or insert any elements and is guaranteed to run in constant time.</p><p>Unlike how swap behaves for the other containers, swapping two <code>arrays</code> does exchange the elements. As a result, swapping two <code>arrays</code> requires time proportional to the number of elements in the <code>array</code>.</p><h2 id="6-Relational-Operators"><a href="#6-Relational-Operators" class="headerlink" title="(6) Relational Operators"></a>(6) Relational Operators</h2><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span> &#125;;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span> &#125;;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span> &#125;;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v4 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span> &#125;;v1 &lt; v2 <span class="hljs-comment">// true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]</span>v1 &lt; v3 <span class="hljs-comment">// false; all elements are equal, but v3 has fewer of them;</span>v1 == v4 <span class="hljs-comment">// true; each element is equal and v1 and v4 have the same size()</span>v1 == v2 <span class="hljs-comment">// false; v2 has fewer elements than v1</span></code></pre><p>We can use a relational operator to compare two containers only if the appropriate comparison operator is defined for the element type.</p><h1 id="3-Sequential-Container-Operations"><a href="#3-Sequential-Container-Operations" class="headerlink" title="3. Sequential Container Operations"></a>3. Sequential Container Operations</h1><h2 id="1-Adding-Elements-to-a-Sequential-Container"><a href="#1-Adding-Elements-to-a-Sequential-Container" class="headerlink" title="(1) Adding Elements to a Sequential Container"></a>(1) Adding Elements to a Sequential Container</h2><p><img src="_v_images/20210126212834373_2122577171.png" srcset="/img/loading.gif" alt="Operations That Add Elements to a Sequential Container"></p><h3 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h3><p>Aside from <code>array</code> and <code>forward_list</code>, every sequential container (including the <code>string</code> type) supports <code>push_back</code>.</p><pre><code class="hljs cpp"><span class="hljs-comment">// read from standard input, putting each word onto the end of container</span><span class="hljs-built_in">string</span> word;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; word)container.push_back(word);<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pluralize</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> cnt, <span class="hljs-built_in">string</span> &amp;word)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">1</span>)    word.push_back(<span class="hljs-string">'s'</span>); <span class="hljs-comment">// same as word += 's'</span>&#125;</code></pre><p>When we use an object to initialize a container, or insert an object into a container, a copy of that object’s value is placed in the container, not the object itself.</p><h3 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h3><p>In addition to <code>push_back</code>, the <code>list</code>, <code>forward_list</code>, and <code>deque</code> containers support an analogous operation named <code>push_front</code>. This operation inserts a new element at the front of the container:</p><pre><code class="hljs cpp"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; ilist;<span class="hljs-comment">// add elements to the start of ilist</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> ix = <span class="hljs-number">0</span>; ix != <span class="hljs-number">4</span>; ++ix)ilist.push_front(ix);</code></pre><p>This loop adds the elements <code>0, 1, 2, 3</code> to the beginning of <code>ilist</code>. Each element is inserted at the new beginning of the list. </p><p>Thus, the elements added in a loop such as this one wind up in reverse order. After executing this loop, ilist holds the sequence <code>3,2,1,0</code>.</p><p>Note that <code>deque</code>, which like <code>vector</code> offers fast random access to its elements, provides the <code>push_front</code> member even though <code>vector</code> does not. </p><p>A <code>deque</code> guarantees constant-time insert and delete of elements at the beginning and end of the container. As with <code>vector</code>, inserting elements other than at the front or back of a <code>deque</code> is a potentially expensive operation.</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>More generally, the <code>insert</code> members let us insert zero or more elements at any point in the container.</p><p>The <code>insert</code> members are supported for <code>vector</code>, <code>deque</code>, <code>list</code>, and <code>string</code>.</p><p>The arguments to <code>insert</code> that appear after the initial iterator argument are analogous to the container constructors that take the same parameters.</p><pre><code class="hljs cpp">slist.insert(iter, <span class="hljs-string">"Hello!"</span>); <span class="hljs-comment">// insert "Hello!" just before iter</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec;<span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; slist;<span class="hljs-comment">// equivalent to calling slist.push_front("Hello!");</span>slist.insert(slist.begin(), <span class="hljs-string">"Hello!"</span>);<span class="hljs-comment">// no push_front on vector but we can insert before begin()</span><span class="hljs-comment">// warning: inserting anywhere but at the end of a vector might be slow</span>svec.insert(svec.begin(), <span class="hljs-string">"Hello!"</span>);<span class="hljs-comment">//inserts ten elements at the end of svec and </span><span class="hljs-comment">//initializes each of those elements to the string "Anna"</span>svec.insert(svec.end(), <span class="hljs-number">10</span>, <span class="hljs-string">"Anna"</span>);<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; v = &#123;<span class="hljs-string">"quasi"</span>, <span class="hljs-string">"simba"</span>, <span class="hljs-string">"frollo"</span>, <span class="hljs-string">"scar"</span>&#125;;<span class="hljs-comment">// insert the last two elements of v at the beginning of slist</span>slist.insert(slist.begin(), v.end() - <span class="hljs-number">2</span>, v.end());slist.insert(slist.end(), &#123;<span class="hljs-string">"these"</span>, <span class="hljs-string">"words"</span>, <span class="hljs-string">"will"</span>,<span class="hljs-string">"go"</span>, <span class="hljs-string">"at"</span>, <span class="hljs-string">"the"</span>, <span class="hljs-string">"end"</span>&#125;);<span class="hljs-comment">// run-time error: iterators denoting the range to copy from</span><span class="hljs-comment">// must not refer to the same container as the one we are changing</span>slist.insert(slist.begin(), slist.begin(), slist.end());</code></pre><p>We can use the value returned by <code>insert</code> to repeatedly insert elements at a specified position in the container:</p><pre><code class="hljs cpp"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-number">1</span>st;<span class="hljs-keyword">auto</span> iter = <span class="hljs-number">1</span>st.begin();<span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; word)    iter = <span class="hljs-number">1</span>st.insert(iter, word); <span class="hljs-comment">// same as calling push_front</span></code></pre><p>The value returned by <code>insert</code> is an iterator referring to this new element. </p><h3 id="Emplace"><a href="#Emplace" class="headerlink" title="Emplace"></a>Emplace</h3><p>The new standard introduced three new members—<code>emplace_front</code>, <code>emplace</code>, and <code>emplace_back</code>—that construct rather than copy elements. </p><p>These operations correspond to the <code>push_front</code>, <code>insert</code>, and <code>push_back</code> operations in that they let us put an element at the front of the container, in front of a given position, or at the back of the container, respectively.</p><p>When we call a <code>push</code> or <code>insert</code> member, we pass objects of the element type and those objects are copied into the container. </p><p>When we call an <code>emplace</code> member, we pass arguments to a constructor for the element type. </p><p>The <code>emplace</code> members use those arguments to construct an element directly in space managed by the container.</p><p>For example, assuming c holds Sales_data elements:</p><pre><code class="hljs cpp"><span class="hljs-comment">// construct a Sales_data object at the end of c</span><span class="hljs-comment">// uses the three-argument Sales_data constructor</span>c.emplace_back(<span class="hljs-string">"978-0590353403"</span>, <span class="hljs-number">25</span>, <span class="hljs-number">15.99</span>);<span class="hljs-comment">// error: there is no version of push_back that takes three arguments</span>c.push_back(<span class="hljs-string">"978-0590353403"</span>, <span class="hljs-number">25</span>, <span class="hljs-number">15.99</span>);<span class="hljs-comment">// ok: we create a temporary Sales_data object to pass to push_back</span>c.push_back(Sales_data(<span class="hljs-string">"978-0590353403"</span>, <span class="hljs-number">25</span>, <span class="hljs-number">15.99</span>));</code></pre><p>The call to <code>emplace_back</code> and the second call to <code>push_back</code> both create new <code>Sales_data</code> objects. In the call to <code>emplace_back</code>, that object is created directly in space managed by the container. </p><p>The call to <code>push_back</code> creates a local temporary object that is pushed onto the container.</p><p>The arguments to an <code>emplace</code> function vary depending on the element type. The arguments must match a constructor for the element type:</p><pre><code class="hljs cpp"><span class="hljs-comment">// iter refers to an element in c, which holds Sales_data elements</span>c.emplace_back(); <span class="hljs-comment">// uses the Sales_data default constructor</span>c.emplace(iter, <span class="hljs-string">"999-999999999"</span>); <span class="hljs-comment">// uses Sales_data(string)</span><span class="hljs-comment">// uses the Sales_data constructor that takes an ISBN, a count, and a price</span>c.emplace_front(<span class="hljs-string">"978-0590353403"</span>, <span class="hljs-number">25</span>, <span class="hljs-number">15.99</span>);</code></pre><p>The <code>emplace</code> functions construct elements in the container. The arguments to these functions must match a constructor for the element type.</p><h2 id="2-Accessing-Elements"><a href="#2-Accessing-Elements" class="headerlink" title="(2) Accessing Elements"></a>(2) Accessing Elements</h2><p>Each sequential container, including <code>array</code>, has a <code>front</code> member, and all except <code>forward_list</code> also have a <code>back</code> member.<br><img src="_v_images/20210126213217693_1564322431.png" srcset="/img/loading.gif" alt="Operations to Access Elements in a Sequential Container"></p><pre><code class="hljs cpp"><span class="hljs-comment">// check that there are elements before dereferencing </span><span class="hljs-comment">//an iterator or calling front or back</span><span class="hljs-keyword">if</span> (!c.empty()) &#123;    <span class="hljs-comment">// val and val2 are copies of the value of the first element in c</span>    <span class="hljs-keyword">auto</span> val = *c.begin(), val2 = c.front();    <span class="hljs-comment">// val3 and val4 are copies of the of the last element in c</span>    <span class="hljs-keyword">auto</span> last = c.end();    <span class="hljs-keyword">auto</span> val3 = *(--last); <span class="hljs-comment">// can't decrement forward_list iterators</span>    <span class="hljs-keyword">auto</span> val4 = c.back(); <span class="hljs-comment">// not supported by forward_list</span>&#125;</code></pre><p>The members that access elements in a container (i.e., front, back, subscript, and at) return <code>references</code>. </p><p>If the container is a <code>const</code> object, the return is a <code>reference to const</code>. </p><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!c.empty()) &#123;    c.front() = <span class="hljs-number">42</span>; <span class="hljs-comment">// assigns 42 to the first element in c</span>    <span class="hljs-keyword">auto</span> &amp;v = c.back(); <span class="hljs-comment">// get a reference to the last element</span>    v = <span class="hljs-number">1024</span>; <span class="hljs-comment">// changes the element in c</span>    <span class="hljs-keyword">auto</span> v2 = c.back(); <span class="hljs-comment">// v2 is not a reference; it's a copy of c.back()</span>    v2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// no change to the element in c</span>&#125;</code></pre><p>The containers that provide fast random access (string, vector, deque, and array) also provide the subscript operator.</p><p>The <code>subscript</code> operator takes an <code>index</code> and returns a <code>reference</code> to the element at that position in the container. The index must be “in range”.</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec; <span class="hljs-comment">// empty vector</span><span class="hljs-built_in">cout</span> &lt;&lt; svec[<span class="hljs-number">0</span>]; <span class="hljs-comment">// run-time error: there are no elements in svec!</span><span class="hljs-built_in">cout</span> &lt;&lt; svec.at(<span class="hljs-number">0</span>); <span class="hljs-comment">// throws an out_of_range exception</span></code></pre><h2 id="3-Erasing-Elements"><a href="#3-Erasing-Elements" class="headerlink" title="(3) Erasing Elements"></a>(3) Erasing Elements</h2><p>Just as there are several ways to add elements to a (nonarray) container there are also several ways to remove elements.<br><img src="_v_images/20210126213315314_10464409.png" srcset="/img/loading.gif" alt="erase Operations on Sequential Containers"></p><p>The <code>pop_front</code> and <code>pop_back</code> functions remove the first and last elements, respectively. </p><p>Just as there is no <code>push_front</code> for <code>vector</code> and <code>string</code>, there is also no <code>pop_front</code> for those types. Similarly, <code>forward_list</code> does not have <code>pop_back</code>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (!ilist.empty()) &#123;    process(ilist.front()); <span class="hljs-comment">// do something with the current top of ilist</span>    ilist.pop_front(); <span class="hljs-comment">// done; remove the first element</span>&#125;</code></pre><p>The <code>erase</code> members remove element(s) at a specified point in the container. We can delete a single element denoted by an iterator or a range of elements marked by a pair of iterators. Both forms of erase return an iterator referring to the location after the (last) element that was removed. </p><p>That is, if <code>j</code> is the element following <code>i</code>, then <code>erase(i)</code> will return an iterator referring to <code>j</code>.</p><p>As an example, the following loop erases the odd elements in a list:</p><pre><code class="hljs cpp"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; lst = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-keyword">auto</span> it = lst.begin();<span class="hljs-keyword">while</span> (it != lst.end())    <span class="hljs-keyword">if</span> (*it % <span class="hljs-number">2</span>) <span class="hljs-comment">// if the element is odd</span>        it = lst.erase(it); <span class="hljs-comment">// erase this element</span>    <span class="hljs-keyword">else</span>        ++it;</code></pre><p>The iterator-pair version of <code>erase</code> lets us delete a range of elements:</p><pre><code class="hljs cpp"><span class="hljs-comment">// delete the range of elements between two iterators</span><span class="hljs-comment">// returns an iterator to the element just after the last removed element</span>elem1 = slist.erase(elem1, elem2); <span class="hljs-comment">// after the call elem1 == elem2</span></code></pre><p>The iterator <code>elem1</code> refers to the first element we want to erase, and <code>elem2</code> refers to one past the last element we want to remove.</p><p>To delete all the elements in a container, we can either call <code>clear</code> or pass the iterators from <code>begin</code> and <code>end</code> to erase:</p><pre><code class="hljs cpp">slist.clear(); <span class="hljs-comment">// delete all the elements within the container</span>slist.erase(slist.begin(), slist.end()); <span class="hljs-comment">// equivalent</span></code></pre><h2 id="4-Specialized-forward-list-Operations"><a href="#4-Specialized-forward-list-Operations" class="headerlink" title="(4) Specialized forward_list Operations"></a>(4) Specialized forward_list Operations</h2><p>To add or remove an element, we need access to its predecessor in order to update that element’s links.</p><p>However, <code>forward_list</code> is a <strong>singly linked list</strong>. In a singly linked list there is no easy way to get to an element’s predecessor. </p><p>For this reason, the operations to <code>add</code> or <code>remove</code> elements in a <code>forward_list</code> operate by changing the element after the given element. </p><p>That way, we always have access to the elements that are affected by the change.</p><p>Because these operations behave differently from the operations on the other containers, <code>forward_list</code> does not define <code>insert</code>, <code>emplace</code>, or <code>erase</code>. </p><p>Instead it defines members named <code>insert_after</code>, <code>emplace_after</code>, and <code>erase_after</code>. </p><p>To support these operations, <code>forward_list</code> also defines <code>before_begin</code>, which returns an off-the-beginning iterator. This iterator lets us add or remove elements “after” the nonexistent element before the first one in the list.<br><img src="_v_images/20210126213517992_632354886.png" srcset="/img/loading.gif" alt="Operations to Insert or Remove Elements in a forward_list"></p><pre><code class="hljs cpp">forward_list&lt;<span class="hljs-keyword">int</span>&gt; flst = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-keyword">auto</span> prev = flst.before_begin(); <span class="hljs-comment">// denotes element "off the start" of flst</span><span class="hljs-keyword">auto</span> curr = flst.begin(); <span class="hljs-comment">// denotes the first element in flst</span><span class="hljs-keyword">while</span> (curr != flst.end()) &#123; <span class="hljs-comment">// while there are still elements to</span>    process    <span class="hljs-keyword">if</span> (*curr % <span class="hljs-number">2</span>) <span class="hljs-comment">// if the element is odd</span>        curr = flst.erase_after(prev); <span class="hljs-comment">// erase it and move curr</span>    <span class="hljs-keyword">else</span>     &#123;        prev = curr; <span class="hljs-comment">// move the iterators to denote the next</span>        ++curr; <span class="hljs-comment">// element and one before the next element</span>    &#125;&#125;</code></pre><h2 id="5-Resizing-a-Container"><a href="#5-Resizing-a-Container" class="headerlink" title="(5) Resizing a Container"></a>(5) Resizing a Container</h2><p>With the usual exception of <code>arrays</code>, we can use resize, described, to make a container larger or smaller. If the current size is greater than the requested size, elements are deleted from the back of the container; if the current size is less than the new size, elements are added to the back of the container:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ilist</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">42</span>)</span></span>; <span class="hljs-comment">// ten ints: each has value 42</span>ilist.resize(<span class="hljs-number">15</span>); <span class="hljs-comment">// adds five elements of value 0 to the back of ilist</span>ilist.resize(<span class="hljs-number">25</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">// adds ten elements of value -1 to the back of ilist</span>ilist.resize(<span class="hljs-number">5</span>); <span class="hljs-comment">// erases 20 elements from the back of ilist</span></code></pre><h2 id="6-Container-Operations-May-Invalidate-Iterators"><a href="#6-Container-Operations-May-Invalidate-Iterators" class="headerlink" title="(6) Container Operations May Invalidate Iterators"></a>(6) Container Operations May Invalidate Iterators</h2><p>Operations that add or remove elements from a container can invalidate pointers, references, or iterators to container elements. An invalidated pointer, reference, or iterator is one that no longer denotes an element. </p><p>After an operation that adds elements to a container</p><ul><li><p>Iterators, pointers, and references to a vector or string are invalid if the container was reallocated. If no reallocation happens, indirect references to elements before the insertion remain valid; those to elements after the insertion are invalid.</p></li><li><p>Iterators, pointers, and references to a deque are invalid if we add elements anywhere but at the front or back. If we add at the front or back, iterators are invalidated, but references and pointers to existing elements are not.</p></li><li><p>Iterators, pointers, and references (including the off-the-end and the before the beginning iterators) to a list or forward_list remain valid.</p></li></ul><p>It should not be surprising that when we remove elements from a container, iterators, pointers, and references to the removed elements are invalidated. After all, those elements have been destroyed. After we remove an element,</p><ul><li><p>All other iterators, references, or pointers (including the off-the-end and the before the beginning iterators) to a list or forward_list remain valid.</p></li><li><p>All other iterators, references, or pointers to a deque are invalidated if the removed elements are anywhere but the front or back. If we remove elements at the back of the deque, the off-the-end iterator is invalidated but other iterators, references, and pointers are unaffected; they are also unaffected if we remove from the front.</p></li><li><p>All other iterators, references, or pointers to a vector or string remain valid for elements before the removal point. Note: The off-the-end iterator is always invalidated when we remove elements.</p></li></ul><pre><code class="hljs cpp"><span class="hljs-comment">// silly loop to remove even-valued elements and </span><span class="hljs-comment">//insert a duplicate of odd-valued elements</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-keyword">auto</span> iter = vi.begin(); <span class="hljs-keyword">while</span> (iter != vi.end())&#123;    <span class="hljs-keyword">if</span> (*iter % <span class="hljs-number">2</span>)     &#123;        iter = vi.insert(iter, *iter); <span class="hljs-comment">// duplicate the current element</span>        iter += <span class="hljs-number">2</span>; <span class="hljs-comment">// advance past this element and the one inserted before it</span>    &#125;    <span class="hljs-keyword">else</span>        iter = vi.erase(iter);        <span class="hljs-comment">// remove even elements, don't advance the iterator;</span>        <span class="hljs-comment">//iter denotes the element after the one we erased</span>&#125;</code></pre><h1 id="4-How-a-vector-Grows"><a href="#4-How-a-vector-Grows" class="headerlink" title="4. How a vector Grows"></a>4. How a vector Grows</h1><p>To support fast random access, vector elements are stored contiguously—each element is adjacent to the previous element.</p><h2 id="1-Members-to-Manage-Capacity"><a href="#1-Members-to-Manage-Capacity" class="headerlink" title="(1) Members to Manage Capacity"></a>(1) Members to Manage Capacity</h2><p>The <code>capacity</code> operation tells us how many elements the container can hold before it must allocate more space. </p><p>The <code>reserve</code> operation lets us tell the container how many elements it should be prepared to hold.</p><p><code>reserve</code> does not change the number of elements in the container; it affects only how much memory the vector preallocates.</p><p>A call to <code>reserve</code> changes the <code>capacity</code> of the <code>vector</code> only if the requested space exceeds the current capacity. If the requested size is greater than the current <code>capacity</code>, <code>reserve</code> allocates at least as much as (and may allocate more than) the requested amount.</p><p>If the requested size is less than or equal to the existing capacity, <code>reserve</code> does nothing. </p><p>In particular, calling <code>reserve</code> with a size smaller than capacity does not cause the container to give back memory. </p><p>Thus, after calling <code>reserve</code>, the <code>capacity</code> will be greater than or equal to the argument passed to <code>reserve</code>.</p><p>The <code>resize</code> members change only the number of elements in the container, not its capacity. </p><p>We cannot use <code>resize</code> to reduce the memory a container holds in <code>reserve</code>.</p><p>Under the new library, we can call <code>shrink_to_fit</code> to ask a <code>deque</code>, <code>vector</code>, or <code>string</code> to return <strong>unneeded memory</strong>. This function indicates that we no longer need any excess capacity. However, the implementation is free to ignore this request. There is no guarantee that a call to <code>shrink_to_fit</code> will return memory.</p><h2 id="2-capacity-and-size"><a href="#2-capacity-and-size" class="headerlink" title="(2) capacity and size"></a>(2) capacity and size</h2><p>It is important to understand the difference between <code>capacity</code> and <code>size</code>.</p><p>The <code>size</code> of a container is the number of elements it already holds; its <code>capacity</code> is how many elements it can hold before more space must be allocated.</p><p>The following code illustrates the interaction between <code>size</code> and <code>capacity</code>:</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ivec;<span class="hljs-comment">// size should be zero; capacity is implementation defined</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ivec: size: "</span> &lt;&lt; ivec.size()&lt;&lt; <span class="hljs-string">" capacity: "</span> &lt;&lt; ivec.capacity() &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">// give ivec 24 elements</span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::size_type ix = <span class="hljs-number">0</span>; ix != <span class="hljs-number">24</span>; ++ix)    ivec.push_back(ix);    <span class="hljs-comment">// size should be 24;</span>    <span class="hljs-comment">//capacity will be &gt;= 24 and is implementation defined</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ivec: size: "</span> &lt;&lt; ivec.size()&lt;&lt; <span class="hljs-string">" capacity: "</span> &lt;&lt; ivec.capacity() &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><p>The capacity must be at least as large as size but can be larger.</p><pre><code class="hljs cpp"><span class="hljs-comment">// add elements to use up the excess capacity</span><span class="hljs-keyword">while</span> (ivec.size() != ivec.capacity())    ivec.push_back(<span class="hljs-number">0</span>);    <span class="hljs-comment">// capacity should be unchanged and size and capacity are now equal</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ivec: size: "</span> &lt;&lt; ivec.size()&lt;&lt; <span class="hljs-string">" capacity: "</span> &lt;&lt; ivec.capacity() &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><pre><code class="hljs cpp">ivec: size: <span class="hljs-number">50</span> capacity: <span class="hljs-number">50</span></code></pre><p>Because we used only <code>reserved</code> capacity, there is no need for the <code>vector</code> to do any allocation. In fact, as long as no operation exceeds the vector’s <code>capacity</code>, the <code>vector</code> must not reallocate its elements. If we now add another element, the <code>vector</code> will have to reallocate itself:</p><h1 id="5-Additional-string-Operations"><a href="#5-Additional-string-Operations" class="headerlink" title="5. Additional string Operations"></a>5. Additional string Operations</h1><h2 id="1-Other-Ways-to-Construct-strings"><a href="#1-Other-Ways-to-Construct-strings" class="headerlink" title="(1) Other Ways to Construct strings"></a>(1) Other Ways to Construct strings</h2><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp = <span class="hljs-string">"Hello World!!!"</span>; <span class="hljs-comment">// null-terminated array</span><span class="hljs-keyword">char</span> noNull[] = &#123;<span class="hljs-string">'H'</span>, <span class="hljs-string">'i'</span>&#125;; <span class="hljs-comment">// not null terminated</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s1</span><span class="hljs-params">(cp)</span></span>; <span class="hljs-comment">// copy up to the null in cp; s1 == "Hello World!!!"</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s2</span><span class="hljs-params">(noNull,<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// copy two characters from no_null; s2 == "Hi"</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s3</span><span class="hljs-params">(noNull)</span></span>; <span class="hljs-comment">// undefined: noNull not null terminated</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s4</span><span class="hljs-params">(cp + <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span></span>;<span class="hljs-comment">// copy 5 characters starting at cp[6]; s4 == "World"</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s5</span><span class="hljs-params">(s1, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// copy 5 characters starting at s1[6]; s5 == "World"</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s6</span><span class="hljs-params">(s1, <span class="hljs-number">6</span>)</span></span>; <span class="hljs-comment">// copy from s1 [6] to end of s1; s6 == "World!!!"</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s7</span><span class="hljs-params">(s1,<span class="hljs-number">6</span>,<span class="hljs-number">20</span>)</span></span>; <span class="hljs-comment">// ok, copies only to end of s1; s7 == "World!!!"</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s8</span><span class="hljs-params">(s1, <span class="hljs-number">16</span>)</span></span>; <span class="hljs-comment">// throws an out_of_range exception</span></code></pre><p>Ordinarily when we create a string from a <code>const char*</code>, the array to which the pointer points must be null terminated; characters are copied up to the <code>null</code>.</p><p>If we also pass a count, the array does not have to be <code>null</code> terminated. If we do not pass a count and there is no null, or if the given count is greater than the size of the array, the operation is undefined. </p><h2 id="2-The-substr-Operation"><a href="#2-The-substr-Operation" class="headerlink" title="(2) The substr Operation"></a>(2) The substr Operation</h2><p>The substr operation returns a string that is a copy of part or all of the original string. We can pass substr an optional starting position and count:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"hello world"</span>)</span></span>;<span class="hljs-built_in">string</span> s2 = s.substr(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// s2 = hello</span><span class="hljs-built_in">string</span> s3 = s.substr(<span class="hljs-number">6</span>); <span class="hljs-comment">// s3 = world</span><span class="hljs-built_in">string</span> s4 = s.substr(<span class="hljs-number">6</span>, <span class="hljs-number">11</span>); <span class="hljs-comment">// s3 = world</span><span class="hljs-built_in">string</span> s5 = s.substr(<span class="hljs-number">12</span>); <span class="hljs-comment">// throws an out_of_range exception</span></code></pre><h2 id="3-Other-Ways-to-Change-a-string"><a href="#3-Other-Ways-to-Change-a-string" class="headerlink" title="(3) Other Ways to Change a string"></a>(3) Other Ways to Change a string</h2><p>The <code>string</code> type supports the sequential container assignment operators and the assign, insert, and erase operations. </p><p>It also defines additional versions of <code>insert</code> and <code>erase</code>. In addition to the versions of <code>insert</code> and <code>erase</code> that take iterators, string provides versions that take an index. The index indicates the starting element to erase or the position before which to insert the given values:</p><pre><code class="hljs cpp">s.insert(s.size(), <span class="hljs-number">5</span>, <span class="hljs-string">'!'</span>); <span class="hljs-comment">// insert five exclamation points at the end of s</span>s.erase(s.size()- <span class="hljs-number">5</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// erase the last five characters from s</span></code></pre><p>The <code>string</code> library also provides versions of <code>insert</code> and <code>assign</code> that take C-style character arrays. For example, we can use a null-terminated character array as the value to insert or assign into a string:</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp = <span class="hljs-string">"Stately, plump Buck"</span>;s.assign(cp, <span class="hljs-number">7</span>); <span class="hljs-comment">// s == "Stately"</span>s.insert(s.size(), cp + <span class="hljs-number">7</span>); <span class="hljs-comment">// s == "Stately, plump Buck"</span></code></pre><p>When we call <code>insert</code> on <code>s</code>, we say that we want to insert the characters before the (nonexistent) element at <code>s[size()]</code>. In this case, we copy characters starting seven characters past <code>cp</code> up to the terminating <code>null</code>.</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s = <span class="hljs-string">"some string"</span>, s2 = <span class="hljs-string">"some other string"</span>;s.insert(<span class="hljs-number">0</span>, s2); <span class="hljs-comment">// insert a copy of s2 before position 0 in s</span><span class="hljs-comment">// insert s2.size() characters from s2 starting at s2[0] before s[0]</span>s.insert(<span class="hljs-number">0</span>, s2, <span class="hljs-number">0</span>, s2.size());</code></pre><h2 id="4-The-append-and-replace-Functions"><a href="#4-The-append-and-replace-Functions" class="headerlink" title="(4) The append and replace Functions"></a>(4) The append and replace Functions</h2><p><img src="_v_images/20210128235352280_116847066.png" srcset="/img/loading.gif" alt="Operations to Modify strings"><br>The string class defines two additional members, <code>append</code> and <code>replace</code>, that can change the contents of a string. </p><pre><code class="hljs cpp">string s("C++ Primer"), s2 = s; // initialize s and s2 to "C++ Primer"s.insert(s.size(), <span class="hljs-string">" 4th Ed."</span>); <span class="hljs-comment">// s == "C++ Primer 4th Ed."</span>s2.append(<span class="hljs-string">" 4th Ed."</span>); <span class="hljs-comment">// equivalent: appends " 4th Ed." to s2; s == s2</span></code></pre><h2 id="5-The-Many-Overloaded-Ways-to-Change-a-string"><a href="#5-The-Many-Overloaded-Ways-to-Change-a-string" class="headerlink" title="(5) The Many Overloaded Ways to Change a string"></a>(5) The Many Overloaded Ways to Change a string</h2><p>The <code>assign</code> and <code>append</code> functions have no need to specify what part of the string is changed: <code>assign</code> always replaces the entire contents of the string and <code>append</code> always adds to the end of the string.</p><p>The <code>replace</code> functions provide two ways to specify the range of characters to remove. We can specify that range by a position and a length, or with an iterator range. </p><p>The <code>insert</code> functions give us two ways to specify the insertion point: with either an index or an iterator. In each case, the new element(s) are inserted in front of the given index or iterator.</p><p>There are several ways to specify the characters to add to the string. </p><h2 id="6-string-Search-Operations"><a href="#6-string-Search-Operations" class="headerlink" title="(6) string Search Operations"></a>(6) string Search Operations</h2><p><img src="_v_images/20210128235249854_1435608683.png" srcset="/img/loading.gif" alt="string Search Operations"><br>Each of these search operations returns a <code>string::size_type</code> value that is the index of where the match occurred. If there is no match, the function returns a static member named <code>string::npos</code>. The library defines <code>npos</code> as a <code>const string::size_type</code> initialized with the value <code>-1</code>. Because <code>npos</code> is an unsigned type, this initializer means <code>npos</code> is equal to the largest possible size any string could have.</p><p>The string search functions return <code>string::size_type</code>, which is an <code>unsigned type</code>. As a result, it is a bad idea to use an <code>int</code>, or other <code>signed type</code>, to hold the return from these functions.</p><pre><code class="hljs cpp">string numbers("0123456789"), name("r2d2");<span class="hljs-comment">// returns 1, i.e., the index of the first digit in name</span><span class="hljs-keyword">auto</span> pos = name.find_first_of(numbers);<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">dept</span><span class="hljs-params">(<span class="hljs-string">"03714p3"</span>)</span></span>;<span class="hljs-comment">// returns 5, which is the index to the character 'p'</span><span class="hljs-keyword">auto</span> pos = dept.find_first_not_of(numbers);</code></pre><h2 id="7-Specifying-Where-to-Start-the-Search"><a href="#7-Specifying-Where-to-Start-the-Search" class="headerlink" title="(7) Specifying Where to Start the Search"></a>(7) Specifying Where to Start the Search</h2><pre><code class="hljs cpp">string numbers("0123456789"), name("r2d2");<span class="hljs-built_in">string</span>::size_type pos = <span class="hljs-number">0</span>;<span class="hljs-comment">// each iteration finds the next number in name</span><span class="hljs-keyword">while</span> ((pos = name.find_first_of(numbers, pos))!= <span class="hljs-built_in">string</span>::npos) &#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"found number at index: "</span> &lt;&lt; pos    &lt;&lt; <span class="hljs-string">" element is "</span> &lt;&lt; name[pos] &lt;&lt; <span class="hljs-built_in">endl</span>;    ++pos; <span class="hljs-comment">// move to the next character</span>&#125;</code></pre><h2 id="8-Searching-Backward"><a href="#8-Searching-Backward" class="headerlink" title="(8) Searching Backward"></a>(8) Searching Backward</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">river</span><span class="hljs-params">(<span class="hljs-string">"Mississippi"</span>)</span></span>;<span class="hljs-keyword">auto</span> first_pos = river.find(<span class="hljs-string">"is"</span>); <span class="hljs-comment">// returns 1</span><span class="hljs-keyword">auto</span> last_pos = river.rfind(<span class="hljs-string">"is"</span>); <span class="hljs-comment">// returns 4</span></code></pre><p><code>find</code> returns an index of <code>1</code>, indicating the start of the first “is”, while <code>rfind</code> returns an index of <code>4</code>, indicating the start of the last occurrence of “is”.</p><p>Similarly, the <code>find_last</code> functions behave like the <code>find_first</code> functions, except that they return the last match rather than the first:</p><p>Each of these operations takes an optional second argument indicating the position within the string to begin searching.</p><h2 id="9-The-compare-Functions"><a href="#9-The-compare-Functions" class="headerlink" title="(9)  The compare Functions"></a>(9)  The compare Functions</h2><p><img src="_v_images/20210128235157649_949848250.png" srcset="/img/loading.gif" alt="Possible Arguments to s.compare"><br>Like <code>strcmp</code>, <code>s.compare</code> returns zero or a positive or negative value depending on whether s is equal to, greater than, or less than the string formed from the given arguments.</p><h2 id="10-Numeric-Conversions"><a href="#10-Numeric-Conversions" class="headerlink" title="(10) Numeric Conversions"></a>(10) Numeric Conversions</h2><p><img src="_v_images/20210128235115352_1850027266.png" srcset="/img/loading.gif" alt="Conversions between strings and Numbers"><br>The numeric value 15 stored in a 16-bit short has the bit pattern <code>0000000000001111</code>, whereas the character string “15” represented as two Latin-1 chars has the bit pattern <code>0011000100110101</code>. The first byte represents the character ‘1’ which has the octal value <code>061</code>, and the second byte represents <code>&#39;5&#39;</code>, which in Latin-1 is octal <code>065</code>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-built_in">string</span> s = to_string(i); <span class="hljs-comment">// converts the int i to its character representation</span><span class="hljs-keyword">double</span> d = stod(s); <span class="hljs-comment">// converts the string s to floating-point</span><span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"pi = 3.14"</span>;<span class="hljs-comment">// convert the first substring in s that starts with a digit, d = 3.14</span>d = stod(s2.substr(s2.find_first_of(<span class="hljs-string">"+-.0123456789"</span>)));</code></pre><h1 id="6-Container-Adaptors"><a href="#6-Container-Adaptors" class="headerlink" title="6. Container Adaptors"></a>6. Container Adaptors</h1><p>In addition to the sequential containers, the library defines three sequential container adaptors: stack, queue, and priority_queue. </p><p>An adaptor is a general concept in the library. There are container, iterator, and function adaptors. </p><p>Essentially, an adaptor is a mechanism for making one thing act like another. A container adaptor takes an existing container type and makes it act like a different type. </p><p>For example, the stack adaptor takes a sequential container (other than array or forward_list) and makes it operate as if it were a stack.<br><img src="_v_images/20210128235036079_1269482240.png" srcset="/img/loading.gif" alt="Operations and Types Common to the Container Adaptors"></p><p>Each adaptor defines two constructors: the default constructor that creates an empty object, and a constructor that takes a container and initializes the adaptor by copying the given container. </p><p>For example, assuming that <code>deq</code> is a <code>deque&lt;int&gt;</code>, we can use <code>deq</code> to initialize a new stack as follows:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">stk</span><span class="hljs-params">(deq)</span></span>; <span class="hljs-comment">// copies elements from deq into stk</span></code></pre><p>By default both stack and queue are implemented in terms of deque, and a priority_queue is implemented on a vector. We can override the default container type by naming a sequential container as a second type argument when we create the adaptor:</p><pre><code class="hljs cpp"><span class="hljs-comment">// empty stack implemented on top of vector</span><span class="hljs-built_in">stack</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; str_stk;<span class="hljs-comment">// str_stk2 is implemented on top of vector and initially holds a copy of svec</span>stack&lt;string, vector&lt;string&gt;&gt; str_stk2(svec);</code></pre><p>There are constraints on which containers can be used for a given adaptor. All of the adaptors require the ability to add and remove elements. As a result, they cannot be built on an array. </p><p>Similarly, we cannot use forward_list, because all of the adaptors require operations that add, remove, or access the last element in the container. </p><p>A stack requires only push_back, pop_back, and back operations, so we can use any of the remaining container types for a stack. </p><p>The queue adaptor requires back, push_back, front, and push_front, so it can be built on a list or deque but not on a vector. </p><p>A priority_queue requires random access in addition to the front, push_back, and pop_back operations; it can be built on a vector or a deque but not on a list.</p><h2 id="1-Stack-Adaptor"><a href="#1-Stack-Adaptor" class="headerlink" title="(1) Stack Adaptor"></a>(1) Stack Adaptor</h2><p><img src="_v_images/20210128234922527_1314730197.png" srcset="/img/loading.gif" alt="Stack Operations"></p><p>The stack type is defined in the stack header. </p><pre><code class="hljs cpp"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; intStack; <span class="hljs-comment">// empty stack</span><span class="hljs-comment">// fill up the stack</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> ix = <span class="hljs-number">0</span>; ix != <span class="hljs-number">10</span>; ++ix)    intStack.push(ix); <span class="hljs-comment">// intStackholds 0 ... 9 inclusive</span><span class="hljs-keyword">while</span> (!intStack.empty()) &#123;   <span class="hljs-comment">// while there are still values in intStack</span>    <span class="hljs-keyword">int</span> value = intStack.top();    <span class="hljs-comment">// code that uses value </span>    intStack.pop(); <span class="hljs-comment">// pop the top element, and repeat</span>&#125;</code></pre><h2 id="2-The-Queue-Adaptors"><a href="#2-The-Queue-Adaptors" class="headerlink" title="(2) The Queue Adaptors"></a>(2) The Queue Adaptors</h2><p><img src="_v_images/20210128234827329_412291029.png" srcset="/img/loading.gif" alt="queue, priority_queue Operations"><br>The library queue uses a first-in, first-out (FIFO) storage and retrieval policy.</p><p>Objects entering the queue are placed in the back and objects leaving the queue are removed from the front. </p><p>A <code>priority_queue</code> lets us establish a priority among the elements held in the queue. Newly added elements are placed ahead of all the elements with a lower priority. </p><p>A restaurant that seats people according to their reservation time, regardless of when they arrive, is an example of a <code>priority queue</code>. By default, the library uses the <code>&lt;</code> operator on the element type to determine relative priorities. </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The IO Library</title>
    <link href="/2021/01/18/The-IO-Library/"/>
    <url>/2021/01/18/The-IO-Library/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 8 The IO Library</p><a id="more"></a><h1 id="1-The-IO-Classes"><a href="#1-The-IO-Classes" class="headerlink" title="1. The IO Classes"></a>1. The IO Classes</h1><h2 id="1-No-Copy-or-Assign-for-IO-Objects"><a href="#1-No-Copy-or-Assign-for-IO-Objects" class="headerlink" title="(1) No Copy or Assign for IO Objects"></a>(1) No Copy or Assign for IO Objects</h2><p>We cannot copy or assign objects of the IO types:</p><pre><code class="hljs cpp">ofstream out1, out2;out1 = out2; <span class="hljs-comment">// error: cannot assign stream objects</span><span class="hljs-function">ofstream <span class="hljs-title">print</span><span class="hljs-params">(ofstream)</span></span>; <span class="hljs-comment">// error: can't initialize the ofstream parameter</span>out2 = print(out2); <span class="hljs-comment">// error: cannot copy stream objects</span></code></pre><h2 id="2-Condition-States"><a href="#2-Condition-States" class="headerlink" title="(2)  Condition States"></a>(2)  Condition States</h2><p><img src="_v_images/20210118221216970_1707240907.png" srcset="/img/loading.gif" alt=" IO Library Condition State"></p><h2 id="3-Flushing-the-Output-Buffer"><a href="#3-Flushing-the-Output-Buffer" class="headerlink" title="(3) Flushing the Output Buffer"></a>(3) Flushing the Output Buffer</h2><p><code>endl</code> ends the current line and flushes the buffer. </p><p><code>flush</code> flushes the stream but adds no characters to the output.</p><p><code>ends</code> inserts a null character into the buffer and then flushes it.</p><pre><code class="hljs cpp"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"hi!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// writes hi and a newline, then flushes the buffer</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"hi!"</span> &lt;&lt; flush; <span class="hljs-comment">// writes hi, then flushes the buffer; adds no data</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"hi!"</span> &lt;&lt; ends; <span class="hljs-comment">// writes hi and a null, then flushes the buffer</span></code></pre><h2 id="4-The-unitbuf-Manipulator"><a href="#4-The-unitbuf-Manipulator" class="headerlink" title="(4) The unitbuf Manipulator"></a>(4) The unitbuf Manipulator</h2><p>If we want to flush after every output, we can use the <code>unitbuf</code> manipulator. </p><p>This manipulator tells the stream to do a flush after every subsequent write. </p><p>The <code>nounitbuf</code> manipulator restores the stream to use normal, system-managed buffer flushing:</p><pre><code class="hljs cpp"><span class="hljs-built_in">cout</span> &lt;&lt; unitbuf; <span class="hljs-comment">// all writes will be flushed immediately</span><span class="hljs-comment">// any output is flushed immediately, no buffering</span><span class="hljs-built_in">cout</span> &lt;&lt; nounitbuf; <span class="hljs-comment">// returns to normal buffering</span></code></pre><p><strong>Caution:</strong> Buffers Are Not Flushed If the Program Crashes</p><p>Output buffers are not flushed if the program terminates abnormally. </p><p>When a program crashes, it is likely that data the program wrote may be sitting in an output buffer waiting to be printed.</p><p>When you debug a program that has crashed, it is essential to make sure that any output you think should have been written was actually flushed.</p><h1 id="2-File-Input-and-Output"><a href="#2-File-Input-and-Output" class="headerlink" title="2. File Input and Output"></a>2. File Input and Output</h1><p>The fstream header defines three types to support file IO: <code>ifstream</code> to read from a given file, <code>ofstream</code> to write to a given file, and <code>fstream</code>, which reads and writes a given file.<br><img src="_v_images/20210118223957603_227409082.png" srcset="/img/loading.gif" alt=" fstream-Specific Operations"></p><h2 id="1-File-Modes"><a href="#1-File-Modes" class="headerlink" title="(1) File Modes"></a>(1) File Modes</h2><p><img src="_v_images/20210118224422012_1688489982.png" srcset="/img/loading.gif" alt="File Modes"></p><p><code>out</code> may be set only for an ofstream or fstream object.</p><p><code>in</code> may be set only for an ifstream or fstream object.</p><p><code>trunc</code> may be set only when out is also specified.</p><p><code>app</code> mode may be specified so long as trunc is not. If app is specified, the file is always opened in output mode, even if out was not explicitly specified.</p><p>By default, a file opened in <code>out</code> mode is truncated even if we do not specify <code>trunc</code>. </p><p>To preserve the contents of a file opened with <code>out</code>, either we must also specify <code>app</code>, in which case we can write only at the end of the file, or we must also specify <code>in</code>, in which case the file is open for both input and output.</p><p>The <code>ate</code> and <code>binary</code> modes may be specified on any file stream object type and in combination with any other file modes.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Classes</title>
    <link href="/2021/01/15/Classes/"/>
    <url>/2021/01/15/Classes/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 7 Classes</p><a id="more"></a><h1 id="1-Defining-Abstract-Data-Types"><a href="#1-Defining-Abstract-Data-Types" class="headerlink" title="1. Defining Abstract Data Types"></a>1. Defining Abstract Data Types</h1><h2 id="1-Data-abstraction-and-Encapsulation"><a href="#1-Data-abstraction-and-Encapsulation" class="headerlink" title="(1) Data abstraction and Encapsulation"></a>(1) Data abstraction and Encapsulation</h2><p>The fundamental ideas behind <strong>classes</strong> are <strong><font color = blue>data abstraction</strong></font> and <strong><font color = blue>encapsulation</strong></font>.</p><p><strong>Data abstraction</strong> is a programming (and design) technique that relies on the separation of <strong><font color = blue>interface</strong></font> and <strong><font color = blue>implementation</strong></font>. </p><p>The <strong>interface</strong> of a <strong>class</strong> consists of the <strong>operations</strong> that <strong>users of the class</strong> can <strong>execute</strong>. </p><p>The <strong>implementation</strong> includes the <strong>class’data members</strong>, the <strong>bodies of the functions</strong> that <strong>constitute the interface</strong>, and any <strong>functions</strong> needed to <strong>define the class</strong> that are <strong>not intended for general use</strong>.</p><p><strong>Encapsulation enforces the separation of a class’interface and implementation</strong>. </p><p>A class that is encapsulated <strong>hides its implementation</strong>—users of the class can use the interface but have <strong>no access to the implementation</strong>.</p><p>A class that uses <strong>data abstraction</strong> and <strong>encapsulation</strong> defines an <strong><font color = blue>abstract data type</strong></font>. </p><h2 id="2-Difference-between-abstraction-and-encapsulation"><a href="#2-Difference-between-abstraction-and-encapsulation" class="headerlink" title="(2) Difference between abstraction and encapsulation"></a>(2) Difference between abstraction and encapsulation</h2><p><a href="http://www.tonymarston.co.uk/php-mysql/abstraction.txt" target="_blank" rel="noopener">Abstraction, Encapsulation, and Information Hiding</a></p><blockquote><p>If encapsulation was “the same thing as information hiding,” then one might make the argument that “everything that was encapsulated was also hidden.” This is obviously not true. For example, even though information may be encapsulated within record structures and arrays, this information is usually not hidden (unless hidden via some other mechanism).</p></blockquote><blockquote><p>Another example of encapsulated, but not hidden, information is the<br>(highly undesirable) “block of global information” technique reminiscent of FORTRAN’s common blocks. Unfortunately, it is quite easy in some object-oriented languages to create blocks of global data in the form of classes. Specifically, it is possible to create classes with nothing but constants and variables in their public interfaces, i.e., there are no operations in the interface. (For reasons why this is undesirable, see discussions of “module coupling,” e.g., [Myers,1978] and [Yourdon and Constantine, 1979].)</p></blockquote><blockquote><p>It is indeed true that encapsulation mechanisms such as classes allow<br>some information to be hidden. However, these same encapsulation mechanisms also allow some information to be visible. Some even allow<br>varying degrees of visibility, e.g., C++’s public, protected, and private members.</p></blockquote><blockquote><p>One could argue that abstraction is a technique that helps us identify which specific information should be visible, and which information should be hidden. Encapsulation is then the technique for packaging the information in such a way as to hide what should be hidden, and make visible what is intended to be visible.</p></blockquote><h2 id="3-Defining-Member-Functions"><a href="#3-Defining-Member-Functions" class="headerlink" title="(3) Defining Member Functions"></a>(3) Defining Member Functions</h2><p><strong>Member functions</strong> must be <strong>declared</strong> inside the class. </p><p><strong>Member functions</strong> may be <strong>defined</strong> inside the class itself or outside the class body. </p><p><strong>Nonmember functions</strong> that are part of the interface are declared and defined outside the class.</p><p><strong>Functions defined in the class are implicitly inline</strong>.</p><p><strong>Inside a member function</strong>, we can <strong>refer directly</strong> to the members of the object on which the function was called.  </p><p>The <code>this</code> parameter is defined for us <strong>implicitly</strong>. </p><p>It would be legal, although unnecessary, to define <code>isbn</code> as</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;bookNo; &#125;</code></pre><p>Because <code>this</code> is intended to always refer to “this” object, this is a const pointer. We cannot change the address that <code>this</code> holds.</p><h2 id="4-Introducing-const-Member-Functions"><a href="#4-Introducing-const-Member-Functions" class="headerlink" title="(4) Introducing const Member Functions"></a>(4) Introducing const Member Functions</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;</code></pre><p>The purpose of that <code>const</code> is to <strong>modify the type</strong> of the implicit <strong>this</strong> pointer.</p><p>By default, the type of <strong>this</strong> is a <strong>const pointer</strong> to the <strong>nonconst version of the class type</strong>. </p><p>For example, by default, the type of <strong>this</strong> in a <code>Sales_data</code> member function is <code>Sales_data *const</code>. </p><p>Although this is implicit, it follows the normal initialization rules, which means that (by default) <strong>we cannot bind this to a const object</strong>. </p><p>This fact, in turn, means that <strong>we cannot call an ordinary member function on a const object</strong>.</p><p>A <strong>const</strong> following the <strong>parameter list</strong> indicates that <strong>this</strong> is a <strong>pointer to const</strong>. </p><p>Member functions that use <strong>const</strong> in this way are <strong>const member functions</strong>.</p><p>The fact that <strong>this</strong> is a <strong>pointer to const</strong> means that <strong>const member functions cannot change the object on which they are called</strong>.</p><h2 id="5-Class-Scope-and-Member-Functions"><a href="#5-Class-Scope-and-Member-Functions" class="headerlink" title="(5) Class Scope and Member Functions"></a>(5) Class Scope and Member Functions</h2><p>Recall that a class is itself a scope. The definitions of the member functions of a class are nested inside the scope of the class itself. </p><p>The compiler processes classes in two steps—<strong>the member declarations are compiled first</strong>, after which the <strong>member function bodies</strong>, if any, are processed. </p><p>Thus, member function bodies may use other members of their class regardless of where in the class those members appear.</p><h2 id="6-Defining-a-Member-Function-outside-the-Class"><a href="#6-Defining-a-Member-Function-outside-the-Class" class="headerlink" title="(6) Defining a Member Function outside the Class"></a>(6) Defining a Member Function outside the Class</h2><p>The name of a member defined outside the class must include the name of the class of which it is a member:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Sales_data::avg_price</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (units_sold)        <span class="hljs-keyword">return</span> revenue/units_sold;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>The function name, <code>Sales_data::avg_price</code>, uses the <strong>scope operator</strong> to say that we are defining the function named <code>avg_price</code> that is declared <strong>in the scope of the Sales_data class</strong>. </p><p>Once the compiler sees the function name, the rest of the code is interpreted as being inside the scope of the class. </p><h2 id="7-Defining-a-Function-to-Return-“This”-Object"><a href="#7-Defining-a-Function-to-Return-“This”-Object" class="headerlink" title="(7) Defining a Function to Return “This” Object"></a>(7) Defining a Function to Return “This” Object</h2><pre><code class="hljs cpp"><span class="hljs-function">Sales_data&amp; <span class="hljs-title">Sales_data::combine</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data &amp;rhs)</span></span><span class="hljs-function"></span>&#123;    units_sold += rhs.units_sold; <span class="hljs-comment">// add the members of rhs into</span>    revenue += rhs.revenue; <span class="hljs-comment">// the members of ''this'' object</span>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// return the object on which the function was called</span>&#125;</code></pre><p>The <strong>built-in assignment operators</strong> return their <strong>left-hand operand</strong> as an <strong>lvalue</strong>. </p><p>To return an <code>lvalue</code>, our combine function must <strong>return a reference</strong>. </p><p>Because the left-hand operand is a <code>Sales_data</code> object, the return type is <code>Sales_data&amp;</code>.</p><h2 id="8-Defining-Nonmember-Class-Related-Functions"><a href="#8-Defining-Nonmember-Class-Related-Functions" class="headerlink" title="(8)  Defining Nonmember Class-Related Functions"></a>(8)  Defining Nonmember Class-Related Functions</h2><p>Class authors often define auxiliary functions. Although such functions define operations that are conceptually part of the <strong>interface</strong> of the class, they are <strong>not part</strong> of the class itself.</p><p>Functions that are conceptually part of a class, but not defined inside the class, are typically <strong>declared (but not defined)</strong> in the <strong>same header</strong> as the class itself. </p><pre><code class="hljs cpp"><span class="hljs-comment">// input transactions contain ISBN, number of copies sold, and sales price</span><span class="hljs-function">istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(istream &amp;is, Sales_data &amp;item)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> price = <span class="hljs-number">0</span>;    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;    item.revenue = price * item.units_sold;    <span class="hljs-keyword">return</span> is;&#125;<span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-keyword">const</span> Sales_data &amp;item)</span></span><span class="hljs-function"></span>&#123;    os &lt;&lt; item.isbn() &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">" "</span>    &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; item.avg_price();    <span class="hljs-keyword">return</span> os;&#125;</code></pre><p>The <strong>IO classes</strong> are types that <strong>cannot be copied</strong>, so we may <strong>only pass them by reference</strong>.</p><h2 id="9-Constructors"><a href="#9-Constructors" class="headerlink" title="(9) Constructors"></a>(9) Constructors</h2><p>Each class defines how objects of its type can be <strong>initialized</strong>. </p><p>Classes control object initialization by defining one or more special member functions known as <strong><font color = blue>constructors</strong></font>. </p><p>The job of a <strong>constructor</strong> is to initialize the <strong>data members</strong> of a class object. </p><p>A <strong>constructor</strong> is <strong>run</strong> whenever an object of a class type is created.</p><p><strong>Constructors</strong> have the <strong>same name</strong> as the class. </p><p>Unlike other functions, constructors have <strong>no return type</strong>. </p><p>Like other functions, <strong>constructors</strong> have a (possibly empty) <strong>parameter list</strong> and a (possibly empty) function body. </p><p>A class can have <strong>multiple constructors</strong>. </p><p>Like any other overloaded function, the <strong>constructors</strong> must <strong>differ</strong> from each other in the <strong>number or types of their parameters</strong>.</p><p>Unlike other member functions, <strong>constructors may not be declared as const</strong>.<br>When we create a <strong>const</strong> object of a class type, <strong>the object does not assume its “constness” until after the constructor completes the object’s initialization</strong>.</p><p>Thus, <strong>constructors</strong> can write to <strong>const objects</strong> during their construction.</p><h3 id="The-Synthesized-Default-Constructor"><a href="#The-Synthesized-Default-Constructor" class="headerlink" title="The Synthesized Default Constructor"></a>The Synthesized Default Constructor</h3><p>Classes control default initialization by defining a special constructor, known as the <strong>default constructor</strong>. </p><p>The <strong>default constructor</strong> is one that <strong>takes no arguments</strong>.</p><p>If our class does <strong>not explicitly define</strong> any constructors, the compiler will <strong>implicitly</strong> define the default constructor for us.</p><p>The compiler-generated constructor is known as the <strong><font color = blue>synthesized default constructor</strong></font> </p><h3 id="Some-Classes-Cannot-Rely-on-the-Synthesized-Default-Constructor"><a href="#Some-Classes-Cannot-Rely-on-the-Synthesized-Default-Constructor" class="headerlink" title="Some Classes Cannot Rely on the Synthesized Default Constructor"></a>Some Classes Cannot Rely on the Synthesized Default Constructor</h3><ol><li><p>The compiler generates the <strong>default</strong> for us only if we do not define any other constructors for the class.</p></li><li><p>For some classes, the synthesized default constructor does the wrong thing. </p><p> Objects of built-in or compound type (such as arrays and pointers) that are defined inside a block have <strong>undefined value</strong> when they are default initialized.  </p></li></ol><ol start="3"><li><p>Sometimes the compiler is unable to synthesize one. </p><p> For example, if a class has a member that has a class type, and that class doesn’t have a default constructor, then the compiler can’t initialize that member. </p></li></ol><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span> </span><span class="hljs-class">&#123;</span>    <span class="hljs-comment">// constructors added</span>    Sales_data() = <span class="hljs-keyword">default</span>;    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s): bookNo(s) &#123; &#125;    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">unsigned</span> n, <span class="hljs-keyword">double</span> p):    bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;    Sales_data(<span class="hljs-built_in">std</span>::istream &amp;);    <span class="hljs-comment">// other members as before</span>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;    <span class="hljs-function">Sales_data&amp; <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;&#125;;</code></pre><h3 id="What-default-Means"><a href="#What-default-Means" class="headerlink" title="What = default Means"></a>What = default Means</h3><pre><code class="hljs haskell"><span class="hljs-type">Sales_data</span>() = <span class="hljs-keyword">default</span>;</code></pre><p>First, note that this constructor defines the <strong>default constructor</strong> because it takes no arguments. </p><p>We are defining this constructor only because we want to provide other constructors as well as the default constructor. </p><p>If we want the default behavior, we can ask the compiler to generate the constructor for us by writing <strong>=</strong> default after the parameter list.</p><h3 id="Constructor-Initializer-List"><a href="#Constructor-Initializer-List" class="headerlink" title="Constructor Initializer List"></a>Constructor Initializer List</h3><pre><code class="hljs cpp">Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s): bookNo(s) &#123; &#125;Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">unsigned</span> n, <span class="hljs-keyword">double</span> p):bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;</code></pre><p>The new parts in these definitions are the colon and the code between it and the curly braces that define the (empty) function bodies. </p><p>This new part is a <strong>constructor initializer list</strong>, which specifies <strong>initial values</strong> for one or more <strong>data members</strong> of the object being created. </p><p>The <strong>constructor initializer</strong> is a list of member names, each of which is followed by that member’s <strong>initial value</strong> in parentheses (or inside curly braces). </p><p>Multiple member initializations are separated by commas.</p><p>When a member is <strong>omitted</strong> from the constructor <strong>initializer list</strong>, it is <strong>implicitly</strong> initialized using the same process as is used by the <strong>synthesized default constructor</strong>. </p><h3 id="C-11-List-Initialization"><a href="#C-11-List-Initialization" class="headerlink" title="C++11 List Initialization"></a>C++11 List Initialization</h3><blockquote><p>c++ primer plus(6th)</p></blockquote><p><a href="http://eel.is/c++draft/class.base.init#nt:mem-initializer-list" target="_blank" rel="noopener">mem-initializer-list</a></p><p>With C++11, you can use the list-initialization syntax with classes:</p><pre><code class="hljs cpp">Stock hot_tip = &#123;<span class="hljs-string">"Derivatives Plus Plus"</span>, <span class="hljs-number">100</span>, <span class="hljs-number">45.0</span>&#125;;Stock jock &#123;<span class="hljs-string">"Sport Age Storage, Inc"</span>&#125;;Stock temp &#123;&#125;;</code></pre><p>The braced lists in the first two declarations match the following constructor:</p><pre><code class="hljs cpp">Stock::Stock(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp; co, <span class="hljs-keyword">long</span> n = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> pr = <span class="hljs-number">0.0</span>);</code></pre><p>In addition, C++11 offers a class called <code>std::initializer_list</code> that can be used as a<br>type for a function or method parameter.</p><h3 id="Defining-a-Constructor-outside-the-Class-Body"><a href="#Defining-a-Constructor-outside-the-Class-Body" class="headerlink" title="Defining a Constructor outside the Class Body"></a>Defining a Constructor outside the Class Body</h3><pre><code class="hljs cpp">Sales_data::Sales_data(<span class="hljs-built_in">std</span>::istream &amp;is)&#123;    <span class="hljs-comment">// read will read a transaction from is into this object</span>    read(is, *<span class="hljs-keyword">this</span>); &#125;</code></pre><p><code>Sales_data::Sales_data</code> says that we’re defining the <code>Sales_data</code> member named <code>Sales_data</code>. </p><p>This member is a <strong>constructor</strong> because it has the <strong>same name</strong> as its class.</p><p>In this constructor there is no constructor initializer list, although technically speaking, it would be more correct to say that the <strong>constructor initializer list is empty</strong>.</p><p>Even though the constructor initializer list is empty, the members of this object are still initialized <strong>before</strong> the constructor body is executed.</p><h1 id="2-Access-Control-and-Encapsulation"><a href="#2-Access-Control-and-Encapsulation" class="headerlink" title="2. Access Control and Encapsulation"></a>2. Access Control and Encapsulation</h1><p>In C++ we use <strong>access specifiers</strong> to enforce encapsulation:</p><ol><li><p>Members defined after a <strong>public specifier</strong> are accessible to <strong>all parts</strong> of the program. </p><p> The public members define the <strong>interface</strong> to the class.</p></li><li><p>Members defined after a <strong>private specifier</strong> are <strong>accessible</strong> to the <strong>member functions</strong> of the class but are <strong>not accessible</strong> to code that <strong>uses the class</strong>. </p><p> The private sections <strong>encapsulate</strong> (i.e., hide) the <strong>implementation</strong>.</p></li></ol><p>A class may contain <strong>zero or more access specifiers</strong>, and there are <strong>no restrictions</strong> on <strong>how often</strong> an access specifier may appear. </p><p>Each <strong>access specifier</strong> specifies the access level of the <strong>succeeding members</strong>. </p><p>The specified access level remains in effect <strong>until the next access specifier</strong> or the end of the class body.</p><h2 id="1-Using-the-class-or-struct-Keyword"><a href="#1-Using-the-class-or-struct-Keyword" class="headerlink" title="(1) Using the class or struct Keyword"></a>(1) Using the class or struct Keyword</h2><p>The only <strong>difference</strong> between <strong>struct</strong> and <strong>class</strong> is the <strong>default access level</strong>.</p><p>If we use the <strong>struct</strong> keyword, the members defined before the <strong>first access specifier</strong> are <strong>public</strong>; if we use <strong>class</strong>, then the members are <strong>private</strong>.</p><h2 id="2-Friends"><a href="#2-Friends" class="headerlink" title="(2) Friends"></a>(2) Friends</h2><p>A class can allow <strong>another class</strong> or <strong>function</strong> to <strong>access</strong> its <strong>nonpublic members</strong> by making that class or function a <strong><font color = blue>friend</strong></font>. </p><p>A class makes a function its <strong>friend</strong> by including a <strong>declaration</strong> for that function preceded by the keyword <strong>friend</strong>:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span> &#123;</span><span class="hljs-comment">// friend declarations for nonmember Sales_data operations added</span><span class="hljs-function"><span class="hljs-keyword">friend</span> Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;, <span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::istream&amp;, Sales_data&amp;)</span></span>;<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream&amp;, <span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<span class="hljs-comment">// other members and access specifiers as before</span><span class="hljs-keyword">public</span>:Sales_data() = <span class="hljs-keyword">default</span>;Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">unsigned</span> n, <span class="hljs-keyword">double</span> p):bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s): bookNo(s) &#123; &#125;Sales_data(<span class="hljs-built_in">std</span>::istream&amp;);<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<span class="hljs-function">Sales_data &amp;<span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<span class="hljs-keyword">private</span>:<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;<span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;&#125;;<span class="hljs-comment">// declarations for nonmember parts of the Sales_data interface</span><span class="hljs-function">Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;, <span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<span class="hljs-function"><span class="hljs-built_in">std</span>::istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::istream&amp;, Sales_data&amp;)</span></span>;<span class="hljs-function"><span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream&amp;, <span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;</code></pre><p><strong>Friend declarations</strong> may appear only inside a class definition; they may appear anywhere in the class. </p><p><strong>Friends</strong> are not members of the class and are not affected by the access control of the section in which they are declared.</p><h3 id="Declarations-for-Friends"><a href="#Declarations-for-Friends" class="headerlink" title="Declarations for Friends"></a>Declarations for Friends</h3><p><strong>A friend declaration only specifies access</strong>. It is not a general declaration of the function. </p><p>If we want users of the class to be able to call a friend function, then we must also declare the function <strong>separately from the friend declaration</strong>.</p><p>To <strong>make a friend visible</strong> to users of the class, we usually declare each friend (<strong>outside the class</strong>) in the <strong>same header</strong> as the class itself.</p><h3 id="Reasons-for-using-friends"><a href="#Reasons-for-using-friends" class="headerlink" title="Reasons for using friends"></a>Reasons for using friends</h3><blockquote><p>c primer plus(6th)</p></blockquote><p>Friends come in three varieties:</p><ul><li>Friend functions</li><li>Friend classes</li><li>Friend member functions</li></ul><p>Often, overloading a binary operator for a class generates a need for friends. </p><pre><code class="hljs cpp"><span class="hljs-comment">// mytime2.h -- Time class after operator overloading</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MYTIME2_H_</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MYTIME2_H_</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Time</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> hours;    <span class="hljs-keyword">int</span> minutes;    <span class="hljs-keyword">public</span>:    Time();    Time(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>);    Time <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">double</span> n) <span class="hljs-keyword">const</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><pre><code class="hljs cpp"><span class="hljs-comment">// mytime2.cpp -- implementing Time methods</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"mytime2.h"</span></span>Time::Time()&#123;    hours = minutes = <span class="hljs-number">0</span>;&#125;Time::Time(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> m )&#123;    hours = h;    minutes = m;&#125;Time Time::<span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">double</span> mult) <span class="hljs-keyword">const</span>&#123;    Time result;    <span class="hljs-keyword">long</span> totalminutes = hours * mult * <span class="hljs-number">60</span> + minutes * mult;    result.hours = totalminutes / <span class="hljs-number">60</span>;    result.minutes = totalminutes % <span class="hljs-number">60</span>;    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Time::Show</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; hours &lt;&lt; <span class="hljs-string">" hours, "</span> &lt;&lt; minutes &lt;&lt; <span class="hljs-string">" minutes"</span>;&#125;</code></pre><p>The multiplication operator combines a <code>Time</code> value with a double value.This restricts how the operator can be used. Remember, the <strong>left operand is the invoking object</strong>. That is:</p><p><code>A = B * 2.75;</code> translates to the following member function call: <code>A = B.operator*(2.75);</code> But what about the following statement? </p><pre><code class="hljs cpp">A = <span class="hljs-number">2.75</span> * B;` <span class="hljs-comment">// cannot correspond to a member function</span></code></pre><p>Conceptually, <code>2.75 * B</code> should be the same as <code>B * 2.75</code>, but the first expression cannot correspond to a member function because <code>2.75</code> is not a type <code>Time</code> object. </p><p><strong>One way around this difficulty is to use a nonmember function.</strong> (most operators can be overloaded using either member or nonmember functions.)</p><p>A nonmember function is not invoked by an object; instead, any values it uses, including objects, are explicit arguments.Thus, the compiler could match the expression <code>A = 2.75 * B;</code> to the following nonmember function call:</p><pre><code class="hljs cpp">A = <span class="hljs-keyword">operator</span>*(<span class="hljs-number">2.75</span>, B);</code></pre><p>The function would have this prototype:</p><pre><code class="hljs cpp">Time <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">double</span> m, <span class="hljs-keyword">const</span> Time &amp; t);</code></pre><p>Using a <strong>nonmember function</strong> solves the problem of getting the operands in the desired order (first double and then Time), but it raises a new problem: <strong>Nonmember functions</strong> can’t directly access <strong>private data</strong> in a class. </p><p>But there is a special category of nonmember functions, called <strong>friends</strong>, that can access <strong>private members</strong> of a class.</p><h3 id="Creating-Friends"><a href="#Creating-Friends" class="headerlink" title="Creating Friends"></a>Creating Friends</h3><blockquote><p>c primer plus(6th)</p></blockquote><ol><li>Placing a prototype in the class declaration and prefix the declaration with the keyword friend:<pre><code class="hljs cpp"><span class="hljs-comment">// goes in class declaration</span><span class="hljs-keyword">friend</span> Time <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">double</span> m, <span class="hljs-keyword">const</span> Time &amp; t);</code></pre>This prototype has two implications:</li></ol><ul><li><p>Although the <code>operator*()</code> function is declared in the class declaration, it is not a member function. <strong>So it isn’t invoked by using the membership operator</strong>.</p></li><li><p>Although the <code>operator*()</code> function is not a member function, it has the <strong>same access rights</strong> as a member function.</p></li></ul><ol start="2"><li>Writing the <strong>function definition</strong>. Because it is not a member function, you don’t use the <code>Time::</code> qualifier. Also you don’t use the <code>friend</code> keyword in the definition. </li></ol><h3 id="Are-Friends-Unfaithful-to-OOP"><a href="#Are-Friends-Unfaithful-to-OOP" class="headerlink" title="Are Friends Unfaithful to OOP"></a>Are Friends Unfaithful to OOP</h3><blockquote><p>c primer plus(6th)</p></blockquote><p>You should think of <strong>friend</strong> functions as part of an extended interface for a class. </p><p>By using both a friend function and a class method, you can express either operation with the same user interface. </p><p>Only a class declaration can decide which functions are friends, so the class declaration still controls which functions access private data. </p><p>In short, <strong>class methods</strong> and <strong>friends</strong> are simply two different mechanisms for expressing a class interface.</p><p>Actually, you can write this particular <strong>friend function</strong> as a <strong>non-friend</strong> by altering the definition so that it switches which value comes first in the multiplication:</p><pre><code class="hljs pgsql"><span class="hljs-type">Time</span> <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> m, const <span class="hljs-type">Time</span> &amp; t)&#123;    <span class="hljs-keyword">return</span> t * m; // use t.<span class="hljs-keyword">operator</span>*(m)&#125;</code></pre><p>The original version accessed <code>t.minutes</code> and <code>t.hours</code> explicitly, so it had to be a<br><code>friend</code>.</p><p>This version only uses the <code>Time</code> object t <strong>as a whole</strong>, letting a member function handle the private values, so this version doesn’t have to be a <code>friend</code>. </p><p>Nonetheless, there are reasons to make this version a <strong>friend</strong>, too: </p><ol><li><p>It ties the function in as part of the official class interface. </p></li><li><p>If you later find a need for the function to access private data directly, you only have to change the function definition and not the class prototype.</p></li></ol><h3 id="friend-class"><a href="#friend-class" class="headerlink" title="friend class"></a>friend class</h3><blockquote><p>c primer plus(6th)</p></blockquote><p>Any method of the <strong>friend class</strong> can access <strong>private</strong> and <strong>protected</strong> members of the original class.</p><p>Also you can be more restrictive and designate just <strong>particular member functions</strong> of a class to be <strong>friends</strong> to another class.</p><p>Friendship cannot be imposed from the outside. Thus, although friends do grant outside access to a class’s private portion, they don’t really violate the spirit of <strong>object-oriented programming</strong>. Instead, they provide more flexibility to the public interface.</p><p><strong>Example:</strong><br>Suppose you must program a simple simulation of a <code>television</code> and a <code>remote control</code>. </p><p>You decide to define a <code>Tv</code> class representing a <code>television</code> and a <code>Remote</code> class representing a <code>remote control</code>. </p><p>There should be some sort of <strong>relationship</strong> between these classes.</p><p>A <code>remote control</code> is not a <code>television</code> and <code>vice versa</code>, so the <code>is-a</code> relationship of <strong>public inheritance</strong> doesn’t apply. Nor is either a <code>component</code> of the other, so the <code>has-a</code> relationship of <code>containment</code> or of <code>private</code> or <code>protected inheritance</code> doesn’t apply.</p><p>What is true is that a <code>remote</code> control can modify the state of a television, and this suggests making the <code>Remote</code> class a <code>friend</code> to the <code>Tv</code> class.</p><p>A <strong>friend</strong> declaration can appear in a <strong>public</strong>, <strong>private</strong>, or <strong>protected</strong> section; <strong>the location makes no difference</strong>. </p><pre><code class="hljs cpp"><span class="hljs-comment">// tv.h -- Tv and Remote classes</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> TV_H_</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TV_H_</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Remote</span>;</span> <span class="hljs-comment">// Remote can access Tv private parts</span>    <span class="hljs-keyword">enum</span> &#123;Off, On&#125;;    <span class="hljs-keyword">enum</span> &#123;MinVal,MaxVal = <span class="hljs-number">20</span>&#125;;    <span class="hljs-keyword">enum</span> &#123;Antenna, Cable&#125;;    <span class="hljs-keyword">enum</span> &#123;TV, DVD&#125;;    Tv(<span class="hljs-keyword">int</span> s = Off, <span class="hljs-keyword">int</span> mc = <span class="hljs-number">125</span>) : state(s), volume(<span class="hljs-number">5</span>),    maxchannel(mc), channel(<span class="hljs-number">2</span>), mode(Cable), input(TV) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onoff</span><span class="hljs-params">()</span> </span>&#123;state = (state == On)? Off : On;&#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ison</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> state == On;&#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">volup</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">voldown</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chanup</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chandown</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_mode</span><span class="hljs-params">()</span> </span>&#123;mode = (mode == Antenna)? Cable : Antenna;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_input</span><span class="hljs-params">()</span> </span>&#123;input = (input == TV)? DVD : TV;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">settings</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// display all settings</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> state; <span class="hljs-comment">// on or off</span>    <span class="hljs-keyword">int</span> volume; <span class="hljs-comment">// assumed to be digitized</span>    <span class="hljs-keyword">int</span> maxchannel; <span class="hljs-comment">// maximum number of channels</span>    <span class="hljs-keyword">int</span> channel; <span class="hljs-comment">// current channel setting</span>    <span class="hljs-keyword">int</span> mode; <span class="hljs-comment">// broadcast or cable</span>    <span class="hljs-keyword">int</span> input; <span class="hljs-comment">// TV or DVD</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Remote</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> mode; <span class="hljs-comment">// controls TV or DVD</span>    <span class="hljs-keyword">public</span>:    Remote(<span class="hljs-keyword">int</span> m = Tv::TV) : mode(m) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">volup</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; <span class="hljs-keyword">return</span> t.volup();&#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">voldown</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; <span class="hljs-keyword">return</span> t.voldown();&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onoff</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; t.onoff(); &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chanup</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.chanup();&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chandown</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.chandown();&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_chan</span><span class="hljs-params">(Tv &amp; t, <span class="hljs-keyword">int</span> c)</span> </span>&#123;t.channel = c;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_mode</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.set_mode();&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_input</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.set_input();&#125;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><pre><code class="hljs cpp"><span class="hljs-comment">// tv.cpp -- methods for the Tv class (Remote methods are inline)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"tv.h"</span></span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Tv::volup</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (volume &lt; MaxVal)    &#123;        volume++;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Tv::voldown</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (volume &gt; MinVal)    &#123;        volume--;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tv::chanup</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (channel &lt; maxchannel)        channel++;    <span class="hljs-keyword">else</span>        channel = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tv::chandown</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (channel &gt; <span class="hljs-number">1</span>)        channel--;    <span class="hljs-keyword">else</span>        channel = maxchannel;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tv::settings</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>;    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"TV is "</span> &lt;&lt; (state == Off? <span class="hljs-string">"Off"</span> : <span class="hljs-string">"On"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">if</span> (state == On)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Volume setting = "</span> &lt;&lt; volume &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Channel setting = "</span> &lt;&lt; channel &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Mode = "</span>        &lt;&lt; (mode == Antenna? <span class="hljs-string">"antenna"</span> : <span class="hljs-string">"cable"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;        out &lt;&lt; <span class="hljs-string">"Input = "</span>        &lt;&lt; (input == TV? <span class="hljs-string">"TV"</span> : <span class="hljs-string">"DVD"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//use_tv.cpp -- using the Tv and Remote classes</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"tv.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>;    Tv s42;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Initial settings for 42\" TV:\n"</span>;    s42.settings();    s42.onoff();    s42.chanup();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nAdjusted settings for 42\" TV:\n"</span>;    s42.settings();    Remote grey;    grey.set_chan(s42, <span class="hljs-number">10</span>);    grey.volup(s42);    grey.volup(s42);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n42\" settings after using remote:\n"</span>;    s42.settings();    <span class="hljs-function">Tv <span class="hljs-title">s58</span><span class="hljs-params">(Tv::On)</span></span>;    s58.set_mode();    grey.set_chan(s58,<span class="hljs-number">28</span>);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n58\" settings:\n"</span>;    s58.settings();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="Friend-Member-Functions"><a href="#Friend-Member-Functions" class="headerlink" title="Friend Member Functions"></a>Friend Member Functions</h3><blockquote><p>c primer plus(6th)</p></blockquote><p>Looking at the code for the last example, the only <code>Remote</code> method that accesses a <strong>private</strong> <code>Tv</code> member directly is <code>Remote::set_chan()</code>, so that’s the only method that needs to be a <strong>friend</strong>.</p><p>You do have the option of making just <strong>selected class members</strong> <strong>friends</strong> to another class rather than making the <strong>entire class</strong> a <strong>friend</strong>.</p><p><strong>You need to be careful about the order in which you arrange the various declarations and definitions.</strong> </p><p>The way to make <code>Remote::set_chan()</code> a <strong>friend</strong> to the <code>Tv</code> class is to declare it as a <strong>friend</strong> in the <code>Tv</code> class declaration:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remote::set_chan</span><span class="hljs-params">(Tv &amp; t, <span class="hljs-keyword">int</span> c)</span></span>;    ...&#125;;</code></pre><p>However, for the compiler to process this statement, it needs to have already seen the <code>Remote</code> <strong>definition</strong>. Otherwise, it won’t know that <code>Remote</code> is a class and that <code>set_chan()</code> is a method of that class. This suggests putting the <code>Remote</code> <strong>definition</strong> above the <code>Tv</code> definition. But the fact that <code>Remote</code> methods mention <code>Tv</code> objects means that the <code>Tv</code> definition should appear above the <code>Remote</code> definition. Part of the way around the <strong>circular dependence</strong> is to use a <strong>forward declaration</strong>. To do so, you insert the following statement above the <code>Remote</code> definition:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span>;</span> <span class="hljs-comment">// forward declaration</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Remote</span> &#123;</span> ... &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span> &#123;</span> ... &#125;;</code></pre><p>Could you use the following arrangement instead?</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Remote</span>;</span> <span class="hljs-comment">// forward declaration</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span> &#123;</span> ... &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Remote</span> &#123;</span> ... &#125;;</code></pre><p>The answer is no.The reason is that when the compiler sees that a <code>Remote</code> method is declared as a <strong>friend</strong> in the <code>Tv</code> class declaration, the compiler needs to <strong>have already</strong> viewed the <strong>declaration</strong> of the <code>Remote</code> class in general and of the <code>set_chan()</code> method in particular.</p><p>Another difficulty remains. The <code>Remote</code> declaration contains inline code such as the following:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onoff</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; t.onoff(); &#125;</code></pre><p>Because this calls a <code>Tv</code> method, the compiler needs to have seen the <code>Tv</code>class declaration at this point so that it knows what methods <code>Tv</code> has. But as you’ve seen, that declaration necessarily follows the <code>Remote</code> declaration. The solution to this problem is to restrict <code>Remote</code> to method declarations and to <strong>place the actual definitions after the <code>Tv</code> class</strong>. This leads to the following ordering:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span>;</span> <span class="hljs-comment">// forward declaration</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Remote</span> &#123;</span> ... &#125;; <span class="hljs-comment">// Tv-using methods as prototypes only</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span> &#123;</span> ... &#125;; <span class="hljs-comment">// put Remote method definitions here</span></code></pre><p>The Remote prototypes look like this:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onoff</span><span class="hljs-params">(Tv &amp; t)</span></span>;</code></pre><p>All the compiler needs to know when inspecting this prototype is that <code>Tv</code> is a class, and the <strong>forward declaration</strong> supplies that information. </p><p>By the time the compiler reaches the actual <strong>method definitions</strong>, it has already read the <code>Tv</code> class declaration and has the added information needed to compile those methods. By using the inline keyword in the method definitions, you can still make the methods inline methods:</p><pre><code class="hljs cpp"><span class="hljs-comment">// tvfm.h -- Tv and Remote classes using a friend member</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> TVFM_H_</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TVFM_H_</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span>;</span> <span class="hljs-comment">// forward declaration</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Remote</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">enum</span> State&#123;Off, On&#125;;    <span class="hljs-keyword">enum</span> &#123;MinVal,MaxVal = <span class="hljs-number">20</span>&#125;;    <span class="hljs-keyword">enum</span> &#123;Antenna, Cable&#125;;    <span class="hljs-keyword">enum</span> &#123;TV, DVD&#125;;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> mode;<span class="hljs-keyword">public</span>:    Remote(<span class="hljs-keyword">int</span> m = TV) : mode(m) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">volup</span><span class="hljs-params">(Tv &amp; t)</span></span>; <span class="hljs-comment">// prototype only</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">voldown</span><span class="hljs-params">(Tv &amp; t)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onoff</span><span class="hljs-params">(Tv &amp; t)</span> </span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chanup</span><span class="hljs-params">(Tv &amp; t)</span> </span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chandown</span><span class="hljs-params">(Tv &amp; t)</span> </span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_mode</span><span class="hljs-params">(Tv &amp; t)</span> </span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_input</span><span class="hljs-params">(Tv &amp; t)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_chan</span><span class="hljs-params">(Tv &amp; t, <span class="hljs-keyword">int</span> c)</span></span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remote::set_chan</span><span class="hljs-params">(Tv &amp; t, <span class="hljs-keyword">int</span> c)</span></span>;    <span class="hljs-keyword">enum</span> State&#123;Off, On&#125;;    <span class="hljs-keyword">enum</span> &#123;MinVal,MaxVal = <span class="hljs-number">20</span>&#125;;    <span class="hljs-keyword">enum</span> &#123;Antenna, Cable&#125;;    <span class="hljs-keyword">enum</span> &#123;TV, DVD&#125;;    Tv(<span class="hljs-keyword">int</span> s = Off, <span class="hljs-keyword">int</span> mc = <span class="hljs-number">125</span>) : state(s), volume(<span class="hljs-number">5</span>),    maxchannel(mc), channel(<span class="hljs-number">2</span>), mode(Cable), input(TV) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onoff</span><span class="hljs-params">()</span> </span>&#123;state = (state == On)? Off : On;&#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ison</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> state == On;&#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">volup</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">voldown</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chanup</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chandown</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_mode</span><span class="hljs-params">()</span> </span>&#123;mode = (mode == Antenna)? Cable : Antenna;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_input</span><span class="hljs-params">()</span> </span>&#123;input = (input == TV)? DVD : TV;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">settings</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> state;    <span class="hljs-keyword">int</span> volume;    <span class="hljs-keyword">int</span> maxchannel;    <span class="hljs-keyword">int</span> channel;    <span class="hljs-keyword">int</span> mode;    <span class="hljs-keyword">int</span> input;&#125;;<span class="hljs-comment">// Remote methods as inline functions</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Remote::volup</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; <span class="hljs-keyword">return</span> t.volup();&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Remote::voldown</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; <span class="hljs-keyword">return</span> t.voldown();&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remote::onoff</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; t.onoff(); &#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remote::chanup</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.chanup();&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remote::chandown</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.chandown();&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remote::set_mode</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.set_mode();&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remote::set_input</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.set_input();&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remote::set_chan</span><span class="hljs-params">(Tv &amp; t, <span class="hljs-keyword">int</span> c)</span> </span>&#123;t.channel = c;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><h3 id="Shared-Friends"><a href="#Shared-Friends" class="headerlink" title="Shared Friends"></a>Shared Friends</h3><blockquote><p>c primer plus(6th)</p></blockquote><p>Another use for friends is when a function needs to access <strong>private</strong> data in <strong>two separate classes</strong>. </p><p>For example, that you have a <code>Probe</code> class that represents some sort of programmable measuring device and an <code>Analyzer</code> class that represents some sort of programmable analyzing device. Each has an internal clock, and you would like to be able to synchronize the two clocks. You could use something along the following lines:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Analyzer</span>;</span> <span class="hljs-comment">// forward declaration</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Probe</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sync</span><span class="hljs-params">(Analyzer &amp; a, <span class="hljs-keyword">const</span> Probe &amp; p)</span></span>; <span class="hljs-comment">// sync a to p</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sync</span><span class="hljs-params">(Probe &amp; p, <span class="hljs-keyword">const</span> Analyzer &amp; a)</span></span>; <span class="hljs-comment">// sync p to a</span>    ...&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Analyzer</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sync</span><span class="hljs-params">(Analyzer &amp; a, <span class="hljs-keyword">const</span> Probe &amp; p)</span></span>; <span class="hljs-comment">// sync a to p</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sync</span><span class="hljs-params">(Probe &amp; p, <span class="hljs-keyword">const</span> Analyzer &amp; a)</span></span>; <span class="hljs-comment">// sync p to a</span>    ...&#125;;<span class="hljs-comment">// define the friend functions</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sync</span><span class="hljs-params">(Analyzer &amp; a, <span class="hljs-keyword">const</span> Probe &amp; p)</span></span><span class="hljs-function"></span>&#123;    ...&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sync</span><span class="hljs-params">(Probe &amp; p, <span class="hljs-keyword">const</span> Analyzer &amp; a)</span></span><span class="hljs-function"></span>&#123;    ...&#125;</code></pre><p>The <strong>forward declaration</strong> enables the compiler to know that <code>Analyzer</code> is a type when it reaches the <strong>friend</strong> declarations in the <code>Probe</code> class declaration.</p><h1 id="3-Additional-Class-Features"><a href="#3-Additional-Class-Features" class="headerlink" title="3. Additional Class Features"></a>3. Additional Class Features</h1><h2 id="1-Making-Members-inline"><a href="#1-Making-Members-inline" class="headerlink" title="(1) Making Members inline"></a>(1) Making Members inline</h2><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::size_type pos;    <span class="hljs-comment">//using pos = std::string::size_type;</span>    <span class="hljs-comment">// needed because Screen has another constructor</span>    Screen() = <span class="hljs-keyword">default</span>;     <span class="hljs-comment">// cursor initialized to 0 by its in-class initializer</span>    Screen(pos ht, pos wd, <span class="hljs-keyword">char</span> c)    : height(ht), width(wd), contents(ht * wd, c)     &#123; &#125;    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// get the character at the cursor</span></span><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> contents[cursor]; &#125; <span class="hljs-comment">// implicitly inline</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht, pos wd)</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// explicitly inline</span>    <span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>; <span class="hljs-comment">// can be made inline later</span><span class="hljs-keyword">private</span>:    pos cursor = <span class="hljs-number">0</span>;    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> contents;&#125;;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">// we can specify inline on the definition</span><span class="hljs-function"><span class="hljs-keyword">inline</span> Screen &amp;<span class="hljs-title">Screen::move</span><span class="hljs-params">(pos r, pos c)</span></span><span class="hljs-function"></span>&#123;    pos row = r * width; <span class="hljs-comment">// compute the row location</span>    cursor = row + c ; <span class="hljs-comment">// move cursor to the column within that row</span>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// return this object as an lvalue</span>&#125;<span class="hljs-comment">// declared as inline in the class</span><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos r, pos c)</span> <span class="hljs-keyword">const</span> </span><span class="hljs-function"></span>&#123;    pos row = r * width; <span class="hljs-comment">// compute row location</span>    <span class="hljs-keyword">return</span> contents[row + c]; <span class="hljs-comment">// return character at the given column</span>&#125;</code></pre><h2 id="2-mutable-Data-Members"><a href="#2-mutable-Data-Members" class="headerlink" title="(2) mutable Data Members"></a>(2) mutable Data Members</h2><p>A <strong>mutable data member</strong> is never <strong>const</strong>, even when it is a member of a <strong>const</strong> object. </p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-comment">// may change even in a const object</span>    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">size_t</span> access_ctr;     <span class="hljs-comment">// other members as before</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Screen::some_member</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// keep a count of the calls to any member function</span>++access_ctr; &#125;</code></pre><p>Despite the fact that <code>some_member</code> is a <strong>const</strong> member function, it can change the value of <code>access_ctr</code>. </p><h2 id="3-Overloading-Based-on-const"><a href="#3-Overloading-Based-on-const" class="headerlink" title="(3) Overloading Based on const"></a>(3) Overloading Based on const</h2><p>We can overload a member function based on whether it is <strong>const</strong> for the same reasons that <strong>we can overload a function based on whether a pointer parameter points to const</strong>.</p><p>The <strong>nonconst</strong> version will not be viable for <strong>const</strong> objects;</p><p>we can only call <strong>const</strong> member functions on a <strong>const</strong> object. We can call either version on a <strong>nonconst</strong> object, but the <strong>nonconst</strong> version will be a better match.</p><h2 id="4-Class-Types"><a href="#4-Class-Types" class="headerlink" title="(4) Class Types"></a>(4) Class Types</h2><p>Every class defines a unique type. Two different classes define two different types even if they define the same members. </p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">First</span> &#123;</span><span class="hljs-keyword">int</span> memi;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMem</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Second</span> &#123;</span><span class="hljs-keyword">int</span> memi;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMem</span><span class="hljs-params">()</span></span>;&#125;;First obj1;Second obj2 = obj1; <span class="hljs-comment">// error: obj1 and obj2 have different types</span></code></pre><p>We can <strong>refer to a class type directly</strong>, by using the class name as a type name.</p><p>Alternatively, we can <strong>use the class name following the keyword class or struct</strong>:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span> &#123;</span>&#125;;Sales_data item1; <span class="hljs-comment">// default-initialized object of type Sales_data</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span> <span class="hljs-title">item1</span>;</span> <span class="hljs-comment">// equivalent declaration</span></code></pre><p>Both methods of referring to a class type are equivalent. The second method is inherited from C and is also valid in C++.</p><h3 id="Class-Declarations"><a href="#Class-Declarations" class="headerlink" title="Class Declarations"></a>Class Declarations</h3><p>Just as we can declare a function apart from its definition, we can also declare a class without defining it:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span>;</span> <span class="hljs-comment">// declaration of the Screen class</span></code></pre><p>This declaration, sometimes referred to as a <strong>forward declaration</strong>, introduces the name <code>Screen</code> into the program and indicates that <code>Screen</code> refers to a class type.</p><p><strong>After a declaration and before a definition is seen</strong>, the type <code>Screen</code> is an incomplete type-it’s <strong>known</strong> that <code>Screen</code> is a class type but <strong>not known</strong> what members that type contains.</p><p>A <strong>class must be defined—not just declared</strong>—before we can write code that creates objects of that type. </p><p>Otherwise, the compiler does not know <strong>how much storage</strong> such objects need. </p><p>Similarly, the class <strong>must be defined before a reference or pointer is used</strong> to access a member of the type. After all, <strong>if the class has not been defined, the compiler can’t know what members the class has.</strong></p><p><strong>Because a class is not defined until its class body is complete, a class cannot have data members of its own type.</strong></p><p>However, <strong>a class is considered declared (but not yet defined) as soon as its class name has been seen</strong>. </p><p>Therefore, <strong>a class can have data members that are pointers or references to its own type</strong>:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Link_screen</span> &#123;</span>Screen window;Link_screen *next;Link_screen *prev;&#125;;</code></pre><p><a href="http://eel.is/c++draft/class.pre#2" target="_blank" rel="noopener">A class is considered defined after the closing brace of its class-specifier has been seen even though its member functions are in general not yet defined.</a></p><h1 id="4-Class-Scope"><a href="#4-Class-Scope" class="headerlink" title="4. Class Scope"></a>4. Class Scope</h1><h2 id="1-Scope-and-Members-Defined-outside-the-Class"><a href="#1-Scope-and-Members-Defined-outside-the-Class" class="headerlink" title="(1) Scope and Members Defined outside the Class"></a>(1) Scope and Members Defined outside the Class</h2><p>Once the class name is seen, the remainder of the definition—including the parameter list and the function body—is in the scope of the class. </p><p>As a result, we can refer to other class members without qualification.</p><p>The other hand, the return type of a function normally appears before the function’s name. </p><p>When a member function is defined outside the class body, any name used in the return type is outside the class scope. </p><p>As a result, the <strong>return type must specify the class of which it is a member</strong>. </p><h2 id="2-Name-Lookup-and-Class-Scope"><a href="#2-Name-Lookup-and-Class-Scope" class="headerlink" title="(2) Name Lookup and Class Scope"></a>(2) Name Lookup and Class Scope</h2><h3 id="name-lookup"><a href="#name-lookup" class="headerlink" title="name lookup"></a>name lookup</h3><p>The process of finding which declarations match the use of a name.</p><ol><li>Look for a declaration of the name in the block in which the name was used. Only names declared before the use are considered.</li><li>If the name isn’t found, look in the enclosing scope(s).</li><li>If no declaration is found, then the program is in error.</li></ol><p>The way names are resolved inside <strong>member functions</strong> defined inside the class may seem to behave <strong>differently</strong> than these lookup rules. </p><p>However, in this case, appearances are deceiving. </p><p>Class definitions are processed in two phases:</p><ol><li>First, the <strong>member declarations</strong> are compiled.</li><li><strong>Function bodies</strong> are compiled only <strong>after the entire class has been seen</strong>.</li></ol><p>Because <strong>member function bodies</strong> are not processed until the entire class is seen, <strong>they can use any name defined inside the class</strong>. </p><p>If function definitions were processed at the same time as the member declarations, then we would have to order the member functions so that they referred only to names already seen.</p><p><strong>This two-step process applies only to names used in the body of a member function.</strong></p><p>Names used in declarations, including names used for the <strong>return type</strong> and types in the <strong>parameter list</strong>, must be seen before they are used. </p><p>If a member declaration uses a name that has not yet been seen inside the class, the compiler will look for that name in the scope(s) in which the class is defined. </p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> Money;<span class="hljs-built_in">string</span> bal;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">Money <span class="hljs-title">balance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> bal; &#125;<span class="hljs-keyword">private</span>:    Money bal;    <span class="hljs-comment">// ...</span>&#125;;</code></pre><p>When the compiler sees the <strong>declaration</strong> of the <code>balance</code> function, it will look for a <strong>declaration</strong> of <code>Money</code> in the <code>Account</code> class. The compiler considers only declarations inside <code>Account</code> that <strong>appear before the use of Money</strong>. </p><p>Because no matching member is found, the compiler then <strong>looks for a declaration in the enclosing scope(s)</strong>. In this example, the compiler will find the <code>typedef</code> of <code>Money</code>. That type will be used for the <strong>return type</strong> of the function <code>balance</code> and as the type for the data member <code>bal</code>. </p><p>On the other hand, <strong>the function body</strong> of <code>balance</code> is processed only after the entire class is seen. Thus, the return inside that function returns the member named <code>bal</code>, not the <code>string</code> from the outer scope.</p><h3 id="Normal-Block-Scope-Name-Lookup-inside-Member-Definitions"><a href="#Normal-Block-Scope-Name-Lookup-inside-Member-Definitions" class="headerlink" title="Normal Block-Scope Name Lookup inside Member Definitions"></a>Normal Block-Scope Name Lookup inside Member Definitions</h3><p>A name used in the body of a member function is resolved as follows:</p><ol><li>First, look for a declaration of the name <strong>inside the member function</strong>. As usual, only declarations in the function body that precede the use of the name are considered.</li><li>If the declaration is not found inside the member function, look for a declaration <strong>inside the class</strong>. <strong>All the members of the class are considered</strong>.</li><li>If a declaration for the name is not found in the class, look for a declaration that is <strong>in scope before the member function definition</strong>.</li></ol><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment"> note: this code is for illustration purposes only</span><span class="hljs-comment"> and reflects bad practice</span><span class="hljs-comment"> it is generally a bad idea to use the same name</span><span class="hljs-comment"> for a parameter and a member</span><span class="hljs-comment">*/</span><span class="hljs-keyword">int</span> height; <span class="hljs-comment">// defines a name subsequently used inside Screen</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::size_type pos;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dummy_fcn</span><span class="hljs-params">(pos height)</span> </span>&#123;    cursor = width * height; <span class="hljs-comment">// which height? the parameter</span>    &#125;<span class="hljs-keyword">private</span>:    pos cursor = <span class="hljs-number">0</span>;    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;&#125;;</code></pre><p>In this case, the <code>height</code> parameter hides the member named <code>height</code>. If we wanted to override the normal lookup rules, we can do so:</p><pre><code class="hljs cpp"><span class="hljs-comment">// bad practice: names local to member functions</span><span class="hljs-comment">// shouldn't hide member names</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Screen::dummy_fcn</span><span class="hljs-params">(pos height)</span> </span>&#123;    cursor = width * <span class="hljs-keyword">this</span>-&gt;height; <span class="hljs-comment">// member height</span>    <span class="hljs-comment">// alternative way to indicate the member</span>    cursor = width * Screen::height; <span class="hljs-comment">// member height</span>&#125;</code></pre><h3 id="After-Class-Scope-Look-in-the-Surrounding-Scope"><a href="#After-Class-Scope-Look-in-the-Surrounding-Scope" class="headerlink" title="After Class Scope, Look in the Surrounding Scope"></a>After Class Scope, Look in the Surrounding Scope</h3><p>If the compiler doesn’t find the name in function or class scope, it looks for the name in the <strong>surrounding scope</strong>. </p><p>If we want the name <code>height</code> from the outer scope, we can ask for it explicitly using the scope operator:</p><pre><code class="hljs cpp"><span class="hljs-comment">// bad practice: don't hide names </span><span class="hljs-comment">// that are needed from surrounding scopes</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Screen::dummy_fcn</span><span class="hljs-params">(pos height)</span> </span>&#123;    cursor = width * ::height;<span class="hljs-comment">// which height? the global one</span>&#125;</code></pre><p>Even though the outer object is hidden, it is still possible to access that object by using the <strong>scope operator</strong>.</p><h3 id="Names-Are-Resolved-Where-They-Appear-within-a-File"><a href="#Names-Are-Resolved-Where-They-Appear-within-a-File" class="headerlink" title="Names Are Resolved Where They Appear within a File"></a>Names Are Resolved Where They Appear within a File</h3><p>When a member is defined outside its class, the <strong>third step</strong> of <strong>name lookup</strong> includes names declared in the scope of the member definition as well as those that appear in the scope of the class definition. For example:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> height; <span class="hljs-comment">// defines a name subsequently used inside Screen</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::size_type pos;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(pos)</span></span>;    pos height = <span class="hljs-number">0</span>; <span class="hljs-comment">// hides the declaration of height in the outer scope</span>&#125;;<span class="hljs-function">Screen::pos <span class="hljs-title">verify</span><span class="hljs-params">(Screen::pos)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Screen::setHeight</span><span class="hljs-params">(pos var)</span> </span>&#123;    <span class="hljs-comment">// var: refers to the parameter</span>    <span class="hljs-comment">// height: refers to the class member</span>    <span class="hljs-comment">// verify: refers to the global function</span>    height = verify(var);&#125;</code></pre><p>Notice that the declaration of the global function <code>verify</code> is not visible before the definition of the class Screen. </p><p>However, the third step of <strong>name lookup</strong> includes the scope in which the member definition appears. </p><p>In this example, the declaration for <code>verify</code> appears before <code>setHeight</code> is defined and may, therefore, be used.</p><h3 id="Type-Names-Are-Special"><a href="#Type-Names-Are-Special" class="headerlink" title="Type Names Are Special"></a>Type Names Are Special</h3><p>Ordinarily, an inner scope can <strong>redefine a name</strong> from an outer scope even if that name has already been used in the inner scope. </p><p>However, in a class, if a member uses a name from an outer scope and that name is a <strong>type</strong>, then the class may not subsequently redefine that name:</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> Money;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">Money <span class="hljs-title">balance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> bal; &#125; <span class="hljs-comment">// uses Money from the outer scope</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> Money; <span class="hljs-comment">// error: cannot redefine Money</span>    Money bal;    <span class="hljs-comment">// ...</span>&#125;;</code></pre><p><strong>Definitions of type names</strong> usually should appear at the <strong>beginning</strong> of a class.</p><p>That way any member that uses that type will be seen after the type name has already been defined.</p><h1 id="5-Constructors"><a href="#5-Constructors" class="headerlink" title="5.  Constructors"></a>5.  Constructors</h1><h2 id="1-Constructor-Initializer-List"><a href="#1-Constructor-Initializer-List" class="headerlink" title="(1) Constructor Initializer List"></a>(1) Constructor Initializer List</h2><p>When we define variables, we typically <strong>initialize them immediately</strong> rather than defining them and then assigning to them:</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> foo = <span class="hljs-string">"Hello World!"</span>; <span class="hljs-comment">// define and initialize</span><span class="hljs-built_in">string</span> bar; <span class="hljs-comment">// default initialized to the empty string</span>bar = <span class="hljs-string">"Hello World!"</span>; <span class="hljs-comment">// assign a new value to bar</span></code></pre><p>If we do not explicitly initialize a member in the <strong>constructor initializer list</strong>, that member is <strong>default initialized</strong> before the constructor body starts executing. </p><h3 id="Constructor-Initializers-Are-Sometimes-Required"><a href="#Constructor-Initializers-Are-Sometimes-Required" class="headerlink" title="Constructor Initializers Are Sometimes Required"></a>Constructor Initializers Are Sometimes Required</h3><p>We can often, but not always, ignore the distinction between whether a member is <strong>initialized</strong> or <strong>assigned</strong>. </p><p>Members that are <strong>const or references</strong> <strong>must be initialized</strong>.</p><p>Similarly, members that are of a <strong>class</strong> type that does not define a default constructor also <strong>must be initialized</strong>. </p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstRef</span> &#123;</span><span class="hljs-keyword">public</span>:    ConstRef(<span class="hljs-keyword">int</span> ii);<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci;    <span class="hljs-keyword">int</span> &amp;ri;&#125;;</code></pre><p>Like any other <strong>const object</strong> or <strong>reference</strong>, the members <code>ci</code> and <code>ri</code> must be initialized.</p><p>As a result, omitting a constructor initializer for these members is an error:</p><pre><code class="hljs cpp"><span class="hljs-comment">// error: ci and ri must be initialized</span>ConstRef::ConstRef(<span class="hljs-keyword">int</span> ii)&#123;   <span class="hljs-comment">// assignments:</span>    i = ii; <span class="hljs-comment">// ok</span>    ci = ii; <span class="hljs-comment">// error: cannot assign to a const</span>    ri = i; <span class="hljs-comment">// error: ri was never initialized</span>&#125;</code></pre><p>By the time the body of the constructor begins executing, initialization is complete.</p><p>Our only chance to initialize const or reference data members is in the constructor initializer. The correct way to write this constructor is：</p><pre><code class="hljs cpp"><span class="hljs-comment">// ok: explicitly initialize reference and const members</span>ConstRef::ConstRef(<span class="hljs-keyword">int</span> ii): i(ii), ci(ii), ri(i) &#123; &#125;</code></pre><h3 id="Order-of-Member-Initialization"><a href="#Order-of-Member-Initialization" class="headerlink" title="Order of Member Initialization"></a>Order of Member Initialization</h3><p>Members are initialized in the order in which <strong>they appear in the class definition</strong>: The first member is initialized first, then the next, and so on. </p><p><strong>The order in which initializers appear in the constructor initializer list does not change the order of initialization.</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> &#123;</span>    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">int</span> j;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">// undefined: i is initialized before j</span>    X(<span class="hljs-keyword">int</span> val): j(val), i(j) &#123; &#125;&#125;;</code></pre><p><strong>Note:</strong><br>It is a good idea to write constructor initializers in the <strong>same order</strong> as the members are declared. </p><p>Moreover, when possible, <strong>avoid using members to initialize other members</strong>.</p><h2 id="2-Delegating-Constructors"><a href="#2-Delegating-Constructors" class="headerlink" title="(2) Delegating Constructors"></a>(2) Delegating Constructors</h2><p>A <strong>delegating constructor</strong> uses another constructor from its own class to perform its initialization. </p><p>In a <strong>delegating constructor</strong>, the <strong>member initializer list</strong> has a single entry that is the name of the class itself. </p><p>Like other member initializers, the name of the class is followed by a parenthesized list of arguments. </p><p>The argument list must match another constructor in the class.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">// nondelegating constructor initializes members from  corresponding arguments</span>    Sales_data(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">unsigned</span> cnt, <span class="hljs-keyword">double</span> price):    bookNo(s), units_sold(cnt), revenue(cnt*price) &#123;    &#125;    <span class="hljs-comment">// remaining constructors all delegate to another constructor</span>    Sales_data(): Sales_data(<span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123;&#125;    Sales_data(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s): Sales_data(s, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>) &#123;&#125;    Sales_data(<span class="hljs-built_in">std</span>::istream &amp;is): Sales_data()    &#123; read(is, *<span class="hljs-keyword">this</span>); &#125;    <span class="hljs-comment">// other members as before</span>&#125;;</code></pre><h2 id="3-The-Role-of-the-Default-Constructor"><a href="#3-The-Role-of-the-Default-Constructor" class="headerlink" title="(3) The Role of the Default Constructor"></a>(3) The Role of the Default Constructor</h2><p>The <strong>default constructor</strong> is used <strong>automatically</strong> whenever an object is default or value initialized. </p><p><strong>Default initialization</strong> happens:</p><ul><li><p>When we define <strong>nonstatic variables or arrays</strong> at block scope without initializers.</p></li><li><p>When a class that itself has members of class type uses the synthesized default constructor.</p></li><li><p>When members of class type are not <strong>explicitly initialized</strong> in a constructor initializer list. </p></li></ul><p>Value initialization happens:</p><ul><li><p>During array initialization when we provide fewer initializers than the size of the array.</p></li><li><p>When we define a local static object without an initializer.</p></li><li><p>When we explicitly request value initialization by writing an expressions of the form T() where T is the name of a type (The vector constructor that takes a single argument to specify the vector’s size uses an argument of this kind to value initialize its element initializer.) </p></li></ul><h2 id="4-Using-the-Default-Constructor"><a href="#4-Using-the-Default-Constructor" class="headerlink" title="(4) Using the Default Constructor"></a>(4) Using the Default Constructor</h2><p>It is a common mistake among programmers new to C++ to try to declare an object initialized with the default constructor as follows:</p><pre><code class="hljs cpp"><span class="hljs-function">Sales_data <span class="hljs-title">obj</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// oops! declares a function, not an object</span>Sales_data obj2; <span class="hljs-comment">// ok: obj2 is an object, not a function</span></code></pre><h2 id="5-Implicit-Class-Type-Conversions"><a href="#5-Implicit-Class-Type-Conversions" class="headerlink" title="(5) Implicit Class-Type Conversions"></a>(5) Implicit Class-Type Conversions</h2><p>Every constructor that can be called with a <font color = red>single argument</font> defines an <strong>implicit conversion</strong> to a class type. </p><p>Such constructors are sometimes referred to as <strong>converting constructors</strong>. </p><p>The <code>Sales_data</code> constructors that take a string and that take an <code>istream</code> both define implicit conversions from those types to <code>Sales_data</code>. </p><p>That is, we can use a string or an <code>istream</code> where an object of type <code>Sales_data</code> is expected:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span> &#123;</span>    <span class="hljs-comment">// constructors added</span>    Sales_data() = <span class="hljs-keyword">default</span>;    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s): bookNo(s) &#123; &#125;    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">unsigned</span> n, <span class="hljs-keyword">double</span> p):    bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;    Sales_data(<span class="hljs-built_in">std</span>::istream &amp;);    <span class="hljs-comment">// other members as before</span>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;    <span class="hljs-function">Sales_data&amp; <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;&#125;;Sales_data item;<span class="hljs-built_in">string</span> null_book = <span class="hljs-string">"9-999-99999-9"</span>;<span class="hljs-comment">// constructs a temporary Sales_data object</span><span class="hljs-comment">// with units_sold and revenue equal to 0 and bookNo equal to null_book</span>item.combine(null_book);</code></pre><p>The compiler automatically creates a <code>Sales_data</code> object from the given string. </p><p>That newly generated (temporary) <code>Sales_data</code> is passed to combine. </p><h2 id="6-Only-One-Class-Type-Conversion-Is-Allowed"><a href="#6-Only-One-Class-Type-Conversion-Is-Allowed" class="headerlink" title="(6) Only One Class-Type Conversion Is Allowed"></a>(6) Only One Class-Type Conversion Is Allowed</h2><p>The compiler will automatically apply <strong>only one class-type</strong> conversion. </p><p>For example, the following code is in error because it implicitly uses two conversions:</p><pre><code class="hljs cpp"><span class="hljs-comment">// error: requires two user-defined conversions:</span><span class="hljs-comment">// (1) convert "9-999-99999-9" to string</span><span class="hljs-comment">// (2) convert that (temporary) string to Sales_data</span>item.combine(<span class="hljs-string">"9-999-99999-9"</span>);</code></pre><p>If we wanted to make this call, we can do so by <strong>explicitly</strong> converting the character string to either a string or a <code>Sales_data</code> object:</p><pre><code class="hljs cpp"><span class="hljs-comment">// ok: explicit conversion to string, implicit conversion to Sales_data</span>item.combine(<span class="hljs-built_in">string</span>(<span class="hljs-string">"9-999-99999-9"</span>));<span class="hljs-comment">// ok: implicit conversion to string, explicit conversion to Sales_data</span>item.combine(Sales_data(<span class="hljs-string">"9-999-99999-9"</span>));</code></pre><h2 id="7-Class-Type-Conversions-Are-Not-Always-Useful"><a href="#7-Class-Type-Conversions-Are-Not-Always-Useful" class="headerlink" title="(7) Class-Type Conversions Are Not Always Useful"></a>(7) Class-Type Conversions Are Not Always Useful</h2><pre><code class="hljs cpp"><span class="hljs-comment">// uses the istream constructor to build an object to pass to combine</span>item.combine(<span class="hljs-built_in">cin</span>);</code></pre><p>This code implicitly converts <code>cin</code> to <code>Sales_data</code>. </p><p>This conversion executes the <code>Sales_data</code> constructor that takes an <code>istream</code>. That constructor creates a (temporary) <code>Sales_data</code> object by reading the standard input. That object is then passed to combine.</p><p>This <code>Sales_data</code> object is a temporary. We have <strong>no access to it</strong> once combine finishes. Effectively, we have constructed an object that is discarded after we add its value into item.</p><h2 id="8-Suppressing-Implicit-Conversions-Defined-by-Constructors"><a href="#8-Suppressing-Implicit-Conversions-Defined-by-Constructors" class="headerlink" title="(8) Suppressing Implicit Conversions Defined by Constructors"></a>(8) Suppressing Implicit Conversions Defined by Constructors</h2><p>We can <strong>prevent</strong> the use of a constructor in a context that requires an implicit conversion by declaring the constructor as <strong>explicit</strong>:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span> &#123;</span><span class="hljs-keyword">public</span>:    Sales_data() = <span class="hljs-keyword">default</span>;    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">unsigned</span> n, <span class="hljs-keyword">double</span> p):    bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Sales_data</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s)</span>: <span class="hljs-title">bookNo</span><span class="hljs-params">(s)</span> </span>&#123; &#125;    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Sales_data</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::istream&amp;)</span></span>;    <span class="hljs-comment">// remaining members as before</span>&#125;;</code></pre><p>Now, neither constructor can be used to implicitly create a <code>Sales_data</code> object.</p><p>Neither of our previous uses will compile:</p><pre><code class="hljs cpp">item.combine(null_book); <span class="hljs-comment">// error: string constructor is explicit</span>item.combine(<span class="hljs-built_in">cin</span>); <span class="hljs-comment">// error: istream constructor is explicit</span></code></pre><p>The <code>explicit</code> keyword is meaningful only on constructors that can be called with a <strong>single argument</strong>.</p><p>Constructors that require <strong>more arguments</strong> are <strong>not used to perform an implicit conversion</strong>, so there is no need to designate such constructors as <code>explicit</code>. </p><p>The <code>explicit</code> keyword is used <strong>only on the constructor declaration inside the class</strong>. It is not repeated on a <strong>definition</strong> made outside the class body:</p><pre><code class="hljs cpp"><span class="hljs-comment">// error: explicit allowed only on a constructor declaration in a class header</span><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Sales_data::Sales_data</span><span class="hljs-params">(istream&amp; is)</span></span><span class="hljs-function"></span>&#123;    read(is, *<span class="hljs-keyword">this</span>);&#125;</code></pre><h2 id="9-explicit-Constructors-Can-Be-Used-Only-for-Direct-Initialization"><a href="#9-explicit-Constructors-Can-Be-Used-Only-for-Direct-Initialization" class="headerlink" title="(9)explicit Constructors Can Be Used Only for Direct Initialization"></a>(9)explicit Constructors Can Be Used Only for Direct Initialization</h2><p>One context in which <strong>implicit conversions</strong> happen is when we use the <strong>copy form of initialization</strong> (with an =). </p><p>We <strong>cannot</strong> use an <strong>explicit constructor</strong> with this form of initialization; we must use <strong>direct initialization</strong>:</p><pre><code class="hljs cpp"><span class="hljs-function">Sales_data <span class="hljs-title">item1</span> <span class="hljs-params">(null_book)</span></span>; <span class="hljs-comment">// ok: direct initialization</span><span class="hljs-comment">// error: cannot use the copy form of initialization </span><span class="hljs-comment">// with an explicit constructor</span>Sales_data item2 = null_book;</code></pre><h2 id="10-Explicitly-Using-Constructors-for-Conversions"><a href="#10-Explicitly-Using-Constructors-for-Conversions" class="headerlink" title="(10) Explicitly Using Constructors for Conversions"></a>(10) Explicitly Using Constructors for Conversions</h2><p>Although the compiler will not use an explicit constructor for an implicit conversion, we can use such constructors explicitly to force a conversion:</p><pre><code class="hljs cpp"><span class="hljs-comment">// ok: the argument is an explicitly constructed Sales_data object</span>item.combine(Sales_data(null_book));<span class="hljs-comment">// ok: static_cast can use an explicit constructor</span>item.combine(<span class="hljs-keyword">static_cast</span>&lt;Sales_data&gt;(<span class="hljs-built_in">cin</span>));</code></pre><h2 id="11-Library-Classes-with-explicit-Constructors"><a href="#11-Library-Classes-with-explicit-Constructors" class="headerlink" title="(11) Library Classes with explicit Constructors"></a>(11) Library Classes with explicit Constructors</h2><p>Some of the library classes that we’ve used have single-parameter constructors:</p><ul><li><p>The string constructor that takes a single parameter of type <code>const char*</code> is not explicit.</p></li><li><p>The vector constructor that takes a size is explicit.</p></li></ul><h2 id="12-Aggregate-Classes"><a href="#12-Aggregate-Classes" class="headerlink" title="(12) Aggregate Classes"></a>(12) Aggregate Classes</h2><p>An <strong>aggregate class</strong> gives users direct access to its members and has special initialization syntax. A class is an aggregate if</p><ul><li>All of its data members are public</li><li>It does not define any constructors</li><li>It has no in-class initializers</li><li>It has no base classes or virtual functions, which are class-related features.</li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span> &#123;</span>    <span class="hljs-keyword">int</span> ival;    <span class="hljs-built_in">string</span> s;&#125;;</code></pre><p>We can initialize the data members of an aggregate class by providing a braced list of member initializers:</p><pre><code class="hljs cpp"><span class="hljs-comment">// val1.ival = 0; val1.s = string("Anna")</span>Data val1 = &#123; <span class="hljs-number">0</span>, <span class="hljs-string">"Anna"</span> &#125;;</code></pre><p>As with initialization of array elements, if the list of initializers has <strong>fewer elements</strong> than the class has members, the trailing members are <strong>value initialized</strong>.</p><p>It is worth noting that there are three significant drawbacks to <strong>explicitly initializing</strong> the members of an object of class type:</p><ul><li><p>It requires that all the data members of the class be public.</p></li><li><p>It puts the burden on the user of the class (rather than on the class author) to correctly initialize every member of every object. </p></li><li><p>If a member is added or removed, all initializations have to be updated.</p></li></ul><h2 id="13-Literal-Classes"><a href="#13-Literal-Classes" class="headerlink" title="(13) Literal Classes"></a>(13) Literal Classes</h2><p>Unlike other classes, classes that are <strong>literal types</strong> may have function members that are <strong>constexpr</strong>. </p><p>Such members must meet all the requirements of a <strong>constexpr function</strong>. These member functions are implicitly <strong>const</strong>.</p><p>An <strong>aggregate</strong> class whose data members are all of <strong>literal type</strong> is a <strong>literal class</strong>. </p><p>A <strong>nonaggregate class</strong>, that meets the following restrictions, is also a literal class: </p><ul><li>The data members all must have literal type.</li><li>The class must have at least one <strong>constexpr</strong> constructor.</li><li>If a data member has an in-class initializer, the initializer for a member of built-in type must be a constant expression, or if the member has class type, the initializer must use the member’s own <strong>constexpr</strong> constructor. </li><li>The class must use default definition for its destructor, which is the member that destroys objects of the class type.</li></ul><h2 id="14-constexpr-Constructors"><a href="#14-constexpr-Constructors" class="headerlink" title="(14) constexpr Constructors"></a>(14) constexpr Constructors</h2><p>Although constructors can’t be <strong>const</strong>, constructors in a literal class can be <strong>constexpr</strong> functions.</p><p>A <strong>constexpr</strong> <strong>constructor</strong> can be declared as <code>=</code> default (or as a deleted function).</p><p>A <strong>constexpr</strong> constructor must meet the requirements of a <strong>constructor</strong>—meaning it can have <strong>no return statement</strong>—and of a <strong>constexpr function</strong>—meaning the only executable statement it can have is a return statement. </p><p>As a result, the <strong>body</strong> of a <strong>constexpr constructor</strong> is typically <strong>empty</strong>. </p><p>We define a <strong>constexpr constructor</strong> by preceding its declaration with the keyword <strong>constexpr</strong>:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Debug</span> &#123;</span><span class="hljs-keyword">public</span>:    constexpr Debug(bool b = true): hw(b), io(b), other(b) &#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Debug</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> h, <span class="hljs-keyword">bool</span> i, <span class="hljs-keyword">bool</span> o)</span>:</span>    hw(h), io(i), other(o) &#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">any</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> hw || io || other; &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_io</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> b)</span> </span>&#123; io = b; &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_hw</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> b)</span> </span>&#123; hw = b; &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_other</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> b)</span> </span>&#123; hw = b; &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">bool</span> hw; <span class="hljs-comment">// hardware errors other than IO errors</span>    <span class="hljs-keyword">bool</span> io; <span class="hljs-comment">// IO errors</span>    <span class="hljs-keyword">bool</span> other; <span class="hljs-comment">// other errors</span>&#125;;</code></pre><p>A <strong>constexpr constructor</strong> must initialize every data member. </p><p>The initializers must either use a <strong>constexpr constructor</strong> or be a constant expression.</p><p>A <strong>constexpr constructor</strong> is used to generate objects that are <strong>constexpr</strong> and for parameters or return types in <strong>constexpr functions</strong>:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> Debug <span class="hljs-title">io_sub</span><span class="hljs-params">(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// debugging IO</span><span class="hljs-keyword">if</span> (io_sub.any()) <span class="hljs-comment">// equivalent to if(true)</span>    <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"print appropriate error messages"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-function"><span class="hljs-keyword">constexpr</span> Debug <span class="hljs-title">prod</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// no debugging during production</span><span class="hljs-keyword">if</span> (prod.any()) <span class="hljs-comment">// equivalent to if(false)</span>    <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"print an error message"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><h1 id="6-static-Class-Members"><a href="#6-static-Class-Members" class="headerlink" title="6. static Class Members"></a>6. static Class Members</h1><p>Classes sometimes need members that are associated with the class, rather than with individual objects of the class type. </p><h2 id="1-Declaring-static-Members"><a href="#1-Declaring-static-Members" class="headerlink" title="(1) Declaring static Members"></a>(1) Declaring static Members</h2><p>We say a member is associated with the class by adding the keyword <strong>static</strong> to its <strong>declaration</strong>. </p><p>Like any other member, static members can be <strong>public</strong> or <strong>private</strong>.</p><p>The type of a <strong>static</strong> data member can be <strong>const</strong>, <strong>reference</strong>, <strong>array</strong>, <strong>class type</strong>, and so forth.</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123; amount += amount * interestRate; &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">rate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> interestRate; &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> owner;    <span class="hljs-keyword">double</span> amount;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> interestRate;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">initRate</span><span class="hljs-params">()</span></span>;&#125;;</code></pre><p>The static members of a class <strong>exist outside any object</strong>. </p><p>Objects do not contain data associated with static data members. </p><p>Thus, each <code>Account</code> object will contain two data members—<code>owner</code> and <code>amount</code>. </p><p>There is <strong>only one <code>interestRate</code> object that will be shared by all the <code>Account</code>objects</strong>.</p><p>Static member functions are <strong>not bound to any object</strong>; they do not have a <strong>this</strong> pointer. </p><p>As a result, static member functions may <strong>not be declared as const</strong>, and we may <strong>not refer to this</strong> in the body of a static member. </p><p>This restriction applies both to <strong>explicit uses</strong> of this and to <strong>implicit uses</strong> of this by calling a <strong>nonstatic member</strong>.</p><h2 id="2-Using-a-Class-static-Member"><a href="#2-Using-a-Class-static-Member" class="headerlink" title="(2) Using a Class static Member"></a>(2) Using a Class static Member</h2><p>We can access a <strong>static member</strong> directly through the scope operator:</p><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> r;r = Account::rate(); <span class="hljs-comment">// access a static member using the scope operator</span></code></pre><p>Even though <strong>static members</strong> are not part of the objects of its class, we can use an object, reference, or pointer of the class type to access a static member:</p><pre><code class="hljs cpp">Account ac1;Account *ac2 = &amp;ac1;<span class="hljs-comment">// equivalent ways to call the static member rate function</span>r = ac1.rate(); <span class="hljs-comment">// through an Account object or reference</span>r = ac2-&gt;rate(); <span class="hljs-comment">// through a pointer to an Account object</span></code></pre><p>Member functions can use static members directly, without the scope operator:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123; amount += amount * interestRate; &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> interestRate;    <span class="hljs-comment">// remaining members as before</span>&#125;;</code></pre><h2 id="3-Defining-static-Members"><a href="#3-Defining-static-Members" class="headerlink" title="(3) Defining static Members"></a>(3) Defining static Members</h2><p>As with any other member function, we can <strong>define a static</strong> member function <strong>inside or outside</strong> of the class body. </p><p>When we define a static member <strong>outside the class</strong>, we do <strong>not</strong> repeat the <strong>static keyword</strong>. The keyword appears only with the <strong>declaration</strong> inside the class body。</p><p>Because static data members are not part of individual objects of the class type, <strong>they are not defined when we create objects of the class</strong>. </p><p>As a result, <strong>they are not initialized by the class’constructors</strong>. </p><p>Moreover, in general, we may <strong>not initialize a static member</strong> <strong>inside the class</strong>. </p><p>Instead, we must <strong>define</strong> and <strong>initialize</strong> each <strong>static data member</strong> <strong>outside the class body</strong>. </p><p>Like any other object, a static data member may be <strong>defined only once</strong>.</p><p>Like global objects, static data members are defined outside any function. </p><p>Hence, once they are defined, they continue to exist until the program completes.</p><h2 id="5-In-Class-Initialization-of-static-Data-Members"><a href="#5-In-Class-Initialization-of-static-Data-Members" class="headerlink" title="(5) In-Class Initialization of static Data Members"></a>(5) In-Class Initialization of static Data Members</h2><p>Ordinarily, class static members may not be initialized in the class body. </p><p>However, we can provide <strong>in-class initializers</strong> for static members that have <strong>const</strong> integral type and must do so for static members that are <strong>constexprs</strong> of literal type. </p><p>The initializers must be constant expressions. </p><p>Such members are themselves constant expressions; they can be used where a constant expression is required. </p><h2 id="6-static-Members-Can-Be-Used-in-Ways-Ordinary-Members-Can’t"><a href="#6-static-Members-Can-Be-Used-in-Ways-Ordinary-Members-Can’t" class="headerlink" title="(6) static Members Can Be Used in Ways Ordinary Members Can’t"></a>(6) static Members Can Be Used in Ways Ordinary Members Can’t</h2><p>Static members exist <strong>independently</strong> of any other object. </p><p>As a result, they can be used in ways that would be illegal for nonstatic data members. </p><p>As one example, a static data member can have incomplete type. </p><p>In particular, a static data member can have the <strong>same type as the class type</strong> of which it is a member. </p><p>A nonstatic data member is restricted to being declared as a pointer or a reference to an object of its class:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">// ...</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">static</span> Bar mem1; <span class="hljs-comment">// ok: static member can have incomplete type</span>    Bar *mem2; <span class="hljs-comment">// ok: pointer member can have incomplete type</span>    Bar mem3; <span class="hljs-comment">// error: data members must have complete type</span>&#125;;</code></pre><p>Another difference between static and ordinary members is that <strong>we can use a static member as a default argument</strong> </p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">// bkground refers to the static member</span>    <span class="hljs-comment">// declared later in the class definition</span>    <span class="hljs-function">Screen&amp; <span class="hljs-title">clear</span><span class="hljs-params">(<span class="hljs-keyword">char</span> = bkground)</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> bkground;&#125;;</code></pre><p><strong>A nonstatic data member may not be used as a default argument because its value is part of the object of which it is a member.</strong> </p><p>Using a nonstatic data member as a default argument provides no object from which to obtain the member’s value and so is an error.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Functions</title>
    <link href="/2021/01/14/Functions-C++/"/>
    <url>/2021/01/14/Functions-C++/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 6 Functions</p><a id="more"></a><h1 id="1-Function-Basics"><a href="#1-Function-Basics" class="headerlink" title="1. Function Basics"></a>1. Function Basics</h1><p><strong>Arguments</strong> are the <strong>initializers</strong> for a function’s <strong>parameters</strong>.</p><p>Although we know which argument initializes which parameter, we have no guarantees about the order in which arguments are evaluated. </p><p>The compiler is free to evaluate the arguments in whatever order it prefers.</p><p>We must pass exactly <strong>the same number</strong> of arguments as the function has parameters.</p><p>Because every call is guaranteed to pass as many arguments as the function has parameters, <strong>parameters are always initialized</strong>.</p><h1 id="2-Argument-Passing"><a href="#2-Argument-Passing" class="headerlink" title="2. Argument Passing"></a>2. Argument Passing</h1><h2 id="1-const-Parameters-and-Arguments"><a href="#1-const-Parameters-and-Arguments" class="headerlink" title="(1) const Parameters and Arguments"></a>(1) const Parameters and Arguments</h2><p>We can initialize an object with a <strong>low-level const</strong> from a <strong>nonconst object</strong> but <strong>not vice</strong> versa, and a <strong>plain reference</strong> must be initialized from an object of the <strong>same type</strong>.  </p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *cp = &amp;i; <span class="hljs-comment">// ok: but cp can't change i (§ 2.4.2 (p. 62))</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r = i; <span class="hljs-comment">// ok: but r can't change i (§ 2.4.1 (p. 61))</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// ok</span><span class="hljs-keyword">int</span> *p = cp; <span class="hljs-comment">// error: types of p and cp don't match </span><span class="hljs-keyword">int</span> &amp;r3 = r; <span class="hljs-comment">// error: types of r3 and r don't match </span><span class="hljs-keyword">int</span> &amp;r4 = <span class="hljs-number">42</span>; <span class="hljs-comment">// error: can't initialize a plain reference from a literal</span></code></pre><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;i)</span> </span><span class="hljs-function"></span>&#123;    i = <span class="hljs-number">0</span>; &#125;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i;<span class="hljs-built_in">string</span>::size_type ctr = <span class="hljs-number">0</span>;reset(&amp;i); <span class="hljs-comment">// calls the version of reset that has an int* parameter</span><span class="hljs-comment">// error: can't initialize an int* from a pointer to a const int object</span>reset(&amp;ci); reset(i); <span class="hljs-comment">// calls the version of reset that has an int&amp; parameter</span>reset(ci); <span class="hljs-comment">// error: can't bind a plain reference to the const object ci</span>reset(<span class="hljs-number">42</span>); <span class="hljs-comment">// error: can't bind a plain reference to a literal</span>reset(ctr); <span class="hljs-comment">// error: types don't match; ctr has an unsigned type</span><span class="hljs-comment">// ok: find_char's first parameter is a reference to const</span>find_char(<span class="hljs-string">"Hello World!"</span>, <span class="hljs-string">'o'</span>, ctr);</code></pre><p><strong>We cannot pass a const object, or a literal, or an object that requires conversion to a plain reference parameter.</strong></p><h2 id="2-Varying-Parameters"><a href="#2-Varying-Parameters" class="headerlink" title="(2) Varying Parameters"></a>(2) Varying Parameters</h2><h3 id="initializer-list-Parameters"><a href="#initializer-list-Parameters" class="headerlink" title="initializer_list Parameters"></a>initializer_list Parameters</h3><p><a href="http://www.cplusplus.com/reference/initializer_list/initializer_list/?kw=initializer_list" target="_blank" rel="noopener">std::initializer_list</a></p><p><a href="https://en.cppreference.com/w/cpp/utility/initializer_list" target="_blank" rel="noopener">std::initializer_list<T> </a></p><p>We can write a function that takes an <strong>unknown number of arguments</strong> of a <strong>single type</strong> by using an <strong>initializer_list</strong> parameter.</p><p>An <strong>initializer_list</strong> is a <strong>library type</strong> that represents an <strong>array</strong> of values of the <strong>specified type</strong>. </p><p>This type is defined in the <strong>initializer_list header</strong>.</p><p><img src="https://img-blog.csdnimg.cn/20200202140027499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">Like a vector, <code>initializer_list</code> is a <strong>template type</strong>. </p><p>When we define an <code>initializer_list</code>, we must specify the type of the elements that the list will contain:</p><pre><code class="hljs cpp"><span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-built_in">string</span>&gt; ls; <span class="hljs-comment">// initializer_list of strings</span><span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-keyword">int</span>&gt; li; <span class="hljs-comment">// initializer_list of ints</span></code></pre><p>Unlike <code>vector</code>, the elements in an <code>initializer_list</code> are always <strong>const values</strong>; there is no way to change the value of an element in an <code>initializer_list</code>.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_msg</span><span class="hljs-params">(<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-built_in">string</span>&gt; il)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> beg = il.begin(); beg != il.end(); ++beg)    <span class="hljs-built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="hljs-string">" "</span> ;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><p>When we pass <strong>a sequence of values</strong> to an initializer_list parameter, we must enclose the sequence in <strong>curly braces</strong>:</p><p>A function with an <code>initializer_list</code> parameter can have other parameters as well. </p><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (expected != actual)    error_msg(ErrCode(<span class="hljs-number">42</span>), &#123;<span class="hljs-string">"functionX"</span>, expected, actual&#125;);<span class="hljs-keyword">else</span>    error_msg(ErrCode(<span class="hljs-number">0</span>), &#123;<span class="hljs-string">"functionX"</span>, <span class="hljs-string">"okay"</span>&#125;);</code></pre><h2 id="Ellipsis-Parameters"><a href="#Ellipsis-Parameters" class="headerlink" title="Ellipsis Parameters"></a>Ellipsis Parameters</h2><p>Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named <code>varargs</code>. </p><p>An ellipsis parameter may appear only as the last element in a parameter list and may take either of two forms:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(parm_list, ...)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(...)</span></span>;</code></pre><h1 id="3-Return-Types-and-the-return-Statement"><a href="#3-Return-Types-and-the-return-Statement" class="headerlink" title="3. Return Types and the return Statement"></a>3. Return Types and the return Statement</h1><h2 id="1-Reference-Returns-Are-Lvalues"><a href="#1-Reference-Returns-Are-Lvalues" class="headerlink" title="(1) Reference Returns Are Lvalues"></a>(1) Reference Returns Are Lvalues</h2><p>Calls to functions that <strong>return references</strong> are <strong>lvalues</strong>; <strong>other</strong> return types yield <strong>rvalues</strong>. </p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span> &amp;<span class="hljs-title">get_val</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;str, <span class="hljs-built_in">string</span>::size_type ix)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> str[ix]; <span class="hljs-comment">// get_val assumes the given index is valid</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"a value"</span>)</span></span>;    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// prints a value</span>    get_val(s, <span class="hljs-number">0</span>) = <span class="hljs-string">'A'</span>; <span class="hljs-comment">// changes s[0] to A</span>    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// prints A value</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="2-List-Initializing-the-Return-Value"><a href="#2-List-Initializing-the-Return-Value" class="headerlink" title="(2) List Initializing the Return Value"></a>(2) List Initializing the Return Value</h2><p>As in any other <code>return</code>, the list is used to initialize the temporary that represents the function’s return.</p><p>If the list is empty, that temporary is value initialized.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">process</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// . . .</span><span class="hljs-comment">// expected and actual are strings</span><span class="hljs-keyword">if</span> (expected.empty())    <span class="hljs-keyword">return</span> &#123;&#125;; <span class="hljs-comment">// return an empty vector</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expected == actual)    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">"functionX"</span>, <span class="hljs-string">"okay"</span>&#125;; <span class="hljs-comment">// return list-initialized vector</span><span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">"functionX"</span>, expected, actual&#125;;&#125;</code></pre><h2 id="3-Declaring-a-Function-That-Returns-a-Pointer-to-an-Array"><a href="#3-Declaring-a-Function-That-Returns-a-Pointer-to-an-Array" class="headerlink" title="(3) Declaring a Function That Returns a Pointer to an Array"></a>(3) Declaring a Function That Returns a Pointer to an Array</h2><pre><code class="hljs fortran"><span class="hljs-keyword">Type</span> (*<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(parameter_list)</span></span>)[<span class="hljs-keyword">dimension</span>]</code></pre><p>As a concrete example, the following declares <code>func</code> without using a type alias:</p><pre><code class="hljs go"><span class="hljs-keyword">int</span> (*<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span>)[10];</span></code></pre><ul><li><p>func(int) says that we can call func with an int argument.</p></li><li><p>(*func(int)) says we can dereference the result of that call.</p></li><li><p>(*func(int))[10] says that dereferencing the result of a call to func yields an array of size ten.</p></li><li><p>int (*func(int))[10] says the element type in that array is int.</p></li></ul><h2 id="4-Using-a-Trailing-Return-Type"><a href="#4-Using-a-Trailing-Return-Type" class="headerlink" title="(4) Using a Trailing Return Type"></a>(4) Using a Trailing Return Type</h2><p><strong>Trailing returns</strong> can be defined for any function, but are most<br>useful for functions with <strong>complicated return</strong> types, such as pointers (or references) to arrays. </p><p>A trailing return type follows the parameter list and is preceded by <code>-&gt;</code>. </p><pre><code class="hljs cpp"><span class="hljs-comment">// fcn takes an int argument and returns a pointer to an array of ten ints</span>auto func(int i) -&gt; int(*)[10];</code></pre><h2 id="5-Using-decltype"><a href="#5-Using-decltype" class="headerlink" title="(5) Using decltype"></a>(5) Using decltype</h2><p>As another alternative, if we know the array(s) to which our function can return a pointer, we can use <strong>decltype</strong> to declare the return type.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> odd[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-keyword">int</span> even[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<span class="hljs-comment">// returns a pointer to an array of five int elements</span><span class="hljs-keyword">decltype</span>(odd) *arrPtr(<span class="hljs-keyword">int</span> i)&#123;    <span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span>) ? &amp;odd : &amp;even; <span class="hljs-comment">// returns a pointer to the array</span>&#125;</code></pre><p>The return type for <code>arrPtr</code> uses <code>decltype</code> to say that the function returns a pointer to whatever type <code>odd</code> has. </p><p>The only tricky part is that we must remember that <strong>decltype does not automatically convert an array to its corresponding pointer type</strong>. </p><h1 id="4-Overloaded-Functions"><a href="#4-Overloaded-Functions" class="headerlink" title="4. Overloaded Functions"></a>4. Overloaded Functions</h1><p>Functions that have the <strong>same name</strong> but <strong>different parameter lists</strong> and that appear in the <strong>same scope</strong> are <strong>overloaded</strong>.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *beg, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *end)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[], <span class="hljs-keyword">size_t</span> size)</span></span>;</code></pre><p>We should only overload operations that actually do <strong>similar things</strong>. </p><h2 id="1-Defining-Overloaded-Functions"><a href="#1-Defining-Overloaded-Functions" class="headerlink" title="(1) Defining Overloaded Functions"></a>(1) Defining Overloaded Functions</h2><p>It is an <strong>error</strong> for two functions to <strong>differ only</strong> in terms of their <strong>return types</strong>. </p><pre><code class="hljs cpp"><span class="hljs-comment">// each pair declares the same function</span><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account &amp;acct)</span></span>;<span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>; <span class="hljs-comment">// parameter names are ignored</span><span class="hljs-keyword">typedef</span> Phone Telno;<span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Phone&amp;)</span></span>;<span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Telno&amp;)</span></span>; <span class="hljs-comment">// Telno and Phone are the same type</span></code></pre><h2 id="2-Overloading-and-const-Parameters"><a href="#2-Overloading-and-const-Parameters" class="headerlink" title="(2) Overloading and const Parameters"></a>(2) Overloading and const Parameters</h2><p>A parameter that has a <strong>top-level const</strong> is <strong>indistinguishable</strong> from one without a <strong>top-level const</strong>:</p><pre><code class="hljs cpp"><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone)</span></span>;<span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Phone)</span></span>; <span class="hljs-comment">// redeclares Record lookup(Phone)</span><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone*)</span></span>;<span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone* <span class="hljs-keyword">const</span>)</span></span>; <span class="hljs-comment">// redeclares Record lookup(Phone*)</span></code></pre><p><strong>On the other hand</strong>, we can overload based on whether the parameter is a reference (or pointer) to the <code>const</code> or <code>nonconst</code> version of a given type; such <code>consts</code> are <strong>low-level</strong>:</p><pre><code class="hljs cpp"><span class="hljs-comment">// functions taking const and nonconst references or pointers</span><span class="hljs-comment">// have different parameters</span><span class="hljs-comment">// declarations for four independent, overloaded functions</span><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account&amp;)</span></span>; <span class="hljs-comment">// function that takes a reference to Account</span><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>; <span class="hljs-comment">// new function that takes a const reference</span><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account*)</span></span>; <span class="hljs-comment">// new function, takes a pointer to Account</span><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account*)</span></span>; <span class="hljs-comment">// new function, takes a pointer to const</span></code></pre><h2 id="3-Overloading-and-Scope"><a href="#3-Overloading-and-Scope" class="headerlink" title="(3) Overloading and Scope"></a>(3) Overloading and Scope</h2><p>As usual, if we declare a name in an inner scope, that name hides uses of that name declared in an outer scope. Names do not overload across scopes.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>; <span class="hljs-comment">// overloads the print function</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fooBar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ival)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">bool</span> read = <span class="hljs-literal">false</span>; <span class="hljs-comment">// new scope: hides the outer declaration of read</span>    <span class="hljs-built_in">string</span> s = read(); <span class="hljs-comment">// error: read is a bool variable, not a function</span>    <span class="hljs-comment">// bad practice: usually it's a bad idea to declare functions at local scope</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">// new scope: hides previous instances of print</span>    print(<span class="hljs-string">"Value: "</span>); <span class="hljs-comment">// error: print(const string &amp;) is hidden</span>    print(ival); <span class="hljs-comment">// ok: print(int) is visible</span>    print(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// ok: calls print(int); print(double) is hidden</span>&#125;</code></pre><p>In C++, name lookup happens before type checking.</p><h1 id="5-Default-Arguments"><a href="#5-Default-Arguments" class="headerlink" title="5. Default Arguments"></a>5. Default Arguments</h1><p>Some functions have parameters that are given a particular value in most, but not all, calls. </p><p>In such cases, we can declare that common value as a <strong>default argument</strong> for the function. </p><p>Functions with default arguments can be called <strong>with or without</strong> that argument.</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">string</span>::size_type sz; <span class="hljs-comment">// typedef see § 2.5.1 (p. 67)</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz ht = <span class="hljs-number">24</span>, sz wid = <span class="hljs-number">80</span>, <span class="hljs-keyword">char</span> backgrnd = <span class="hljs-string">' '</span>)</span></span>;</code></pre><p>A default argument is specified as an <strong>initializer</strong> for a parameter in the <strong>parameter list</strong>. </p><p>We may define defaults for <strong>one or more</strong> parameters. </p><p>However, if a parameter has a default argument, all the parameters that <strong>follow it</strong> must also have default arguments.</p><p>Because screen provides defaults for all of its parameters, we can call screen with zero, one, two, or three arguments:</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> window;window = screen(); <span class="hljs-comment">// equivalent to screen(24,80,' ')</span>window = screen(<span class="hljs-number">66</span>);<span class="hljs-comment">// equivalent to screen(66,80,' ')</span>window = screen(<span class="hljs-number">66</span>, <span class="hljs-number">256</span>); <span class="hljs-comment">// screen(66,256,' ')</span>window = screen(<span class="hljs-number">66</span>, <span class="hljs-number">256</span>, <span class="hljs-string">'#'</span>); <span class="hljs-comment">// screen(66,256,'#')</span></code></pre><p>Arguments in the call are resolved by position. The default arguments are used for the trailing (right-most) arguments of a call. </p><pre><code class="hljs cpp">window = screen(, , <span class="hljs-string">'?'</span>); <span class="hljs-comment">// error: can omit only trailing arguments</span>window = screen(<span class="hljs-string">'?'</span>); <span class="hljs-comment">// calls screen('?',80,' ')</span></code></pre><p>In this call, the char argument is implicitly converted to string::size_type, and is passed as the argument to height. </p><h2 id="1-Default-Argument-Declarations"><a href="#1-Default-Argument-Declarations" class="headerlink" title="(1) Default Argument Declarations"></a>(1) Default Argument Declarations</h2><p>Although it is normal practice to declare a function once inside a header, it is legal to <strong>redeclare a function multiple times</strong>. </p><p>However, each parameter can have its <strong>default specified only once</strong> in a <strong>given scope</strong>. </p><p>Any subsequent declaration can add a default only for a parameter that has not previously had a default specified.</p><pre><code class="hljs cpp"><span class="hljs-comment">// no default for the height or width parameters</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz, sz, <span class="hljs-keyword">char</span> = <span class="hljs-string">' '</span>)</span></span>;</code></pre><p>we cannot change an already declared default value:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz, sz, <span class="hljs-keyword">char</span> = <span class="hljs-string">'*'</span>)</span></span>; <span class="hljs-comment">// error: redeclaration</span></code></pre><p>but we can add a default argument as follows:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz = <span class="hljs-number">24</span>, sz = <span class="hljs-number">80</span>, <span class="hljs-keyword">char</span>)</span></span>; <span class="hljs-comment">// ok: adds default</span></code></pre><h1 id="6-Inline-and-constexpr-Functions"><a href="#6-Inline-and-constexpr-Functions" class="headerlink" title="6. Inline and constexpr Functions"></a>6. Inline and constexpr Functions</h1><h2 id="1-inline-Functions"><a href="#1-inline-Functions" class="headerlink" title="(1)  inline Functions"></a>(1)  inline Functions</h2><p>A function specified as inline (usually) is expanded “<strong>in line</strong>” at each call. </p><p>In an inline function, the compiled code is “in line” with the other code in the program. </p><p>That is, the compiler <strong>replaces the function call</strong> with the <strong>corresponding function code</strong>.</p><p>With inline code, the program doesn’t have to jump to another location to execute the code and then jump back. </p><p>Inline functions thus run a little <strong>faster</strong> than regular functions, but they come with a <strong>memory penalty</strong>. </p><pre><code class="hljs cpp"><span class="hljs-comment">// inline.cpp -- using an inline function</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// an inline function definition</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;    <span class="hljs-keyword">double</span> a, b;    <span class="hljs-keyword">double</span> c = <span class="hljs-number">13.0</span>;    a = square(<span class="hljs-number">5.0</span>);    b = square(<span class="hljs-number">4.5</span> + <span class="hljs-number">7.5</span>); <span class="hljs-comment">// can pass expressions</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>Note:</strong><br>The inline specification is <strong>only a request to the compiler</strong>. The compiler may choose to ignore this request.</p><h2 id="2-constexpr-Functions"><a href="#2-constexpr-Functions" class="headerlink" title="(2) constexpr Functions"></a>(2) constexpr Functions</h2><p><a href="https://en.cppreference.com/w/cpp/language/constexpr" target="_blank" rel="noopener">constexpr specifier</a></p><p>A <strong>constexpr</strong> function is a function that can be used in a constant expression.</p><p>A <strong>constexpr</strong> function is defined like any other function but must meet certain <strong>restrictions</strong>:<br>The <strong>return type</strong> and the type of each parameter in a must be a <a href="https://en.cppreference.com/w/cpp/named_req/LiteralType" target="_blank" rel="noopener">literal type</a>, and the <strong>function body</strong> must contain exactly one return statement:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> foo = new_sz(); <span class="hljs-comment">// ok: foo is a constant expression</span></code></pre><p>Here we defined <code>new_sz</code> as a <strong>constexpr</strong> that takes no arguments. </p><p>The compiler can verify at compile time that a call to <code>new_sz</code> returns a constant expression, so we can use <code>new_sz</code> to initialize our <strong>constexpr variable</strong> <code>foo</code>.</p><p>When it can do so, the compiler will replace a call to a <strong>constexpr</strong> function with its resulting value. </p><p>In order to be able to expand the function immediately, <strong>constexpr</strong> functions are <strong>implicitly inline</strong>.</p><p>A <strong>constexpr function body</strong> may contain other statements so long as those statements <strong>generate no actions at run time</strong>.</p><p>A <strong>constexpr function</strong> is permitted to <strong>return</strong> a value that is not a constant:</p><pre><code class="hljs cpp"><span class="hljs-comment">// scale(arg) is a constant expression if arg is a constant expression</span><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> cnt)</span> </span>&#123; <span class="hljs-keyword">return</span> new_sz() * cnt; &#125;</code></pre><p>The scale function will return a constant expression if its argument is a constant expression but not otherwise:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> arr[scale(<span class="hljs-number">2</span>)]; <span class="hljs-comment">// ok: scale(2) is a constant expression</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; <span class="hljs-comment">// i is not a constant expression</span><span class="hljs-keyword">int</span> a2[scale(i)]; <span class="hljs-comment">// error: scale(i) is not a constant expression</span></code></pre><h2 id="3-Put-inline-and-constexpr-Functions-in-Header-Files"><a href="#3-Put-inline-and-constexpr-Functions-in-Header-Files" class="headerlink" title="(3) Put inline and constexpr Functions in Header Files"></a>(3) Put inline and constexpr Functions in Header Files</h2><p>Unlike other functions, <strong>inline</strong> and <strong>constexpr</strong> functions may be <strong>defined multiple times in the program</strong>. </p><p>After all, the compiler needs the definition, not just the declaration, in order to expand the code. </p><p>However, all of the definitions of a given <strong>inline</strong> or <strong>constexpr</strong> must match exactly. </p><p>As a result, <strong>inline</strong> and <strong>constexpr</strong> functions normally are defined in <strong>headers</strong>.</p><h1 id="7-Aids-for-Debugging"><a href="#7-Aids-for-Debugging" class="headerlink" title="7. Aids for Debugging"></a>7. Aids for Debugging</h1><p>C++ programmers sometimes use a technique similar to header guards to <strong>conditionally</strong> execute <strong>debugging code</strong>. </p><p>The idea is that the program will <strong>contain debugging code</strong> that is executed <strong>only</strong> while the program is being developed. </p><p>When the application is <strong>completed</strong> and ready to ship, the debugging code is <strong>turned off</strong>. </p><p>This approach uses two <strong>preprocessor</strong> facilities: <strong>assert</strong> and <strong>NDEBUG</strong>.</p><h2 id="1-The-assert-Preprocessor-Macro"><a href="#1-The-assert-Preprocessor-Macro" class="headerlink" title="(1) The assert Preprocessor Macro"></a>(1) The assert Preprocessor Macro</h2><p><strong>assert</strong> is a <strong>preprocessor macro</strong>. </p><p>A <strong>preprocessor macro</strong> is a <strong>preprocessor variable</strong> that acts somewhat like an <strong>inline function</strong>. </p><p>The <strong>assert macro</strong> takes a <strong>single expression</strong>, which it uses as a <strong>condition</strong>:</p><pre><code class="hljs cpp">assert(expr);</code></pre><p>evaluates <code>expr</code> and if the expression is <strong>false</strong> (i.e., zero), then <strong>assert</strong> writes a <strong>message</strong> and <strong>terminates the program</strong>. If the expression is <strong>true</strong> (i.e., is nonzero), then assert <strong>does nothing</strong>.</p><p>The <strong>assert macro</strong> is defined in the <strong>cassert</strong> header. </p><p>As we’ve seen, <code>preprocessor</code> names are managed by the <code>preprocessor</code> not the compiler. </p><p>As a result, we <strong>use preprocessor names</strong> <strong>directly</strong> and <strong>do not</strong> provide a <strong>using declaration</strong> for them. </p><p>As with <code>preprocessor</code> variables, macro names must be unique within the program.</p><p>The assert macro is often used to check for conditions that “cannot happen”.</p><pre><code class="hljs cpp">assert(word.size() &gt; threshold);</code></pre><h2 id="2-The-NDEBUG-Preprocessor-Variable"><a href="#2-The-NDEBUG-Preprocessor-Variable" class="headerlink" title="(2) The NDEBUG Preprocessor Variable"></a>(2) The NDEBUG Preprocessor Variable</h2><p>The <strong>behavior of assert</strong> depends on the <strong>status</strong> of a <strong>preprocessor variable</strong> named <strong>NDEBUG</strong>. </p><p>If <strong>NDEBUG</strong> is defined, assert does nothing. </p><p>By default, <strong>NDEBUG</strong> is <strong>not defined</strong>, so, by default, assert performs a <strong>run-time check</strong>.</p><p>We can “turn off” debugging by providing a <code>#define</code> to define <code>NDEBUG</code>.</p><p>Alternatively, most compilers provide a command-line option that lets us define preprocessor variables:</p><pre><code class="hljs bash">$ CC -D NDEBUG main.C <span class="hljs-comment"># use /D with the Microsoft compiler</span></code></pre><p>has the same effect as writing <strong>#define NDEBUG</strong> at the beginning of main.C.</p><p>In addition to <strong>using assert</strong>, we can write our own conditional debugging code using NDEBUG. </p><p>If <strong>NDEBUG</strong> is not defined, the code between the <strong>#ifndef</strong> and the <strong>#endif</strong> is executed. </p><p>If <strong>NDEBUG</strong> is defined, that code is ignored:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[], <span class="hljs-keyword">size_t</span> size)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><span class="hljs-comment">// _ _func_ _ is a local static defined by the compiler that holds the function's name</span><span class="hljs-built_in">cerr</span> &lt;&lt; _ _func_ _ &lt;&lt; <span class="hljs-string">": array size is "</span> &lt;&lt; size &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-comment">// ...</span></code></pre><p>Here we use a variable named <code>_ _func_ _</code> to print the name of the function we are debugging. </p><p>The compiler defines <code>_ _func_ _</code> in every function. It is a local static array of const char that holds the name of the function.</p><p>In addition to <code>_ _func_ _</code>, which the C++ compiler defines, the preprocessor defines four other names that can be useful in debugging:</p><pre><code class="hljs livecodeserver">_ _FILE_ _ <span class="hljs-keyword">string</span> literal containing <span class="hljs-keyword">the</span> name <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span>_ _LINE_ _ <span class="hljs-keyword">integer</span> literal containing <span class="hljs-keyword">the</span> current <span class="hljs-built_in">line</span> <span class="hljs-built_in">number</span>_ _TIME_ _ <span class="hljs-keyword">string</span> literal containing <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> was compiled_ _DATE_ _ <span class="hljs-keyword">string</span> literal containing <span class="hljs-keyword">the</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> was compiled</code></pre><p>We might use these constants to report additional information in error messages:</p><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (word.size() &lt; threshold)<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error: "</span> &lt;&lt; _ _FILE_ _&lt;&lt; <span class="hljs-string">" : in function "</span> &lt;&lt; _ _func_ _&lt;&lt; <span class="hljs-string">" at line "</span> &lt;&lt; _ _LINE_ _ &lt;&lt; <span class="hljs-built_in">endl</span>&lt;&lt; <span class="hljs-string">" Compiled on "</span> &lt;&lt; _ _DATE_ _&lt;&lt; <span class="hljs-string">" at "</span> &lt;&lt; _ _TIME_ _ &lt;&lt; <span class="hljs-built_in">endl</span>&lt;&lt; <span class="hljs-string">" Word read was \""</span> &lt;&lt; word&lt;&lt; <span class="hljs-string">"\": Length too short"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><p>If we give this program a string that is shorter than the threshold, then the following error message will be generated:</p><pre><code class="hljs cpp">Error: wdebug.cc : in function main at line <span class="hljs-number">27</span>Compiled on Jul <span class="hljs-number">11</span> <span class="hljs-number">2012</span> at <span class="hljs-number">20</span>:<span class="hljs-number">50</span>:<span class="hljs-number">03</span>Word read was <span class="hljs-string">"foo"</span>: Length too short</code></pre><h1 id="8-Function-Matching"><a href="#8-Function-Matching" class="headerlink" title="8. Function Matching"></a>8. Function Matching</h1><p>It is not so simple when the overloaded functions have the same number of parameters and when one or more of the parameters have types that are related by conversions. </p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span> = <span class="hljs-number">3.14</span>)</span></span>;f(<span class="hljs-number">5.6</span>); <span class="hljs-comment">// calls void f(double, double)</span></code></pre><h2 id="1-Determining-the-Candidate-and-Viable-Functions"><a href="#1-Determining-the-Candidate-and-Viable-Functions" class="headerlink" title="(1) Determining the Candidate and Viable Functions"></a>(1) Determining the Candidate and Viable Functions</h2><p><strong>The first step</strong> of <strong>function matching</strong> identifies the set of overloaded functions considered for the call.</p><p>The functions in this set are the <strong>candidate functions</strong>.</p><p><strong>The second step</strong> selects from the set of candidate functions those functions that can be called with the arguments in the given call. </p><p>The selected functions are the <strong>viable functions</strong>. </p><p><strong>To be viable</strong>, a function must have the <strong>same number of parameters</strong> as there are arguments in the call, and the <strong>type</strong> of each argument must <strong>match</strong> or be <strong>convertible</strong> to the type of its <strong>corresponding parameter</strong>.</p><p><strong>When a function has default arguments, a call may appear to have fewer arguments than it actually does.</strong></p><p>If there are no viable functions, the compiler will complain that there is no matching function.</p><p><strong>The third step</strong> of function matching determines which viable function provides the <strong>best match</strong> for the call. </p><p>Function matching is more complicated if there are two or more arguments. </p><p>Given the same functions named <code>f</code>, let’s analyze the following call:</p><pre><code class="hljs cpp">f(<span class="hljs-number">42</span>, <span class="hljs-number">2.56</span>);</code></pre><p>In this case, the viable functions are <code>f(int, int)</code> and <code>f(double, double)</code>. </p><p>Considering <strong>only the first argument</strong>, <code>f(int, int)</code> is a better match than <code>f(double, double)</code>.</p><p>When we consider <strong>only the second parameter</strong>, the function <code>f(double, double)</code> is a better match.</p><p>The compiler will <strong>reject this call</strong> because it is <strong>ambiguous</strong>: Each viable function is a better match than the other on one of the arguments to the call. </p><p><strong>Note:</strong><br><strong>Casts should not be needed to call an overloaded function.</strong> The need for a cast suggests that the parameter sets are designed poorly.</p><h2 id="2-Argument-Type-Conversions"><a href="#2-Argument-Type-Conversions" class="headerlink" title="(2) Argument Type Conversions"></a>(2) Argument Type Conversions</h2><p>In order to <strong>determine the best match</strong>, the compiler <strong>ranks the conversions</strong> that could be used to convert each argument to the type of its corresponding parameter.</p><p>Conversions are ranked as follows:</p><h3 id="An-exact-match"><a href="#An-exact-match" class="headerlink" title="An exact match"></a>An exact match</h3><p>An exact match happens when:</p><ul><li><p>The argument and parameter types are identical.</p></li><li><p>The argument is converted from an <strong>array or function type</strong> to the corresponding <strong>pointer type</strong>. (covers function pointers.)</p></li><li><p>A top-level const is added to or discarded from the argument.</p><h3 id="Match-through-a-const-conversion"><a href="#Match-through-a-const-conversion" class="headerlink" title="Match through a const conversion"></a>Match through a const conversion</h3><p>When we call an overloaded function that differs on whether a <code>reference</code> or <code>pointer parameter</code> refers or points to <code>const</code>, the compiler uses the constness of the argument to decide which function to call:</p></li></ul><pre><code class="hljs cpp"><span class="hljs-comment">// function that takes a reference to Account</span><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account&amp;)</span></span>; <span class="hljs-comment">// new function that takes a const reference</span><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>; <span class="hljs-keyword">const</span> Account a;Account b;lookup(a); <span class="hljs-comment">// calls lookup(const Account&amp;)</span>lookup(b); <span class="hljs-comment">// calls lookup(Account&amp;)</span></code></pre><p>We cannot bind a <code>plain reference</code> to a <code>const</code> object.</p><p>We can use <code>b</code> to initialize a reference to either <code>const</code> or <code>nonconst</code> type.</p><p>However, initializing a reference to <code>const</code> from a <code>nonconst</code> object requires a <strong>conversion</strong>. Hence, the <code>nonconst</code> version is preferred.</p><h3 id="Match-through-a-Promotion-or-Arithmetic-Conversion"><a href="#Match-through-a-Promotion-or-Arithmetic-Conversion" class="headerlink" title="Match through a Promotion or Arithmetic Conversion"></a>Match through a Promotion or Arithmetic Conversion</h3><p>The small integral types always promote to int or to a larger integral type. </p><p>Given two functions, one of which takes an <code>int</code> and the other a <code>short</code>, the <code>short</code> version will be called <strong>only</strong> on values of type short:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(short)</span></span>;ff(<span class="hljs-string">'a'</span>); <span class="hljs-comment">// char promotes to int; calls f(int)</span></code></pre><p><strong>All the arithmetic conversions are treated as equivalent to each other.</strong></p><p>The conversion from <code>int</code> to <code>unsigned int</code>, for example, does not take precedence over the conversion from <code>int</code> to <code>double</code>:   </p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manip</span><span class="hljs-params">(<span class="hljs-keyword">long</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manip</span><span class="hljs-params">(<span class="hljs-keyword">float</span>)</span></span>;manip(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// error: ambiguous call</span></code></pre><h1 id="9-Pointers-to-Functions"><a href="#9-Pointers-to-Functions" class="headerlink" title="9. Pointers to Functions"></a>9. Pointers to Functions</h1><p>A function pointer is just that a pointer that denotes a function rather than an object.</p><p>When we use the name of a function as a value, the function is automatically converted to a pointer. </p><h2 id="1-Function-Pointer-Parameters"><a href="#1-Function-Pointer-Parameters" class="headerlink" title="(1) Function Pointer Parameters"></a>(1) Function Pointer Parameters</h2><p>Just as with arrays, we cannot define parameters of function type but can have a parameter that is a pointer to function. </p><p>As with arrays, we can write a parameter that looks like a function type, but it will be treated as a pointer:</p><pre><code class="hljs cpp"><span class="hljs-comment">// third parameter is a function type and is automatically treated as a pointer to function</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span> pf(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;))</span></span>;<span class="hljs-comment">// equivalent declaration: explicitly define the parameter as a pointer to function</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span> (*pf)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;))</span></span>;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">// compares lengths of two strings</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">lengthCompare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;)</span></span>;<span class="hljs-comment">// Func and Func2 have function type</span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;)</span></span>;<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> Func2</span>; <span class="hljs-comment">// equivalent type</span><span class="hljs-comment">// FuncP and FuncP2 have pointer to function type</span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span><span class="hljs-params">(*FuncP)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;)</span></span>;<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> *FuncP2</span>; <span class="hljs-comment">// equivalent type</span></code></pre><p>Both <code>Func</code> and <code>Func2</code> are <strong>function types</strong>, whereas <code>FuncP</code> and <code>FuncP2</code> are <strong>pointer types</strong>. </p><p><strong>It is important to note that decltype returns the function type</strong>; the <strong>automatic conversion</strong> to pointer is not done.</p><h2 id="2-Returning-a-Pointer-to-Function"><a href="#2-Returning-a-Pointer-to-Function" class="headerlink" title="(2) Returning a Pointer to Function"></a>(2) Returning a Pointer to Function</h2><p>As with arrays, we can’t return a function type but can return a pointer to a function type. </p><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> F = <span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>); <span class="hljs-comment">// F is a function type, not a pointer</span><span class="hljs-keyword">using</span> PF = <span class="hljs-keyword">int</span>(*)(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>); <span class="hljs-comment">// PF is a pointer type</span></code></pre><p>Here we used type alias declarations to define <code>F</code>as a <strong>function type</strong> and <code>PF</code> as a <strong>pointer to function type</strong>. </p><pre><code class="hljs cpp"><span class="hljs-function">PF <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">// ok: PF is a pointer to function; f1 returns a pointer to function</span><span class="hljs-function">F <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">// error: F is a function type; f1 can't return a function</span><span class="hljs-function">F *<span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">// ok: explicitly specify that the return type is a pointer to function</span></code></pre><p>We can also declare <code>f1</code> directly, which we’d do as</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> (*f1(<span class="hljs-keyword">int</span>))(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>);</code></pre><p>Reading this declaration from the inside out, we see that <code>f1</code> has a parameter list, so <code>f1</code> is a function. </p><p><code>f1</code> is preceded by a <code>*</code> so <code>f1</code> returns a pointer. </p><p>The type of that pointer itself has a parameter list, so the pointer points to a function. </p><p>That function returns an int.</p><p>For completeness, it’s worth noting that we can simplify declarations of functions that return pointers to function by using a trailing return:</p><pre><code class="hljs cpp">auto f1(int) -&gt; int (*)(int*, int);</code></pre><h2 id="3-Using-auto-or-decltype-for-Function-Pointer-Types"><a href="#3-Using-auto-or-decltype-for-Function-Pointer-Types" class="headerlink" title="(3) Using auto or decltype for Function Pointer Types"></a>(3) Using auto or decltype for Function Pointer Types</h2><p>If we know which function(s) we want to return, we can use <strong>decltype</strong> to simplify writing a function pointer return type. </p><p>For example, assume we have two functions, both of which return a <code>string::size_type</code> and have two <code>const string&amp;</code> parameters. </p><p>We can write a third function that takes a string parameter and returns a pointer to one of these two functions as follows:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span>::size_type <span class="hljs-title">sumLength</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;)</span></span>;<span class="hljs-function"><span class="hljs-built_in">string</span>::size_type <span class="hljs-title">largerLength</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;)</span></span>;<span class="hljs-comment">// depending on the value of its string parameter,</span><span class="hljs-comment">// getFcn returns a pointer to sumLength or to largerLength</span><span class="hljs-keyword">decltype</span>(sumLength) *getFcn(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Statements</title>
    <link href="/2021/01/12/Statements/"/>
    <url>/2021/01/12/Statements/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 5 Statements</p><a id="more"></a><h1 id="1-switch"><a href="#1-switch" class="headerlink" title="1. switch"></a>1. switch</h1><p><a href="https://www.learncpp.com/cpp-tutorial/53-switch-statements/" target="_blank" rel="noopener">Switch statements</a></p><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> Color&#123;    black,    white&#125;color;<span class="hljs-keyword">switch</span> (color)&#123;    <span class="hljs-keyword">case</span> Color::black:        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Black"</span>;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> Color::white:        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"White"</span>;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Unknown"</span>;        <span class="hljs-keyword">break</span>;&#125;</code></pre><p>A <strong>switch</strong> statement executes by evaluating the parenthesized expression that follows the keyword <strong>switch</strong>. </p><p>That <strong>expression</strong> may be an initialized variable declaration. The expression is converted to <strong>integral type</strong>. </p><p>The one restriction on this <strong>expression</strong> is that it must evaluate to an <strong>integral</strong> type (that is, char, short, int, long, long long, or <a href="https://www.learncpp.com/cpp-tutorial/45-enumerated-types/" target="_blank" rel="noopener">enum</a>). Floating point variables, strings, and other non-integral types may not be used here.</p><p>The result of the <strong>expression</strong> is compared with the value associated with each <strong>case</strong>, which is declared using the <strong>case</strong> keyword and followed by a <strong>constant expression</strong>.</p><p>A <strong>constant expression</strong> is one that evaluates to a constant value – in other words, either a <strong>literal</strong> (such as 5), an <strong>enum</strong> (such as Color::red), or a <strong>constant variable</strong> (such as x, when x has been defined as a <strong>const int</strong>).</p><p>If we need to define and initialize a variable for a particular case, we can do so by defining the variable inside a block, thereby ensuring that the variable is out of scope at the point of any subsequent label.</p><pre><code class="hljs cpp"><span class="hljs-keyword">case</span> <span class="hljs-literal">true</span>:&#123;    <span class="hljs-comment">// ok: declaration statement within a statement block</span>    <span class="hljs-built_in">string</span> file_name = get_file_name();    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-literal">false</span>:    <span class="hljs-keyword">if</span> (file_name.empty()) <span class="hljs-comment">// error: file_name is not in scope</span></code></pre><h1 id="2-Range-for"><a href="#2-Range-for" class="headerlink" title="2. Range for"></a>2. Range for</h1><p>The syntactic form of the range for statement is:</p><pre><code class="hljs less"><span class="hljs-selector-tag">for</span> (<span class="hljs-attribute">declaration </span>: expression)<span class="hljs-selector-tag">statement</span></code></pre><p><strong>expression</strong> must represent a <strong>sequence</strong>, such as a braced initializer list , an array, or an <strong>object of a type</strong> such as <strong>vector</strong> or <strong>string</strong> that has <strong>begin</strong> and <strong>end</strong> members that return iterators.</p><p><strong>declaration</strong> defines a <strong>variable</strong>. It must be possible to convert each element of the sequence to the variable’s type.</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-comment">// range variable must be a reference so we can write to the elements</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;r : v) <span class="hljs-comment">// for each element in v</span>    r *= <span class="hljs-number">2</span>; <span class="hljs-comment">// double the value of each element in v</span></code></pre><p>The for header declares the loop control variable <code>r</code>, and associates it with <code>v</code>. </p><p>We use <code>auto</code> to let the compiler infer the correct type for <code>r</code>. </p><p>Because we want to <strong>change the value</strong> of the elements in <code>v</code>, we declare <code>r</code> as a <strong>reference</strong>. </p><h1 id="3-goto"><a href="#3-goto" class="headerlink" title="3. goto"></a>3. goto</h1><p>A goto statement provides an unconditional jump from the goto to a another statement in the same function.</p><pre><code class="hljs cpp"><span class="hljs-comment">// . . .</span><span class="hljs-keyword">goto</span> end;<span class="hljs-keyword">int</span> ix = <span class="hljs-number">10</span>; <span class="hljs-comment">// error: goto bypasses an initialized variable definition</span>end:<span class="hljs-comment">// error: code here could use ix but the goto bypassed its declaration</span>ix = <span class="hljs-number">42</span>;</code></pre><p>A jump backward over an already executed definition is okay. Jumping back to a point before a variable is defined destroys the variable and constructs it again:</p><pre><code class="hljs cpp"><span class="hljs-comment">// backward jump over an initialized variable definition is okay</span>begin:<span class="hljs-keyword">int</span> sz = get_size();<span class="hljs-keyword">if</span> (sz &lt;= <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">goto</span> begin;&#125;</code></pre><p>Here <code>sz</code> is destroyed when the goto executes. It is defined and initialized again when control passes back through its definition after the jump back to begin.</p><h1 id="4-try-Blocks-and-Exception-Handling"><a href="#4-try-Blocks-and-Exception-Handling" class="headerlink" title="4. try Blocks and Exception Handling"></a>4. try Blocks and Exception Handling</h1><h2 id="1-throw-Expression"><a href="#1-throw-Expression" class="headerlink" title="(1) throw Expression"></a>(1) throw Expression</h2><p>The detecting part of a program uses a throw expression to raise an exception. A <strong>throw</strong> consists of the <strong>keyword throw</strong> followed by an <strong>expression</strong>. </p><p>The type of the expression determines what kind of exception is thrown. </p><pre><code class="hljs cpp">Sales_item item1, item2;<span class="hljs-built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2;<span class="hljs-comment">// first check that item1 and item2 represent the same book</span><span class="hljs-keyword">if</span> (item1.isbn() == item2.isbn()) &#123;    <span class="hljs-built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// indicate success</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Data must refer to same ISBN"</span>    &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// indicate failure</span>&#125;</code></pre><p>rewrite the above code to throw an exception rather than returning an error indicator:</p><pre><code class="hljs cpp"><span class="hljs-comment">// first check that the data are for the same item</span><span class="hljs-keyword">if</span> (item1.isbn() != item2.isbn())    <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Data must refer to same ISBN"</span>);<span class="hljs-comment">// if we're still here, the ISBNs are the same</span><span class="hljs-built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><p>Throwing an exception <strong>terminates</strong> the current function and <strong>transfers control</strong> to a handler that will know how to handle this error.</p><p>The type <strong>runtime_error</strong> is one of the standard library exception types and is defined in the <strong>stdexcept</strong> header.</p><h2 id="2-try-Block"><a href="#2-try-Block" class="headerlink" title="(2) try Block"></a>(2) try Block</h2><pre><code class="hljs cpp"><span class="hljs-keyword">try</span> &#123;program-statements&#125; <span class="hljs-keyword">catch</span> (exception-declaration) &#123;handler-statements&#125; <span class="hljs-keyword">catch</span> (exception-declaration) &#123;handler-statements&#125; <span class="hljs-comment">// . . .</span></code></pre><p>A <strong>try</strong> block begins with the keyword <strong>try</strong> followed by a <strong>block</strong>, which, as usual, is a sequence of statements enclosed in curly braces.</p><p>Following the try block is a list of one or more <strong>catch clauses</strong>. </p><p>A <strong>catch</strong> consists of <strong>three</strong> parts: the keyword <strong>catch</strong>, the <strong>declaration</strong> of a (possibly unnamed) object within parentheses (referred to as an exception declaration), and a <strong>block</strong>. </p><p>When a catch is selected to handle an exception, the associated block is executed. </p><p>Once the catch <strong>finishes</strong>, execution <strong>continues</strong> with the statement immediately following the last catch clause of the try block.</p><p>If <strong>no appropriate catch</strong> is found, execution is transferred to a library function named <strong>terminate</strong>. </p><p>The behavior of that function is <strong>system dependent</strong> but is guaranteed to <strong>stop further execution</strong> of the program</p><p>Some programs use exceptions simply to terminate the program when an<br>exceptional condition occurs. Such programs generally don’t worry about exception safety.</p><h2 id="3-Standard-Exceptions"><a href="#3-Standard-Exceptions" class="headerlink" title="(3) Standard Exceptions"></a>(3) Standard Exceptions</h2><p>The <strong>exception header</strong> defines the most general kind of exception class named <strong>exception</strong>. </p><p>It communicates only that an exception occurred but provides no additional information.</p><p>The <strong>stdexcept</strong> header defines several general-purpose exception classes.</p><p><img src="https://img-blog.csdnimg.cn/20200528210147708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>The <strong>new</strong> header defines the <strong>bad_alloc exception</strong> type.</p><p>The <strong>type_info</strong> header defines the <strong>bad_cast exception</strong> type.</p><p>The library exception classes have only a few operations. We can <strong>create</strong>, <strong>copy</strong>, and <strong>assign</strong> objects of any of the exception types.</p><p>We can only <strong>default initialize</strong> exception, <strong>bad_alloc</strong>, and <strong>bad_cast</strong> objects; it is not possible to provide an <strong>initializer</strong> for objects of these exception types.</p><p>The <strong>other exception</strong> types have the <strong>opposite behavior</strong>: We can initialize those objects from either a string or a C-style string, but we <strong>cannot default initialize them</strong>.</p><p>When we create objects of any of these other exception types, we <strong>must supply</strong> an <strong>initializer</strong>. That initializer is used to provide additional information about the <strong>error</strong> that occurred.</p><p>The exception types define <strong>only a single operation</strong> named <strong>what</strong>. </p><p>That function <strong>takes no arguments</strong> and <strong>returns</strong> a <strong>const char*</strong> that points to a C-style character string . </p><p>The <strong>purpose</strong> of this C-style character string is to provide some sort of <strong>textual description of the exception thrown</strong>.</p><p>The contents of the C-style string that <strong>what</strong> returns depends on the type of the exception object. For the types that take a string initializer, the what function returns that string. For the other types, the value of the string that what returns varies by compiler.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Storage Classes Linkage and Memory Management</title>
    <link href="/2021/01/07/Storage-Classes-Linkage-and-Memory-Management/"/>
    <url>/2021/01/07/Storage-Classes-Linkage-and-Memory-Management/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 12 Storage Classes Linkage and Memory Management</p><a id="more"></a><h1 id="1-Scope"><a href="#1-Scope" class="headerlink" title="1. Scope"></a>1. Scope</h1><p>Scope describes the region or regions of a program that can access an identifier. </p><p>A C variable has one of the following scopes: block scope, function scope, function prototype scope, or file scope. </p><h2 id="1-block-scope"><a href="#1-block-scope" class="headerlink" title="(1) block scope"></a>(1) block scope</h2><p>A block is a region of code contained within an opening brace and the matching closing brace. </p><p>A variable defined inside a block has block scope, and it is visible from the point it is defined until the end of the block containing the definition. </p><p>Formal function parameters, even though they occur before the opening brace of a function, have block scope and belong to the block containing the function body. </p><h2 id="2-function-scope"><a href="#2-function-scope" class="headerlink" title="(2) function scope"></a>(2) function scope</h2><p>Function scope applies just to labels used with goto statements. </p><p>This means that even if a label first appears inside an inner block in a function, its scope extends to the whole function. </p><p>It would be confusing if you could use the same label inside two separate blocks, and function scope for labels prevents this from happening.</p><p>Function prototype scope applies to variable names used in function prototypes, as in the following:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mighty</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mouse, <span class="hljs-keyword">double</span> large)</span></span>;</code></pre><p>Function prototype scope runs from the point the variable is defined to the end of the prototype declaration. </p><p>What this means is that all the compiler cares about when handling a function prototype argument is the types; the names you use, if any, normally don’t matter, and they needn’t match the names you use in the function definition. </p><p>One case in which the names matter a little is with variable-length array parameters:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use_a_VLA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, ar[n][m])</span></span>;</code></pre><p>If you use names in the brackets, they have to be names declared earlier in the prototype.</p><h2 id="3-file-scope"><a href="#3-file-scope" class="headerlink" title="(3) file scope"></a>(3) file scope</h2><p>A variable with its definition placed outside of any function has file scope. </p><p>A variable with file scope is visible from the point it is defined to the end of the file containing the definition. </p><p>Because they can be used in more than one function, file scope variables are also called global variables.</p><p>The compiler sees a single file containing information from your source code file and all the header files. </p><p>This single file is called a <strong>translation unit</strong>. </p><p>When we describe a variable as having file scope, it’s actually visible to the whole translation unit. </p><p>If your program consists of several source code files, then it will consist of several translation units.</p><h1 id="2-Linkage"><a href="#2-Linkage" class="headerlink" title="2. Linkage"></a>2. Linkage</h1><p>A C variable has one of the following linkages: external linkage, internal linkage, or no linkage. </p><p>Variables with block scope, function scope, or function prototype scope have no linkage. </p><p>That means they are private to the block, function, or prototype in which they are defined. </p><p>A variable with file scope can have either internal or external linkage.</p><p>A variable with external linkage can be used anywhere in a multifile program. </p><p>A variable with internal linkage can be used anywhere in a single translation unit.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> giants = <span class="hljs-number">5</span>; <span class="hljs-comment">// file scope, external linkage</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> dodgers = <span class="hljs-number">3</span>; <span class="hljs-comment">// file scope, internal linkage</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ...&#125;...</code></pre><h1 id="3-Storage-Duration"><a href="#3-Storage-Duration" class="headerlink" title="3. Storage Duration"></a>3. Storage Duration</h1><p>Scope and linkage describe the visibility of identifiers. </p><p>Storage duration describes the persistence of the objects accessed by these identifiers. </p><p>A C object has one of the following four storage durations: static storage duration, thread storage duration, automatic storage duration, or allocated storage duration.</p><h2 id="1-static-storage-duration"><a href="#1-static-storage-duration" class="headerlink" title="(1) static storage duration"></a>(1) static storage duration</h2><p>If an object has static storage duration, it exists throughout program execution. It’s created when the program is loaded and ends when the program terminates.</p><p>Variables with file scope have static storage duration. </p><p>Note that for file scope variables, the keyword static indicates the linkage type, not the storage duration. </p><h2 id="2-thread-storage-duration"><a href="#2-thread-storage-duration" class="headerlink" title="(2) thread storage duration"></a>(2) thread storage duration</h2><p>Thread storage duration comes into play in concurrent programming, in which program execution can be divided into multiple threads. </p><p>An object with thread storage duration exists from when it’s declared until the thread terminates. </p><p>Such an object is created when a declaration that would otherwise create a file scope object is modified with the keyword _Thread_local.</p><p>When a variable is declared with this specifier, each thread gets its own private copy of that variable.</p><h2 id="3-automatic-storage-duration"><a href="#3-automatic-storage-duration" class="headerlink" title="(3) automatic storage duration"></a>(3) automatic storage duration</h2><p>Variables with block scope normally have automatic storage duration. </p><p>These variables have memory allocated for them when the program enters the block in which they are defined, and the memory is freed when the block is exited. </p><p>The idea is that memory used for automatic variables is a workspace or scratch pad that can be reused. </p><p>Variable-length arrays provide a slight exception in that they exist from the point of declaration to the end of the block rather than from the beginning of the block to the end.</p><h1 id="4-Five-Storage-Classes"><a href="#4-Five-Storage-Classes" class="headerlink" title="4. Five Storage Classes"></a>4. Five Storage Classes</h1><h2 id="1-Automatic-Variables"><a href="#1-Automatic-Variables" class="headerlink" title="(1) Automatic Variables"></a>(1) Automatic Variables</h2><p>A variable belonging to the automatic storage class has automatic storage duration, block scope, and no linkage.</p><p>Automatic variables are not initialized unless you do so explicitly. </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//The keyword auto is termed a storage-class specifier.</span>    <span class="hljs-keyword">auto</span> <span class="hljs-keyword">int</span> i; <span class="hljs-comment">//uninitialized</span>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; <span class="hljs-comment">//automatic variable without explicitly using auto</span>&#125;</code></pre><h2 id="2-Register-Variables"><a href="#2-Register-Variables" class="headerlink" title="(2) Register Variables"></a>(2) Register Variables</h2><p>register variables are stored in the CPU registers or, more generally, in the fastest memory available, where they can be accessed and manipulated more rapidly than regular variables. </p><p>Because a register variable may be in a register rather than in memory, you can’t take the address of a register variable. </p><p>In most other respects, register variables are the same as automatic variables. </p><p>That is, they have block scope, no linkage, and automatic storage duration. </p><p>A variable is declared by using the storage class specifier register:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> quick;    ...&#125;</code></pre><p>A variable as a register class is more a request than a direct order. </p><p>The compiler has to weigh your demands against the number of registers or amount of fast memory available, or it can simply ignore the request. </p><p>In that case, the variable becomes an ordinary automatic variable; however, you still can’t use the address operator with it.</p><h2 id="3-Static-Variables-with-Block-Scope"><a href="#3-Static-Variables-with-Block-Scope" class="headerlink" title="(3) Static Variables with Block Scope"></a>(3) Static Variables with Block Scope</h2><p>You also can create local variables having block scope but static duration. </p><p>These variables have the same scope as automatic variables, but they don’t vanish when the containing function ends its job. </p><p>That is, such variables have block scope, no linkage, but static storage duration.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">try</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> j = <span class="hljs-number">2</span>;&#125;</code></pre><p><code>i</code> is initialized each time <code>try()</code> is called, but <code>j</code> is initialized just once, when <code>try()</code> is <strong>compiled</strong>.</p><p>Only <code>try()</code> is allowed to see <code>j</code>, but <code>static j = 2;</code> is not executed during runtime.</p><p>Static variables are initialized to zero if you don’t explicitly initialize them to some other value.</p><p>static variables and external variables are already in place after a program is loaded into memory.</p><h2 id="4-Static-Variables-with-External-Linkage"><a href="#4-Static-Variables-with-External-Linkage" class="headerlink" title="(4) Static Variables with External Linkage"></a>(4) Static Variables with External Linkage</h2><p>A static variable with external linkage has file scope, external linkage, and static storage duration. </p><p>This class is sometimes termed the external storage class, and variables of this type are called external variables. </p><p>You create an external variable by placing a defining declaration outside of any function. </p><p>An external variable can additionally be declared inside a function that uses it by using the <code>extern</code> keyword. </p><p>If a particular external variable is defined in one source code file and is used in a second source code file, declaring the variable in the second file with <code>extern</code> is mandatory. </p><pre><code class="hljs c"><span class="hljs-keyword">int</span> Errupt; <span class="hljs-comment">/* externally defined variable */</span><span class="hljs-keyword">double</span> Up[<span class="hljs-number">100</span>]; <span class="hljs-comment">/* externally defined array */</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> Coal; <span class="hljs-comment">/* mandatory declaration if */</span><span class="hljs-comment">/* Coal defined in another file */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> Errupt; <span class="hljs-comment">/* optional declaration */</span>    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> Up[]; <span class="hljs-comment">/* optional declaration */</span>...&#125;</code></pre><p>Note that you don’t have to give the array size in the optional declaration of double <code>Up</code>. That’s because the original declaration already supplied that information. </p><p>The group of extern declarations inside <code>main()</code> can be omitted entirely because external variables have file scope, so they are known from the point of declaration to the end of the file. </p><p>If only extern is omitted from the declaration inside a function, a separate automatic variable is set up. </p><p>That is, replacing <code>extern int Errupt;</code> with <code>int Errupt;</code> in <code>main()</code> causes the compiler to create an automatic variable named <code>Errupt</code>. </p><p>external variables are initialized automatically to zero if you don’t initialize them.</p><p>This rule applies to elements of an externally defined array, too. </p><p>Unlike the case for automatic variables, you can use only <strong>constant expressions</strong> to initialize <strong>file scope</strong> variables:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// ok, 10 is constant</span><span class="hljs-keyword">int</span> y = <span class="hljs-number">3</span> + <span class="hljs-number">20</span>; <span class="hljs-comment">// ok, a constant expression</span><span class="hljs-keyword">size_t</span> z = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>); <span class="hljs-comment">// ok, a constant expression</span><span class="hljs-keyword">int</span> x2 = <span class="hljs-number">2</span> * x; <span class="hljs-comment">// not ok, x is a variable</span></code></pre><p>As long as the type is not a variable array, a sizeof expression is considered a constant expression.</p><p>An external variable can be initialized only once, and that must occur when the variable is defined. </p><pre><code class="hljs c"><span class="hljs-comment">// file one.c</span><span class="hljs-keyword">char</span> permis = <span class="hljs-string">'N'</span>;...<span class="hljs-comment">// file two.c</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> permis = <span class="hljs-string">'Y'</span>; <span class="hljs-comment">/* error */</span></code></pre><p>The keyword extern indicates that a declaration is not a definition because it instructs the compiler to look elsewhere.</p><h2 id="5-Static-Variables-with-Internal-Linkage"><a href="#5-Static-Variables-with-Internal-Linkage" class="headerlink" title="(5) Static Variables with Internal Linkage"></a>(5) Static Variables with Internal Linkage</h2><p>Variables of this storage class have static storage duration, file scope, and internal linkage. </p><p>You create one by defining it outside of any function (just as with an external variable) with the storage class specifier <code>static</code>:</p><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> svil = <span class="hljs-number">1</span>; <span class="hljs-comment">// static variable, internal linkage</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    ...&#125;</code></pre><p>The ordinary external variable can be used by functions in any file that’s part of the program, but the static variable with internal linkage can be used only by functions in the same file. </p><p>You can redeclare any file scope variable within a function by using the storage class specifier <code>extern</code>. </p><p>Such a declaration doesn’t change the linkage. Consider the following code:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> traveler = <span class="hljs-number">1</span>; <span class="hljs-comment">// external linkage</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> stayhome = <span class="hljs-number">1</span>; <span class="hljs-comment">// internal linkage</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> traveler; <span class="hljs-comment">// use global traveler</span>    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> stayhome; <span class="hljs-comment">// use global stayhome</span>&#125;</code></pre><h1 id="4-Storage-Class-Specifier-Roundup"><a href="#4-Storage-Class-Specifier-Roundup" class="headerlink" title="4. Storage-Class Specifier Roundup"></a>4. Storage-Class Specifier Roundup</h1><p>The C language has six keywords that are grouped together as storage-class specifiers. They are auto, register, static, extern, _Thread_local, and typedef.</p><p>The extern specifier indicates that you are declaring a variable that has been defined elsewhere. </p><p>If the declaration containing extern has file scope, the variable referred to must have external linkage. </p><p>If the declaration containing extern has block scope, the referred-to variable can have either external linkage or internal linkage, depending on the defining declaration for that variable.</p><h1 id="5-malloc-and-free"><a href="#5-malloc-and-free" class="headerlink" title="5. malloc() and free()"></a>5. malloc() and free()</h1><p>Then malloc() finds a suitable block of free memory. The memory is anonymous; that is, malloc() allocates memory but it doesn’t assign a name to it. However, it does return the address of the first byte of that block.</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> * ptd;ptd = (<span class="hljs-keyword">double</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">30</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>));</code></pre><p>The free() function takes as its argument an address returned earlier by malloc() and frees up the memory that had been allocated.</p><h1 id="6-calloc"><a href="#6-calloc" class="headerlink" title="6. calloc()"></a>6. calloc()</h1><pre><code class="hljs c"><span class="hljs-keyword">long</span> *newmen;newmem = (<span class="hljs-keyword">long</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">100</span>, <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">long</span>));</code></pre><p>The calloc() function throws in one more feature: It sets all the bits in the block to zero. (Note, however, that on some hardware systems, a floating-point value of 0 is not represented by all bits set to 0.)</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lvalue</title>
    <link href="/2021/01/05/lvalue/"/>
    <url>/2021/01/05/lvalue/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="1-Definition"><a href="#1-Definition" class="headerlink" title="1. Definition"></a>1. Definition</h1><blockquote><p><a href="http://port70.net/~nsz/c/c11/n1570.html#6.3.2.1" target="_blank" rel="noopener">lvalue</a><br>An lvalue is an expression (with an object type other than void) that potentially designates an object;</p></blockquote><p>1 A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a const- qualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a const- qualified type.</p><blockquote><p>C Primer Plus (6th)<br>Consider an assignment statement. Its purpose is to store a value at a memory location. Data object is a general term for a region of data storage that can be used to hold values. The C standard uses just the term object for this concept. </p></blockquote><p>For example, you could specify an element of an array, a member of a structure, or use a pointer expression that involves the address of the object. </p><p>C uses the term lvalue to mean any such name or expression that identifies a particular data object. </p><p>Object refers to the actual data storage, but an lvalue is a label used to identify, or locate, that storage.</p><p>In the early days of C, saying something was an lvalue meant two things:</p><ol><li><p>It specified an object, hence referred to an address in memory.</p></li><li><p>It could be used on the left side of an assignment operator, hence the “l” in lvalue.</p></li></ol><p>But then C added the const modifier. This allows you to create an object, but one whose value cannot be changed.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> ex;<span class="hljs-keyword">int</span> why = <span class="hljs-number">2</span>, zee = <span class="hljs-number">4</span>;ex = why + zee;</code></pre><p>The expression <code>why + zee</code> is an rvalue; it doesn’t represent a specific memory location and you can’t assign to it. It’s just a temporary value the program calculates, and then discards when it’s finished with it.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt = &amp;entity;<span class="hljs-keyword">int</span> ranks[<span class="hljs-number">10</span>];</code></pre><p><code>pt</code> is an identifier. It designates an object that holds an address. </p><p>The expression <code>*pt</code> is not an identifier because it’s not a name. However, it does designate an object.</p><p>The expression <code>ranks + 2 * entity</code> is neither an identifier (not a name) nor an lvalue. </p><p>But the expression <code>*(ranks + 2 * entity)</code> is an lvalue because it does designate the value of a particular memory location.</p><h1 id="2-Operators-and-lvalue"><a href="#2-Operators-and-lvalue" class="headerlink" title="2. Operators and lvalue"></a>2. Operators and lvalue</h1><h2 id="1-Address-Operator-amp"><a href="#1-Address-Operator-amp" class="headerlink" title="(1) Address Operator &amp;"></a>(1) Address Operator &amp;</h2><blockquote><p>The C Programming Language<br>The unary <code>&amp;</code> takes the address of its operand. The operand must be an lvalue referring neither to a bit-field nor to an object declared as register, or must be of function type.</p></blockquote><blockquote><p>C Primer Plus (6th)</p></blockquote><pre><code class="hljs c">ptr = &amp;pooh; <span class="hljs-comment">// assigns pooh's address to ptr</span></code></pre><p>We say that <code>ptr</code> “points to” <code>pooh</code>. The difference between <code>ptr</code> and <code>&amp;pooh</code> is that <code>ptr</code> is a variable, and <code>&amp;pooh</code> is a constant. Or, <code>ptr</code> is a modifiable lvalue and <code>&amp;pooh</code> is an rvalue.</p><h2 id="2-Indirection-Operator"><a href="#2-Indirection-Operator" class="headerlink" title="(2) Indirection Operator *"></a>(2) Indirection Operator *</h2><blockquote><p>The C Programming Language<br>The unary <code>*</code> operator denotes indirection, and returns the object or function to which its operand points. </p></blockquote><p>It is an lvalue if the operand is a pointer to an object of arithmetic, structure, union, or pointer type. </p><p>The operand may not be an lvalue, such as, <code>*(&amp;p)</code>.</p><h2 id="3-and-–"><a href="#3-and-–" class="headerlink" title="(3) ++ and –"></a>(3) ++ and –</h2><p>The operand is incremented ++ or decremented – by 1. </p><p>The value of the expression is the value after the incrementation (decrementation). </p><p>The operand must be an lvalue;</p><p>The result is not an lvalue.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>Supplement</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Expressions</title>
    <link href="/2020/12/29/Expressions/"/>
    <url>/2020/12/29/Expressions/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 4 Expressions</p><a id="more"></a><h1 id="1-Lvalues-and-Rvalues"><a href="#1-Lvalues-and-Rvalues" class="headerlink" title="1. Lvalues and Rvalues"></a>1. Lvalues and Rvalues</h1><p>Every expression in C++ is either an <strong>rvalue</strong> or an <strong>lvalue</strong>.</p><p>In C++, an <strong>lvalue expression</strong> yields an object or a function. </p><p>Roughly speaking, when we use an object as an <strong>rvalue</strong>, we use the object’s <strong>value</strong> (its contents). </p><p>When we use an object as an <strong>lvalue</strong>, we use the object’s <strong>identity</strong> (its location in memory).</p><ul><li><p><strong>Assignment</strong> requires a (nonconst) <code>lvalue</code> as its left-hand operand and yields its <strong>left-hand operand as an lvalue</strong>.</p></li><li><p>The <strong>address-of operator</strong> requires an <strong>lvalue</strong> operand and <strong>returns</strong> a <strong>pointer</strong> to its operand <strong>as an rvalue</strong>.</p></li><li><p>The built-in dereference and subscript operators and the iterator dereference and string and vector subscript operators all yield <strong>lvalues</strong>.</p></li><li><p>The built-in and iterator <strong>increment and decrement</strong> operators <strong>require lvalue</strong> operands and the prefix versions also <strong>yield lvalues</strong>.</p></li></ul><p><strong>Lvalues and rvalues also differ when used with decltype</strong>.</p><p>When we apply <strong>decltype to an expression</strong> (other than a variable), the result is a <strong>reference</strong> type if the expression yields an <strong>lvalue</strong>. </p><p>As an example, assume <code>p</code> is an <code>int*</code>. Because dereference yields an <strong>lvalue</strong> <code>decltype(*p)</code> is <code>int&amp;</code>. </p><p>On the other hand, because the address-of operator yields an <strong>rvalue</strong> <code>decltype(&amp;p)</code> is <code>int**</code>, that is, a pointer to a pointer to type int.</p><p>The left-hand operand of an assignment operator must be a <strong>modifiable lvalue</strong>. For example, given</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>; <span class="hljs-comment">// initializations, not assignment</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i; <span class="hljs-comment">// initialization, not assignment</span></code></pre><pre><code class="hljs cpp"><span class="hljs-number">1024</span> = k; <span class="hljs-comment">// error: literals are rvalues</span>i + j = k; <span class="hljs-comment">// error: arithmetic expressions are rvalues</span>ci = k; <span class="hljs-comment">// error: ci is a const (nonmodifiable) lvalue</span></code></pre><p>The <strong>result of an assignment</strong> is its <strong>left-hand operand</strong>, which is an <strong>lvalue</strong>. </p><p>The <strong>type of the result</strong> is the type of the left-hand operand. </p><p>If the <strong>types</strong> of the left and right operands <strong>differ</strong>, the <strong>right-hand</strong> operand is <strong>converted</strong> to the type of the <strong>left</strong>:</p><pre><code class="hljs cpp">k = <span class="hljs-number">0</span>; <span class="hljs-comment">// result: type int, value 0</span>k = <span class="hljs-number">3.14159</span>; <span class="hljs-comment">// result: type int, value 3</span></code></pre><p>Under the new standard, we can use a <strong>braced initializer list</strong> on the right-hand side:</p><pre><code class="hljs cpp">k = &#123;<span class="hljs-number">3.14</span>&#125;; <span class="hljs-comment">// error: narrowing conversion</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi; <span class="hljs-comment">// initially empty</span>vi = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;</code></pre><p>If the <strong>left-hand operand</strong> is of a <strong>built-in type</strong>, the <strong>initializer list</strong> may contain at most one value, and that value <strong>must not</strong> require a <strong>narrowing conversion</strong>.</p><p>Regardless of the type of the left-hand operand, the initializer list may be empty. </p><p>In this case, the compiler generates a <strong>value-initialized</strong> temporary and assigns that value to the left-hand operand.</p><p>Unlike the other binary operators, assignment is <strong>right associative</strong>.</p><h1 id="2-Arithmetic-Operators"><a href="#2-Arithmetic-Operators" class="headerlink" title="2. Arithmetic Operators"></a>2. Arithmetic Operators</h1><p>In a <strong>division</strong>, the <a href="http://eel.is/c++draft/expr.mul#:operator,division" target="_blank" rel="noopener">new standard</a> requires the quotient to be rounded toward zero (i.e., truncated).</p><p>The <strong>modulus operator</strong> is defined so that if m and n are integers and n is nonzero, then <strong>(m/n)*n + m%n</strong> is equal to m. </p><p><strong>By implication, if **m%n</strong> is nonzero, it has the same sign as <strong>m</strong>.**</p><pre><code class="hljs angelscript"><span class="hljs-number">21</span> % <span class="hljs-number">6</span>; <span class="hljs-comment">/* result is 3 */</span> <span class="hljs-number">21</span> / <span class="hljs-number">6</span>; <span class="hljs-comment">/* result is 3 */</span><span class="hljs-number">21</span> % <span class="hljs-number">7</span>; <span class="hljs-comment">/* result is 0 */</span> <span class="hljs-number">21</span> / <span class="hljs-number">7</span>; <span class="hljs-comment">/* result is 3 */</span><span class="hljs-number">-21</span> % <span class="hljs-number">-8</span>; <span class="hljs-comment">/* result is -5 */</span> <span class="hljs-number">-21</span> / <span class="hljs-number">-8</span>; <span class="hljs-comment">/* result is 2 */</span><span class="hljs-number">21</span> % <span class="hljs-number">-5</span>; <span class="hljs-comment">/* result is 1 */</span> <span class="hljs-number">21</span> / <span class="hljs-number">-5</span>; <span class="hljs-comment">/* result is -4 */</span></code></pre><h1 id="3-Precedence-and-Associativity"><a href="#3-Precedence-and-Associativity" class="headerlink" title="3. Precedence and Associativity"></a>3. Precedence and Associativity</h1><p><img src="https://img-blog.csdnimg.cn/20200129093415373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200129093555366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200129093618503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200129093634253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="4-Order-of-Evaluation"><a href="#4-Order-of-Evaluation" class="headerlink" title="4. Order of Evaluation"></a>4. Order of Evaluation</h1><p><strong>Precedence</strong> specifies how the operands are grouped. It says nothing about the <strong>order</strong> in which the <strong>operands are evaluated</strong>. </p><p>In most cases, the order is largely <strong>unspecified</strong>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = f1() * f2();</code></pre><p>we know that <code>f1</code> and <code>f2</code> must be called before the multiplication can be done. </p><p>However, we have no way of knowing whether <code>f1</code> will be called before <code>f2</code> or vice versa.</p><p>For operators that do not specify evaluation order, it is an error for an expression to refer to and change the <strong>same object</strong>. </p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; ++i &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// undefined</span></code></pre><p>The compiler might evaluate <code>++i</code> before evaluating <code>i</code>.</p><p>There are <strong>four operators</strong> that do <strong>guarantee the order</strong> in which <strong>operands are evaluated</strong>.</p><p>The logical <strong>AND (&amp;&amp;)</strong> operator guarantees that its <strong>left-hand operand is evaluated first</strong>. </p><p>Moreover, we are also guaranteed that the <strong>right-hand</strong> operand is evaluated <strong>only if the left-hand operand is true</strong>.</p><p>The only other operators that guarantee the order in which operands are evaluated are the <strong>logical OR (||)</strong> operator, the <strong>conditional (? : )</strong> operator, and the <strong>comma (,)</strong> operator </p><h1 id="5-Increment-and-Decrement-Operators"><a href="#5-Increment-and-Decrement-Operators" class="headerlink" title="5. Increment and Decrement Operators"></a>5. Increment and Decrement Operators</h1><p>There are <strong>two forms</strong> of these operators: prefix and postfix. </p><p>The <strong>prefix</strong> increments (or decrements) its operand and <strong>yields the changed object</strong> as its result. </p><p>The <strong>postfix</strong> operators increment (or decrement) the operand but <strong>yield a copy of the original</strong>, unchanged value as its result.</p><p>The <strong>postfix operator</strong> must <strong>store the original value</strong> so that it can return the unincremented value as its result.</p><pre><code class="hljs cpp"><span class="hljs-comment">// the behavior of the following loop is undefined!</span><span class="hljs-keyword">while</span> (beg != s.end() &amp;&amp; !<span class="hljs-built_in">isspace</span>(*beg))    *beg = <span class="hljs-built_in">toupper</span>(*beg++); <span class="hljs-comment">// error: this assignment is undefined</span></code></pre><p>The problem is that both the left and right-hand operands to = use beg and the right-hand operand changes beg. </p><p>The compiler might evaluate this expression as either</p><pre><code class="hljs cpp"><span class="hljs-comment">// execution if left-hand side is evaluated first</span>*beg = <span class="hljs-built_in">toupper</span>(*beg); <span class="hljs-comment">// execution if right-hand side is evaluated first</span>*(beg + <span class="hljs-number">1</span>) = <span class="hljs-built_in">toupper</span>(*beg);</code></pre><h1 id="6-sizeof"><a href="#6-sizeof" class="headerlink" title="6. sizeof"></a>6. sizeof</h1><p>The <strong>sizeof</strong> operator returns the size, in <strong>bytes</strong>, of an expression or a type name. </p><p>The operator is <strong>right associative</strong>. </p><p>The result of <strong>sizeof</strong> is a <strong>constant expression</strong> of type <code>size_t</code>.</p><p>The operator takes one of two forms:</p><pre><code class="hljs cpp"><span class="hljs-keyword">sizeof</span> (type)<span class="hljs-keyword">sizeof</span> expr</code></pre><p><strong>sizeof an array</strong> is the size of the entire array. It is equivalent to taking the sizeof the element type times the number of elements in the array. </p><p><strong>sizeof a string</strong> or a <strong>vector</strong> returns only the size of the fixed part of these types; it does not return the size used by the object’s elements.</p><p>Note that sizeof does not convert the array to a pointer.</p><h1 id="7-Type-Conversion"><a href="#7-Type-Conversion" class="headerlink" title="7. Type Conversion"></a>7. Type Conversion</h1><h2 id="1-implicit-conversions"><a href="#1-implicit-conversions" class="headerlink" title="(1) implicit conversions"></a>(1) implicit conversions</h2><ul><li><p>In <strong>most expressions</strong>, values of integral types smaller than <code>int</code> are first promoted to an appropriate larger integral type.</p></li><li><p>In <strong>conditions</strong>, nonbool expressions are converted to bool.</p></li><li><p>In <strong>initializations</strong>, the initializer is converted to the type of the variable; </p></li><li><p>in <strong>assignments</strong>, the right-hand operand is converted to the type of the left-hand.</p></li><li><p>In <strong>arithmetic and relational expressions</strong> with operands of mixed types, the types are converted to a common type.</p></li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">3.541</span> + <span class="hljs-number">3</span>; <span class="hljs-comment">// the compiler might warn about loss of precision</span></code></pre><ol><li><p><code>3</code> is converted to double, floating-point addition is done, and the result is a double.</p></li><li><p>The double result of the addition is converted to <code>int</code> and used to initialize <code>ival</code>.</p></li></ol><h2 id="2-The-Arithmetic-Conversions"><a href="#2-The-Arithmetic-Conversions" class="headerlink" title="(2) The Arithmetic Conversions"></a>(2) The Arithmetic Conversions</h2><p>The <strong>arithmetic conversions</strong> convert one arithmetic type to another. </p><p>The rules define a hierarchy of type conversions in which operands to an operator are converted to the <strong>widest type</strong>.</p><h2 id="3-Other-Implicit-Conversions"><a href="#3-Other-Implicit-Conversions" class="headerlink" title="(3) Other Implicit Conversions"></a>(3) Other Implicit Conversions</h2><h3 id="Array-to-Pointer-Conversions"><a href="#Array-to-Pointer-Conversions" class="headerlink" title="Array to Pointer Conversions"></a>Array to Pointer Conversions</h3><p>In most expressions, when we use an array, the array is automatically converted to a pointer to the first element in that array.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">10</span>]; <span class="hljs-comment">// array of ten ints</span><span class="hljs-keyword">int</span>* ip = ia; <span class="hljs-comment">// convert ia to a pointer to the first element</span></code></pre><p>This conversion is <strong>not performed</strong> when an array is used with <strong>decltype</strong> or as the operand of the <strong>address-of</strong> ( &amp; ), <strong>sizeof</strong>, or <strong>typeid</strong> operators. </p><p>The conversion is also <strong>omitted</strong> when we <strong>initialize a reference</strong> to an array.</p><h2 id="4-Pointer-Conversions"><a href="#4-Pointer-Conversions" class="headerlink" title="(4) Pointer Conversions"></a>(4) Pointer Conversions</h2><ul><li><p>A constant integral value of <strong>0</strong> and the literal <strong>nullptr</strong> can be converted to any pointer type.</p></li><li><p>A pointer to any nonconst type can be converted to <strong>void*</strong>.</p></li><li><p>A pointer to any type can be converted to a <strong>const void*</strong>.</p></li></ul><h2 id="5-Conversions-to-bool"><a href="#5-Conversions-to-bool" class="headerlink" title="(5) Conversions to bool"></a>(5) Conversions to bool</h2><p>There is an <strong>automatic conversion</strong> from arithmetic or pointer types to bool. </p><p>If the pointer or arithmetic value is zero, the conversion yields false; any other value yields true.</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> *cp = get_string();<span class="hljs-keyword">if</span> (cp) <span class="hljs-comment">/* ... */</span> <span class="hljs-comment">// true if the pointer cp is not zero</span><span class="hljs-keyword">while</span> (*cp) <span class="hljs-comment">/* ... */</span> <span class="hljs-comment">// true if *cp is not the null character</span></code></pre><h2 id="6-Conversion-to-const"><a href="#6-Conversion-to-const" class="headerlink" title="(6) Conversion to const"></a>(6) Conversion to const</h2><p>We <strong>can</strong> convert a <strong>pointer to a nonconst</strong> type to a <strong>pointer to the corresponding const type</strong>, and similarly for <strong>references</strong>. </p><p>That is, if <code>T</code> is a type, we can convert a pointer or a reference to <code>T</code> into a pointer or reference to <strong>const T</strong>, respectively.</p><h2 id="7-Conversions-Defined-by-Class-Types"><a href="#7-Conversions-Defined-by-Class-Types" class="headerlink" title="(7) Conversions Defined by Class Types"></a>(7) Conversions Defined by Class Types</h2><p>Class types can define conversions that the compiler will apply automatically. </p><pre><code class="hljs cpp"><span class="hljs-comment">// character string literal converted to type string</span><span class="hljs-built_in">string</span> s, t = <span class="hljs-string">"a value"</span>; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; s) <span class="hljs-comment">// while condition converts cin to bool</span></code></pre><p>The condition <code>(cin &gt;&gt; s)</code> reads <code>cin</code> and yields <code>cin</code> as its result. </p><p>Conditions expect a value of type bool, but this condition tests a value of type istream. </p><p>The <strong>IO library</strong> defines a conversion from istream to bool. </p><p>That conversion is used (automatically) to convert <code>cin</code> to bool. </p><p>The resulting bool value depends on the state of the stream. </p><p>If the last read succeeded, then the conversion yields true. If the last attempt failed, then the conversion to bool yields false.</p><h2 id="8-Named-Casts"><a href="#8-Named-Casts" class="headerlink" title="(8) Named Casts"></a>(8) Named Casts</h2><pre><code class="hljs elm"><span class="hljs-title">cast</span>-name&lt;<span class="hljs-keyword">type</span>&gt;(expression);</code></pre><p>Where <code>type</code> is the target type of the conversion, and <code>expression</code> is the value to be cast. </p><p>If <code>type</code> is a reference, then the result is an <code>lvalue</code>. </p><p>The cast-name may be one of <strong>static_cast</strong>, <strong>dynamic_cast</strong>, <strong>const_cast</strong>, and <strong>reinterpret_cast</strong>.</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>Any well-defined type conversion, other than those involving low-level const, can be requested using a <strong>static_cast</strong>. </p><pre><code class="hljs cpp"><span class="hljs-comment">// cast used to force floating-point division</span><span class="hljs-keyword">double</span> slope = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(j) / i;</code></pre><p>A <code>static_cast</code> is <strong>often useful</strong> when a <strong>larger arithmetic</strong> type is assigned to a <strong>smaller type</strong>. </p><p>A <code>static_cast</code> is <strong>also useful</strong> to perform a conversion that the compiler will not generate automatically.</p><pre><code class="hljs cpp"><span class="hljs-comment">// ok: address of any nonconst object can be stored in a void*</span><span class="hljs-keyword">void</span>* p = &amp;d; <span class="hljs-comment">// ok: converts void* back to the original pointer type</span><span class="hljs-keyword">double</span> *dp = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>*&gt;(p);</code></pre><p>The result of the cast will be equal to the original address value.</p><p>However, we <strong>must be certain</strong> that the type to which we cast the pointer is the <strong>actual type</strong> of that pointer; if the types do <strong>not match</strong>, the result is <strong>undefined</strong>.</p><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>A <strong>const_cast</strong> changes only a low-level const in its operand</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pc;<span class="hljs-keyword">char</span> *p = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(pc); <span class="hljs-comment">// ok: but writing through p is undefined ？？？</span></code></pre><p>Conventionally we say that a cast that converts a const object to a nonconst type “<strong>casts away the const</strong>.” </p><p><strong>Once we have cast away the const of an object, the compiler will no longer prevent us from writing to that object.</strong> </p><p>If the object was originally not a const, using a cast to obtain write access is legal. </p><p>Only a <strong>const_cast</strong> may be used to change the <strong>constness</strong> of an expression.</p><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>A <strong>reinterpret_cast</strong> generally performs a <strong>low-level reinterpretation</strong> of the bit pattern of its operands.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ip;<span class="hljs-keyword">char</span> *pc = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(ip);</code></pre><p>We must never forget that the <strong>actual object</strong> addressed by <code>pc</code> is an <strong>int</strong>, <strong>not a character</strong>. </p><p>Any use of <code>pc</code> that assumes it’s an ordinary character pointer is likely to fail at run time:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">(pc)</span></span>;</code></pre><p>is likely to result in bizarre run-time behavior.</p><h3 id="Old-Style-Casts"><a href="#Old-Style-Casts" class="headerlink" title="Old-Style Casts"></a>Old-Style Casts</h3><p>In early versions of C++, an explicit cast took one of the following two forms:</p><pre><code class="hljs cpp">type (expr); <span class="hljs-comment">// function-style cast notation</span>(type) expr; <span class="hljs-comment">// C-language-style cast notation</span></code></pre><p>When we use an old-style cast where a <strong>static_cast</strong> or a <strong>const_cast</strong> would be legal, the old-style cast does <strong>the same conversion</strong> as the respective named cast. If neither cast is legal, then an old-style cast performs a <strong>reinterpret_cast</strong>. For example:</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> *pc = (<span class="hljs-keyword">char</span>*) ip; <span class="hljs-comment">// ip is a pointer to int</span></code></pre><p>has the same effect as using a <code>reinterpret_cast</code>.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strings-Vectors-and-Arrays</title>
    <link href="/2020/12/29/Strings-Vectors-and-Arrays/"/>
    <url>/2020/12/29/Strings-Vectors-and-Arrays/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 3 Strings-Vectors-and-Arrays</p><a id="more"></a><h1 id="1-using-declaration"><a href="#1-using-declaration" class="headerlink" title="1. using declaration"></a>1. using declaration</h1><p><a href="http://eel.is/c++draft/basic.namespace" target="_blank" rel="noopener">Namespaces</a> </p><p>A <strong>using</strong> declaration lets us use a name from a namespace without qualifying the <code>name</code> with a namespace_name <strong>::</strong> prefix.</p><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>::name;</code></pre><p>Once the <strong>using</strong> declaration has been made, we can access <code>name</code> directly.</p><p>Code inside headers ordinarily should not use <strong>using</strong> declarations.<br>The reason is that the contents of a header are copied into the including program’s text. </p><p>If a header has a using declaration, then every program that includes that header gets that same <strong>using</strong> declaration. </p><p>As a result, a program that didn’t intend to use the specified library name might <strong>encounter unexpected name conflicts</strong>.</p><h1 id="2-Library-string-Type"><a href="#2-Library-string-Type" class="headerlink" title="2. Library string Type"></a>2. Library string Type</h1><p>A string is a <strong>variable-length sequence of characters</strong>. </p><p>To use the string type, we must include the <strong>string header</strong>. </p><p>Because it is part of the library, string is defined in the <strong>std namespace</strong>. </p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>;</code></pre><h2 id="1-Defining-and-Initializing-strings"><a href="#1-Defining-and-Initializing-strings" class="headerlink" title="(1) Defining and Initializing strings"></a>(1) Defining and Initializing strings</h2><p>Each class defines how objects of its type can be initialized. </p><p>A class may define <strong>many different ways to initialize objects</strong> of its type. </p><p>Each way must be <strong>distinguished</strong> from the others either by the <strong>number of initializers</strong> that we supply, or by the <strong>types of those initializers</strong>. </p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1; <span class="hljs-comment">// default initialization; s1 is the empty string</span><span class="hljs-built_in">string</span> s2 = s1; <span class="hljs-comment">// s2 is a copy of s1</span><span class="hljs-built_in">string</span> s3 = <span class="hljs-string">"hiya"</span>; <span class="hljs-comment">// s3 is a copy of the string literal</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>)</span></span>; <span class="hljs-comment">// s4 is cccccccccc</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200126165219910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="2-Direct-and-Copy-Forms-of-Initialization"><a href="#2-Direct-and-Copy-Forms-of-Initialization" class="headerlink" title="(2) Direct and Copy Forms of Initialization"></a>(2) Direct and Copy Forms of Initialization</h2><p>When we initialize a variable using <strong>=</strong>, we are asking the compiler to <strong>copy</strong> initialize the object by <strong>copying the initializer</strong> on the right-hand side into the object being created.</p><p>Otherwise, when we omit the =, we use <strong>direct initialization</strong>.</p><p>When we have a <strong>single initializer</strong>, we can use either the direct or copy form of initialization. </p><p>When we initialize a variable from <strong>more than one value</strong>, such as in the initialization of s4 above, we must use the <strong>direct form of initialization</strong>:</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s5 = <span class="hljs-string">"hiya"</span>; <span class="hljs-comment">// copy initialization</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s6</span><span class="hljs-params">(<span class="hljs-string">"hiya"</span>)</span></span>; <span class="hljs-comment">// direct initialization</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s7</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>)</span></span>; <span class="hljs-comment">// direct initialization; s7 is cccccccccc</span></code></pre><p>When we want to use several values, we can <strong>indirectly</strong> use the <strong>copy form</strong> of initialization by <strong>explicitly</strong> creating a <strong>(temporary) object</strong> to copy:</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s8 = <span class="hljs-built_in">string</span>(<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>); <span class="hljs-comment">// copy initialization; s8 is cccccccccc</span></code></pre><h3 id="Difference-between-direct-and-copy-Initialization"><a href="#Difference-between-direct-and-copy-Initialization" class="headerlink" title="Difference between direct and copy Initialization"></a>Difference between direct and copy Initialization</h3><p><a href="https://stackoverflow.com/a/1051395/12342782" target="_blank" rel="noopener">Is there a difference between copy initialization and direct initialization?</a></p><h2 id="3-Operations-on-strings"><a href="#3-Operations-on-strings" class="headerlink" title="(3) Operations on strings"></a>(3) Operations on strings</h2><p><img src="https://img-blog.csdnimg.cn/20200126170111949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="4-Reading-and-Writing-strings"><a href="#4-Reading-and-Writing-strings" class="headerlink" title="(4) Reading and Writing strings"></a>(4) Reading and Writing strings</h2><p>We use the iostream library to read and write values of <strong>built-in</strong> types such as int, double, and so on. </p><p>We use the same IO operators to read and write strings:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">string</span> s; <span class="hljs-comment">// empty string</span>    <span class="hljs-built_in">cin</span> &gt;&gt; s; <span class="hljs-comment">// read a whitespace-separated string into s</span>    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// write s to the output</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>The string input operator reads and <strong>discards any leading whitespace</strong> (e.g., spaces, newlines, tabs). </p><p>It then reads characters until the <strong>next whitespace</strong> character is encountered.</p><p>Like the input and output operations on the built-in types, the string operators <strong>return their left-hand operand as their result</strong>. </p><p>Thus, we can <strong>chain together multiple reads or writes</strong>:</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1, s2;<span class="hljs-built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2; <span class="hljs-comment">// read first input into s1, second into s2</span><span class="hljs-built_in">cout</span> &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// write both strings</span></code></pre><h2 id="5-Reading-an-Unknown-Number-of-strings"><a href="#5-Reading-an-Unknown-Number-of-strings" class="headerlink" title="(5) Reading an Unknown Number of strings"></a>(5) Reading an Unknown Number of strings</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">string</span> word;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; word) <span class="hljs-comment">// read until end-of-file</span>        <span class="hljs-built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// write each word followed by a new line</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>If the stream is valid—it hasn’t hit <strong>end-of-file</strong> or encountered<br>an <strong>invalid input</strong>—then the body of the while is executed. </p><h2 id="6-Using-getline-to-Read-an-Entire-Line"><a href="#6-Using-getline-to-Read-an-Entire-Line" class="headerlink" title="(6) Using getline to Read an Entire Line"></a>(6) Using getline to Read an Entire Line</h2><p>The getline function takes an input stream and a string. </p><p>This function reads the given stream up to and <strong>including the first newline</strong> and stores what it read—<strong>not including the newline</strong>—in its string argument. </p><p>After getline sees a <strong>newline</strong>, even if it is the first character in<br>the input, it <strong>stops reading and returns</strong>. </p><p>If the first character in the input is a newline, then the resulting string is the <strong>empty string</strong>.</p><p>Like the input operator, getline <strong>returns its istream</strong> argument. </p><p><strong>The newline that causes getline to return is discarded; the newline is not stored in the string.</strong></p><h2 id="7-The-string-empty-and-size-Operations"><a href="#7-The-string-empty-and-size-Operations" class="headerlink" title="(7) The string empty and size Operations"></a>(7) The string empty and size Operations</h2><p>The empty function does what one would expect: It returns a <strong>bool</strong>  indicating whether the string is empty.</p><pre><code class="hljs cpp"><span class="hljs-comment">// read input a line at a time and discard blank lines</span><span class="hljs-keyword">while</span> (getline(<span class="hljs-built_in">cin</span>, line))    <span class="hljs-keyword">if</span> (!line.empty())        <span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><p>The <strong>size member</strong> returns the <strong>length</strong> of a string. size returns a <strong>string::size_type</strong> value.</p><p>Although we don’t know the precise type of <strong>string::size_type</strong>, we do know that it is an <strong>unsigned type</strong> big enough to hold the size of any string. </p><p>Any variable used to store the result from the string size operation should be of type <strong>string::size_type</strong>.</p><p>Admittedly, it can be tedious to type <strong>string::size_type</strong>. Under the new standard, we can ask the compiler to provide the appropriate type by using <strong>auto or decltype</strong>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> len = line.size(); <span class="hljs-comment">// len has type string::size_type</span></code></pre><h2 id="8-Comparing-strings"><a href="#8-Comparing-strings" class="headerlink" title="(8) Comparing strings"></a>(8) Comparing strings</h2><p>The <strong>equality operators</strong> (== and !=) test whether two strings are <strong>equal or unequal</strong>, respectively. </p><p>Two strings are equal if they are the <strong>same length and contain the same characters</strong>. </p><p>The relational operators <strong>&lt;, &lt;=, &gt;, &gt;=</strong> test whether one string is less than, less than or equal to, greater than, or greater than or equal to another.</p><p>These operators use the same strategy as a (<strong>case-sensitive</strong>) dictionary:</p><h2 id="9-Assignment-for-strings"><a href="#9-Assignment-for-strings" class="headerlink" title="(9) Assignment for strings"></a>(9) Assignment for strings</h2><pre><code class="hljs cpp">string st1(10, 'c'), st2; // st1 is cccccccccc; st2 is an empty stringst1 = st2; <span class="hljs-comment">// assignment: replace contents of st1 with a copy of st2</span><span class="hljs-comment">// both st1 and st2 are now the empty string</span></code></pre><h2 id="10-Adding-Two-strings"><a href="#10-Adding-Two-strings" class="headerlink" title="(10) Adding Two strings"></a>(10) Adding Two strings</h2><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"hello, "</span>, s2 = <span class="hljs-string">"world\n"</span>;<span class="hljs-built_in">string</span> s3 = s1 + s2; <span class="hljs-comment">// s3 is hello, world\n</span>s1 += s2; <span class="hljs-comment">// equivalent to s1 = s1 + s2</span></code></pre><h2 id="11-Adding-Literals-and-strings"><a href="#11-Adding-Literals-and-strings" class="headerlink" title="(11) Adding Literals and strings"></a>(11) Adding Literals and strings</h2><p>The string library lets us convert both character literals and character string literals to strings.</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"hello"</span>, s2 = <span class="hljs-string">"world"</span>; <span class="hljs-comment">// no punctuation in s1 or s2</span><span class="hljs-built_in">string</span> s3 = s1 + <span class="hljs-string">", "</span> + s2 + <span class="hljs-string">'\n'</span>;</code></pre><p>When we mix strings and string or character literals, <strong>at least one operand</strong> to <strong>each +</strong> operator must be of <strong>string type</strong>:</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s4 = s1 + <span class="hljs-string">", "</span>; <span class="hljs-comment">// ok: adding a string and a literal</span><span class="hljs-built_in">string</span> s5 = <span class="hljs-string">"hello"</span> + <span class="hljs-string">", "</span>; <span class="hljs-comment">// error: no string operand</span><span class="hljs-built_in">string</span> s6 = s1 + <span class="hljs-string">", "</span> + <span class="hljs-string">"world"</span>; <span class="hljs-comment">// ok: each + has a string operand</span><span class="hljs-built_in">string</span> s7 = <span class="hljs-string">"hello"</span> + <span class="hljs-string">", "</span> + s2; <span class="hljs-comment">// error: can't add string literals</span></code></pre><p>The subexpression <code>s1 + &quot;, &quot;</code><strong>returns a string</strong>, which forms the left-hand operand of the second <code>+</code> operator. It is as if we had written：</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> tmp = s1 + <span class="hljs-string">", "</span>; <span class="hljs-comment">// ok: + has a string operand</span>s6 = tmp + <span class="hljs-string">"world"</span>; <span class="hljs-comment">// ok: + has a string operand</span></code></pre><h2 id="12-Dealing-with-the-Characters-in-a-string"><a href="#12-Dealing-with-the-Characters-in-a-string" class="headerlink" title="(12) Dealing with the Characters in a string"></a>(12) Dealing with the Characters in a string</h2><p><strong>cctype Functions：</strong><br><img src="https://img-blog.csdnimg.cn/20200126192859119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="13-Range-Based-for-Processing-Every-Character"><a href="#13-Range-Based-for-Processing-Every-Character" class="headerlink" title="(13) Range-Based for: Processing Every Character"></a>(13) Range-Based for: Processing Every Character</h2><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (declaration : expression)    statement</code></pre><p>Where <strong>expression</strong> is an <strong>object</strong> of a type that represents <strong>a sequence</strong>, and <strong>declaration</strong> defines the variable that we’ll use to access the <strong>underlying elements</strong> in the sequence.</p><p>On <strong>each iteration</strong>, the variable in declaration is initialized from the value of the next element in expression.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"some string"</span>)</span></span>;<span class="hljs-comment">// print the characters in str one character to a line</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : str) <span class="hljs-comment">// for every char in str</span>    <span class="hljs-built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// print the current character followed by a newline</span></code></pre><p>In this case, we use <strong>auto</strong> to let the compiler determine the type of <code>c</code>, which in this case will be char. </p><p>On each iteration, the next character in <code>str</code> will be copied into <code>c</code>. </p><p>Thus, we can read this loop as saying, “For every character c in the string str,” do something. </p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"Hello World!!!"</span>)</span></span>;<span class="hljs-comment">// punct_cnt has the same type that s.size returns; see § 2.5.3 (p. 70)</span><span class="hljs-keyword">decltype</span>(s.size()) punct_cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">// count the number of punctuation characters in s</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) <span class="hljs-comment">// for every char in s</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ispunct</span>(c)) <span class="hljs-comment">// if the character is punctuation</span>        ++punct_cnt; <span class="hljs-comment">// increment the punctuation counter</span><span class="hljs-built_in">cout</span> &lt;&lt; punct_cnt&lt;&lt; <span class="hljs-string">" punctuation characters in "</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><h2 id="14-Change-the-Characters-in-a-string"><a href="#14-Change-the-Characters-in-a-string" class="headerlink" title="(14) Change the Characters in a string"></a>(14) Change the Characters in a string</h2><p>If we want to change the value of the characters in a string, we must define the loop variable as a reference type.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"Hello World!!!"</span>)</span></span>;<span class="hljs-comment">// convert s to uppercase</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s) <span class="hljs-comment">// for every char in s (note: c is a reference)</span>    c = <span class="hljs-built_in">toupper</span>(c); <span class="hljs-comment">// c is a reference, so the assignment changes the char in s</span><span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><h2 id="15-Processing-Only-Some-Characters"><a href="#15-Processing-Only-Some-Characters" class="headerlink" title="(15) Processing Only Some Characters"></a>(15) Processing Only Some Characters</h2><p>There are two ways to access individual characters in a string: We can use a subscript or an iterator. </p><p>Subscripts for strings start at zero, and the last character is in <code>s[s.size() - 1]</code>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!s.empty()) <span class="hljs-comment">// make sure there's a character to print</span>    <span class="hljs-built_in">cout</span> &lt;&lt; s[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// print the first character in s</span></code></pre><h1 id="3-Library-vector-Type"><a href="#3-Library-vector-Type" class="headerlink" title="3. Library vector Type"></a>3. Library vector Type</h1><p>A vector is a collection of objects, all of which have the same type. Every object in the collection has an associated index, which gives access to that object. </p><p>A vector is often referred to as a container because it “contains” other objects.</p><p>A vector is a class template. C++ has both class and function templates.</p><p>Templates are not themselves functions or classes. Instead, they can be thought of as instructions to the compiler for generating classes or functions.</p><p>Because references are not objects, we cannot have a vector of references.</p><h2 id="1-Defining-and-Initializing-vectors"><a href="#1-Defining-and-Initializing-vectors" class="headerlink" title="(1) Defining and Initializing vectors"></a>(1) Defining and Initializing vectors</h2><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec <span class="hljs-comment">// default initialization; svec is empty</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec1</span><span class="hljs-params">(svec)</span></span>; <span class="hljs-comment">//svec1 has a copy of each element in svec</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec2 = svec; <span class="hljs-comment">//copy elements of svec into svec2</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">"hi"</span>)</span></span>; <span class="hljs-comment">//ten strings; each element is "hi"</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec4</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//ten elements; each an empty string</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// ten elements; each initialized to 0</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ivec1&#123;<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">// one element with value 10</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec5&#123;<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">// ten default-initialized elements</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec6 = &#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"an"</span>&#125;; <span class="hljs-comment">// two elements; list initialization</span></code></pre><h2 id="2-vector-Operations"><a href="#2-vector-Operations" class="headerlink" title="(2) vector Operations"></a>(2) vector Operations</h2><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">100</span>; i++)    v1.push_back(i);</code></pre><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : v1)    i *= i;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//size member returns a value of the size_type </span><span class="hljs-comment">//defined by the corresponding vector type</span><span class="hljs-comment">//vector&lt;int&gt;::size_type</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ivec;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">decltype</span>(ivec.size()) ix = <span class="hljs-number">0</span>; ix != <span class="hljs-number">10</span>; ++ix)    ivec.push_back(ix);</code></pre><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-built_in">cout</span> &lt;&lt; ivec1[<span class="hljs-number">0</span>];</code></pre><h1 id="5-Using-Iterators"><a href="#5-Using-Iterators" class="headerlink" title="5. Using Iterators"></a>5. Using Iterators</h1><p>Types that have iterators have members that <strong>return iterators</strong>. </p><p>In particular, these types have members named <strong>begin</strong> and <strong>end</strong>. </p><p>The begin member returns an iterator that denotes the first element (or first character):</p><pre><code class="hljs cpp"><span class="hljs-comment">// the compiler determines the type of b and e; </span><span class="hljs-comment">// b denotes the first element and e denotes one past the last element </span><span class="hljs-keyword">auto</span> b = v.begin(), e = v.end(); <span class="hljs-comment">// b and e have the same type</span></code></pre><p>The iterator returned by <strong>end</strong> is an iterator positioned <strong>one past the end</strong> of the associated container (or string). </p><p>It is used as a <strong>marker</strong> indicating when we have processed all the elements. </p><p>If the container is <strong>empty</strong>, begin returns the <strong>same</strong> iterator as the one returned by end.</p><p>If the container is empty, the iterators returned by begin and end are equal—they are both off-the-end iterators.</p><p><img src="https://img-blog.csdnimg.cn/20200127201927385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>As with pointers, we can <strong>dereference</strong> an iterator to obtain the element denoted by an iterator.</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"some string"</span>)</span></span>;<span class="hljs-keyword">if</span> (s.begin() != s.end()) &#123; <span class="hljs-comment">// make sure s is not empty</span><span class="hljs-keyword">auto</span> it = s.begin(); <span class="hljs-comment">// it denotes the first character in s</span>*it = <span class="hljs-built_in">toupper</span>(*it); <span class="hljs-comment">// make that character uppercase</span>&#125;</code></pre><p>Because the iterator returned from end does not denote an element, it may not be incremented or dereferenced.</p><p>C++ programmers use <strong>!=</strong> as a matter of habit. </p><p>By routinely using iterators and !=, we don’t have to worry about the precise type of container we’re processing.</p><p>As with <code>size_type</code>, the library types that have iterators define types named <strong>iterator</strong> and <strong>const_iterator</strong> that represent actual iterator types:</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it; <span class="hljs-comment">// it can read and write vector&lt;int&gt; elements</span><span class="hljs-built_in">string</span>::iterator it2; <span class="hljs-comment">// it2 can read and write characters in a string</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator it3; <span class="hljs-comment">// it3 can read but not write elements</span><span class="hljs-built_in">string</span>::const_iterator it4; <span class="hljs-comment">// it4 can read but not write</span></code></pre><p>If the object is <code>const</code>, then <code>begin</code> and <code>end</code> return a <code>const_iterator</code>; if the object is not const, they return <code>iterator</code>:</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; cv;<span class="hljs-keyword">auto</span> it1 = v.begin(); <span class="hljs-comment">// it1 has type vector&lt;int&gt;::iterator</span><span class="hljs-keyword">auto</span> it2 = cv.begin(); <span class="hljs-comment">// it2 has type vector&lt;int&gt;::const_iterator</span></code></pre><p>To let us ask specifically for the <strong>const_iterator</strong> type, the new standard introduced two new functions named <strong>cbegin</strong> and <strong>cend</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it3 = v.cbegin(); <span class="hljs-comment">// it3 has type vector&lt;int&gt;::const_iterator</span></code></pre><p>Assuming it is an <code>iterator</code> into this vector, we can check whether the string that it denotes is empty as follows:</p><pre><code class="hljs cpp">(*it).empty()</code></pre><p>The arrow operator (the <strong>-&gt;</strong> operator)combines dereference and member access into a single operation. </p><p>That is, <strong>it-&gt;mem</strong> is a synonym for <strong>(* it).mem</strong>.</p><p>We noted that there are implications of the fact that <strong>vectors</strong> can <strong>grow dynamically</strong>. </p><p>We also noted that one such implication is that we <strong>cannot</strong> add elements to a vector inside a <strong>range for loop</strong>. </p><p>Another implication is that <strong>any operation</strong>, such as <strong>push_back</strong>, that <strong>changes the size of a vector</strong> potentially <strong>invalidates</strong> all iterators into that vector. </p><p><strong>Warning:</strong><br>It is important to realize that loops that use iterators <strong>should not</strong> <strong>add elements</strong> to the container to which the <strong>iterators refer</strong>.</p><p><img src="https://img-blog.csdnimg.cn/20200127211310408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">We can also subtract two iterators so long as they refer to elements in, or one off the end of, the same vector or string. </p><p>The result is the distance between the iterators. </p><p>The result type is a <strong>signed integral type</strong> named <strong>difference_type</strong>.</p><p>A classic algorithm that uses iterator arithmetic is binary search. </p><pre><code class="hljs cpp"><span class="hljs-comment">// text must be sorted</span><span class="hljs-comment">// beg and end will denote the range we're searching</span><span class="hljs-keyword">auto</span> beg = text.begin(), end = text.end();<span class="hljs-keyword">auto</span> mid = text.begin() + (end - beg)/<span class="hljs-number">2</span>; <span class="hljs-comment">// original midpoint</span><span class="hljs-keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;    <span class="hljs-keyword">if</span> (sought &lt; *mid) <span class="hljs-comment">// is the element we want in the first half?</span>        end = mid; <span class="hljs-comment">// if so, adjust the range to ignore the second half</span>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// the element we want is in the second half</span>        beg = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// start looking with the element just after mid</span>    mid = beg + (end - beg)/<span class="hljs-number">2</span>; <span class="hljs-comment">// new midpoint</span>&#125;</code></pre><h1 id="6-Arrays"><a href="#6-Arrays" class="headerlink" title="6. Arrays"></a>6. Arrays</h1><h2 id="1-Difference-between-array-and-vector"><a href="#1-Difference-between-array-and-vector" class="headerlink" title="(1) Difference between array and vector"></a>(1) Difference between array and vector</h2><p><strong>Like a vector</strong>, an array is a <strong>container</strong> of <strong>unnamed objects</strong> of a <strong>single type</strong> that we access by position.</p><p><strong>Unlike a vector</strong>, arrays have <strong>fixed size</strong>; we cannot add elements to an array.</p><h2 id="2-Complicated-Array-Declarations"><a href="#2-Complicated-Array-Declarations" class="headerlink" title="(2) Complicated Array Declarations"></a>(2) Complicated Array Declarations</h2><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ptrs[<span class="hljs-number">10</span>]; <span class="hljs-comment">// ptrs is an array of ten pointers to int</span><span class="hljs-keyword">int</span> &amp;refs[<span class="hljs-number">10</span>] = <span class="hljs-comment">/* ? */</span>; <span class="hljs-comment">// error: no arrays of references</span><span class="hljs-keyword">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr; <span class="hljs-comment">// Parray points to an array of ten ints</span><span class="hljs-keyword">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr; <span class="hljs-comment">// arrRef refers to an array of ten ints</span></code></pre><p>There are no limits on how many type modifiers can be used:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *(&amp;arry)[<span class="hljs-number">10</span>] = ptrs; <span class="hljs-comment">// arry is a reference to an array of ten pointers</span></code></pre><h2 id="3-Pointers-and-Arrays"><a href="#3-Pointers-and-Arrays" class="headerlink" title="(3) Pointers and Arrays"></a>(3) Pointers and Arrays</h2><p>In particular, as we’ll see, when we use an array, the compiler ordinarily <strong>converts the array to a pointer</strong>.</p><p>When we use an array as an initializer for a variable defined using <strong>auto</strong>, the deduced type is a <strong>pointer</strong>, <strong>not an array</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// ia is an array of ten ints</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>; <span class="hljs-comment">// ia2 is an int* that points to the first element in ia</span>ia2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// error: ia2 is a pointer, and we can't assign an int to a pointer</span></code></pre><p>It is worth noting that this conversion does not happen when we use <strong>decltype</strong>. The type returned by <code>decltype(ia)</code> is <strong>array</strong> of ten ints:</p><pre><code class="hljs cpp"><span class="hljs-comment">// ia3 is an array of ten ints</span><span class="hljs-keyword">decltype</span>(ia) ia3 = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;ia3 = p; <span class="hljs-comment">// error: can't assign an int* to an array</span>ia3[<span class="hljs-number">4</span>] = i; <span class="hljs-comment">// ok: assigns the value of i to an element in ia3</span></code></pre><h2 id="4-The-Library-begin-and-end-Functions"><a href="#4-The-Library-begin-and-end-Functions" class="headerlink" title="(4) The Library begin and end Functions"></a>(4) The Library begin and end Functions</h2><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// ia is an array of ten ints</span><span class="hljs-keyword">int</span> *beg = begin(ia); <span class="hljs-comment">// pointer to the first element in ia</span><span class="hljs-keyword">int</span> *last = end(ia); <span class="hljs-comment">// pointer one past the last element in ia</span></code></pre><p><strong>begin</strong> returns a <strong>pointer to the first</strong>, and <strong>end</strong> returns a <strong>pointer one past the last element</strong> in the given array. These functions are defined in the <strong>iterator header</strong>.</p><h2 id="5-Pointer-Arithmetic"><a href="#5-Pointer-Arithmetic" class="headerlink" title="(5) Pointer Arithmetic"></a>(5) Pointer Arithmetic</h2><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *b = arr, *e = arr + sz;<span class="hljs-keyword">while</span> (b &lt; e) &#123;<span class="hljs-comment">// use *b</span>    ++b;&#125;</code></pre><p><strong>We cannot use the relational operators on pointers to two unrelated objects:</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, sz = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> *p = &amp;i, *e = &amp;sz;<span class="hljs-comment">// undefined: p and e are unrelated; comparison is meaningless!</span><span class="hljs-keyword">while</span> (p &lt; e)</code></pre><h2 id="6-Subscripts-and-Pointers"><a href="#6-Subscripts-and-Pointers" class="headerlink" title="(6) Subscripts and Pointers"></a>(6) Subscripts and Pointers</h2><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = &amp;ia[<span class="hljs-number">2</span>]; <span class="hljs-comment">// p points to the element indexed by 2</span><span class="hljs-keyword">int</span> j = p[<span class="hljs-number">1</span>]; <span class="hljs-comment">// p[1] is equivalent to *(p + 1),</span><span class="hljs-comment">// p[1] is the same element as ia[3]</span><span class="hljs-keyword">int</span> k = p[<span class="hljs-number">-2</span>]; <span class="hljs-comment">// p[-2] is the same element as ia[0]</span></code></pre><p>Unlike subscripts for vector and string, the <strong>index of the built-in subscript</strong> operator is <strong>not an unsigned type</strong>.</p><h1 id="7-Multidimensional-Arrays"><a href="#7-Multidimensional-Arrays" class="headerlink" title="7. Multidimensional Arrays"></a>7. Multidimensional Arrays</h1><p>Strictly speaking, there are no multidimensional arrays in C++. What are commonly referred to as multidimensional arrays are actually <strong>arrays of arrays</strong>. </p><h2 id="1-Using-a-Range-for-with-Multidimensional-Arrays"><a href="#1-Using-a-Range-for-with-Multidimensional-Arrays" class="headerlink" title="(1) Using a Range for with Multidimensional Arrays"></a>(1) Using a Range for with Multidimensional Arrays</h2><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> rowCnt = <span class="hljs-number">3</span>, colCnt = <span class="hljs-number">4</span>;<span class="hljs-keyword">int</span> ia[rowCnt][colCnt]; <span class="hljs-comment">// 12 uninitialized elements</span><span class="hljs-comment">// for each row</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i != rowCnt; ++i) &#123;    <span class="hljs-comment">// for each column within the row</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> j = <span class="hljs-number">0</span>; j != colCnt; ++j) &#123;        <span class="hljs-comment">// assign the element's positional index as its value</span>        ia[i][j] = i * colCnt + j;    &#125;&#125;</code></pre><p>same as</p><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> rowCnt = <span class="hljs-number">3</span>, colCnt = <span class="hljs-number">4</span>;<span class="hljs-keyword">int</span> ia[rowCnt][colCnt];<span class="hljs-keyword">size_t</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;row : ia) <span class="hljs-comment">// for every element in the outer array</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;col : row) &#123; <span class="hljs-comment">// for every element in the inner array</span>        col = cnt; <span class="hljs-comment">// give this element the next value</span>        ++cnt; <span class="hljs-comment">// increment cnt</span>    &#125;</code></pre><p><font color = red>note</font><br>To use a multidimensional array in a range for, the loop control variable for<br>all but the innermost array must be <strong>references</strong>.</p><h2 id="2-Pointers-and-Multidimensional-Arrays"><a href="#2-Pointers-and-Multidimensional-Arrays" class="headerlink" title="(2) Pointers and Multidimensional Arrays"></a>(2) Pointers and Multidimensional Arrays</h2><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]; <span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">4</span>] = ia; <span class="hljs-comment">// p points to an array of four ints</span>p = &amp;ia[<span class="hljs-number">2</span>]; <span class="hljs-comment">// p now points to the last element in ia</span></code></pre><pre><code class="hljs cpp"><span class="hljs-comment">// p points to an array of four ints</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = ia; p != ia + <span class="hljs-number">3</span>; ++p) &#123;    <span class="hljs-comment">// q points to the first element of an array of four ints;</span>    <span class="hljs-comment">//that is, q points to an int</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> q = *p; q != *p + <span class="hljs-number">4</span>; ++q)        <span class="hljs-built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="hljs-string">' '</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><p>we can even more easily write this loop using the library <code>begin</code> and <code>end</code> functions：</p><pre><code class="hljs cpp"><span class="hljs-comment">// p points to the first array in ia</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = begin(ia); p != end(ia); ++p) &#123;    <span class="hljs-comment">// q points to the first element in an inner array</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> q = begin(*p); q != end(*p); ++q)        <span class="hljs-built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="hljs-string">' '</span>;     <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Variables and Basic Types</title>
    <link href="/2020/12/29/Variables-and-Basic-Types/"/>
    <url>/2020/12/29/Variables-and-Basic-Types/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 2 Variables and Basic Types</p><a id="more"></a><h1 id="1-Initializers"><a href="#1-Initializers" class="headerlink" title="1. Initializers"></a>1. Initializers</h1><p>An object that is initialized gets the specified value at the moment it is created.</p><p><strong>Warning:</strong><br><strong>Initialization is not assignment.</strong><br>Initialization happens when a variable is given a value when it is created. </p><p>Assignment obliterates an object’s current value and replaces that value with a new one.</p><h2 id="1-List-Initialization"><a href="#1-List-Initialization" class="headerlink" title="(1) List Initialization"></a>(1) List Initialization</h2><p>The language defines several different forms of initialization:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> units_sold = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> units_sold = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> units_sold&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">units_sold</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;</code></pre><p>The generalized use of curly braces for initialization is referred to as <strong>list initialization</strong>.</p><p>The compiler will not let us <strong>list initialize</strong> variables of built-in type if the initializer might lead to the <strong>loss of information</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> ld = <span class="hljs-number">3.1415926536</span>;<span class="hljs-keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class="hljs-comment">// error: narrowing conversion required</span>int c(ld), d = ld; // ok: but value will be truncated</code></pre><h2 id="2-Default-Initialization"><a href="#2-Default-Initialization" class="headerlink" title="(2) Default Initialization"></a>(2) Default Initialization</h2><p>When we define a variable without an initializer, the variable is <strong>default initialized</strong>.</p><p>The value of an object of <strong>built-in type</strong> that is <strong>not explicitly initialized</strong> depends on <strong>where it is defined</strong>. </p><p>Variables defined <strong>outside any function</strong> body are initialized to <strong>zero</strong>.</p><p>Variables of <strong>built-in type</strong> defined <strong>inside a function</strong> are <strong>uninitialized</strong>. </p><p>It is an error to copy or otherwise try to access the value of a variable whose value is undefined.</p><p>Objects of <strong>class type</strong> that we do not explicitly initialize have a value that is defined by the class.</p><p>Different of forms of initialization</p><p><a href="https://stackoverflow.com/questions/1051379/is-there-a-difference-between-copy-initialization-and-direct-initialization" target="_blank" rel="noopener">Is there a difference between copy initialization and direct initialization?</a></p><p><a href="https://stackoverflow.com/questions/29068684/different-forms-of-initialization" target="_blank" rel="noopener">Different forms of initialization</a></p><p><a href="http://www.cplusplus.com/doc/tutorial/variables/" target="_blank" rel="noopener">Initialization of variables</a></p><p><a href="http://eel.is/c++draft/dcl.init" target="_blank" rel="noopener">Initializers </a></p><h1 id="2-Identifiers"><a href="#2-Identifiers" class="headerlink" title="2. Identifiers"></a>2. Identifiers</h1><p>Identifiers in C++ can be composed of letters, digits, and the underscore character.</p><p>The language imposes no limit on name length. </p><p>Identifiers must begin with either a letter or an underscore. Identifiers are case-sensitive; upper- and lowercase letters are distinct.</p><p>The language reserves a set of names. These names may not be used as identifiers.<br><img src="https://img-blog.csdnimg.cn/20200124175004976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>The standard also reserves a set of names for use in the standard library. </p><p>The <strong>identifiers</strong> may not contain two consecutive underscores, nor can an identifier <strong>begin with an underscore followed immediately by an uppercase letter</strong>.</p><p>In addition, identifiers defined <strong>outside a function may not begin with an underscore</strong>.</p><h1 id="3-const-Qualifier"><a href="#3-const-Qualifier" class="headerlink" title="3. const Qualifier"></a>3. const Qualifier</h1><h2 id="1-Initialization"><a href="#1-Initialization" class="headerlink" title="(1) Initialization"></a>(1) Initialization</h2><p>We can make a variable unchangeable by defining the variable’s type as <strong>const</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = <span class="hljs-number">512</span>; <span class="hljs-comment">// input buffer size</span></code></pre><p><strong>Because we can’t change the value of a const object after we create it, it must be initialized.</strong> </p><p>By default, const objects are Local to a file. When a const object is initialized from a compile-time constant, such as in our definition of <code>bufSize</code>, the compiler will usually <strong>replace</strong> uses of the variable with its corresponding value <strong>during compilation</strong>. </p><p>To substitute the value for the variable, the compiler has to see the variable’s initializer. </p><p>When we split a program into multiple files, every file that uses the <strong>const</strong> must have access to its initializer.</p><p>In order to see the initializer, the variable must be defined in every file that wants to use the variable’s value. </p><p>To support this usage, yet avoid multiple definitions of the same variable, <strong>const</strong> variables are defined as local to the file. </p><p><strong>Sometimes we have a const variable that we want to share across multiple files but whose initializer is not a constant expression.</strong></p><p>To define a single instance of a <strong>const</strong> variable, we use the keyword <strong>extern</strong> on <strong>both its definition and declaration(s)</strong>:</p><pre><code class="hljs cpp"><span class="hljs-comment">// file_1.cc defines and initializes a const that </span><span class="hljs-comment">// is accessible to other files</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = fcn();<span class="hljs-comment">// file_1.h</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize; <span class="hljs-comment">// same bufSize as defined in file_1.cc</span></code></pre><p>In this program, <code>file_1.cc</code> defines and initializes <code>bufSize</code>. Because this declaration includes an initializer, it is (as usual) a definition. </p><p>However, because <code>bufSize</code> is <strong>const</strong>, we must specify <strong>extern</strong> in order for <code>bufSize</code> to be used in other files.</p><p>The declaration in <code>file_1.h</code> is also <code>extern</code>. In this case, the <code>extern</code> signifies that <code>bufSize</code> is not local to this file and that its definition will occur elsewhere.</p><h2 id="2-References-to-const"><a href="#2-References-to-const" class="headerlink" title="(2) References to const"></a>(2) References to const</h2><p>As with any other object, we can bind a reference to an object of a <strong>const</strong> type. </p><p>To do so we use a <strong>reference to const</strong>, which is a reference that refers to a <strong>const</strong> type.</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">1024</span>;<span class="hljs-comment">// ok: both reference and underlying object are const</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = ci; r1 = <span class="hljs-number">42</span>; <span class="hljs-comment">// error: r1 is a reference to const</span><span class="hljs-keyword">int</span> &amp;r2 = ci; <span class="hljs-comment">// error: non const reference to a const object</span></code></pre><p><strong>Terminology: const Reference is a Reference to const.</strong></p><p>C++ programmers tend to abbreviate the phrase “reference to const” as “const reference.” </p><p>Technically speaking, there are no <strong>const references</strong>. A reference is <strong>not an object</strong>, so we cannot make a reference itself <strong>const</strong>.</p><p>Indeed, because there is no way to make a reference refer to a different object, in some sense all references are <strong>const</strong>. </p><p><strong>Two exceptions to the rule that the type of a reference must match the type of the object to which it refers:</strong></p><ol><li><strong>We can initialize a reference to const from any expression that can be converted to the type of the reference.</strong> </li></ol><p>In particular, we can bind a reference to <strong>const</strong> to a <strong>nonconst</strong> object, a literal, or a more general expression:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = i; <span class="hljs-comment">// we can bind a const int&amp; to a plain int object</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// ok: r1 is a reference to const</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r3 = r1 * <span class="hljs-number">2</span>; <span class="hljs-comment">// ok: r3 is a reference to const</span><span class="hljs-keyword">int</span> &amp;r4 = r1 * <span class="hljs-number">2</span>; <span class="hljs-comment">// error: r4 is a plain, non const reference</span></code></pre><p>The easiest way to understand this difference in initialization rules is to consider what happens when we bind a reference to an object of a different type:</p><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ri = dval;</code></pre><p>To ensure that the object to which <code>ri</code> is bound is an <code>int</code>, the compiler transforms this code into something like:</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> temp = dval; <span class="hljs-comment">// create a temporary const int from the double</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ri = temp; <span class="hljs-comment">// bind ri to that temporary</span></code></pre><p>In this case, <code>ri</code> is bound to a <strong>temporary</strong> object. A temporary object is an unnamed object created by the compiler when it needs a place to store a result from evaluating an expression. </p><p>C++ programmers often use the word <strong>temporary</strong> as an abbreviation for temporary object.</p><p><strong>Now consider what could happen if this initialization were allowed but ri was not const:</strong> </p><p>If <code>ri</code> weren’t <strong>const</strong>, we could assign to <code>ri</code>. Doing so would change the object to which <code>ri</code> is bound. However, that object is a temporary, not <code>dval</code>. </p><p>Because binding a reference to a temporary is almost surely not what the programmer intended, the language makes it illegal.</p><ol start="2"><li><strong>A Reference to const May Refer to an Object That Is Not const</strong></li></ol><p>It is important to realize that a reference to const <strong>restricts only what we can do through that reference</strong>. </p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> &amp;r1 = i; <span class="hljs-comment">// r1 bound to i</span><span class="hljs-comment">// r2 also bound to i; but cannot be used to change i</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = i; r1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// r1 is not const; i is now 0; r2 = 0;</span>r2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// error: r2 is a reference to const</span></code></pre><p>Even so, <strong>the value int i still might change</strong>. We can change <code>i</code> by assigning to it directly, or by assigning to another reference bound to <code>i</code>, such as <code>r1</code>.</p><h2 id="3-Pointers-and-const"><a href="#3-Pointers-and-const" class="headerlink" title="(3) Pointers and const"></a>(3) Pointers and const</h2><p>Like a reference to <strong>const</strong>, a pointer to <strong>const</strong> may not be used to change the object to which the pointer points. </p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// pi is const; its value may not be changed</span><span class="hljs-keyword">double</span> *ptr = &amp;pi; <span class="hljs-comment">// error: ptr is a plain pointer</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *cptr = &amp;pi; <span class="hljs-comment">// ok: cptr may point to a double that is const</span>*cptr = <span class="hljs-number">42</span>; <span class="hljs-comment">// error: cannot assign to *cptr</span></code></pre><p><strong>There are two exceptions to the rule that the types of a pointer and the object to which it points must match:</strong></p><ol><li><strong>We can use a pointer to const to point to a nonconst object</strong></li></ol><p> <strong>Like a reference to const</strong>, a pointer to <strong>const</strong> says nothing about whether the object to which the pointer points is <strong>const</strong>. </p><p>Defining a <strong>pointer</strong> as a <strong>pointer to const</strong> affects only <strong>what we can do with the pointer.</strong> </p><p>It is important to remember that there is <strong>no guarantee that an object pointed to by a pointer to const won’t change</strong>.</p><ol start="2"><li><strong>Unlike references, pointers are objects</strong> </li></ol><p>Hence, as with any other object type, we can have a pointer that is itself <strong>const</strong>. </p><p>Like any other <strong>const object</strong>, a const pointer must be initialized, and once initialized, its value may not be changed. </p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> errNumb = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> curErr = &amp;errNumb; <span class="hljs-comment">// curErr will always point to errNumb</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14159</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *<span class="hljs-keyword">const</span> pip = &amp;pi; <span class="hljs-comment">// pip is a const pointer to a const object</span></code></pre><h2 id="4-Top-Level-const"><a href="#4-Top-Level-const" class="headerlink" title="(4) Top-Level const"></a>(4) Top-Level const</h2><p>We use the term <strong>top-level const</strong> to indicate that the pointer itself is a <strong>const</strong>. </p><p>When a pointer can point to a <strong>const</strong> object, we refer to that <strong>const</strong> as a <strong>low-level const</strong>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">// we can't change the value of p1; const is top-level</span><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p1 = &amp;i; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">42</span>; <span class="hljs-comment">// we cannot change ci; const is top-level</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p2 = &amp;ci; <span class="hljs-comment">// we can change p2; const is low-level</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p3 = p2; <span class="hljs-comment">// right-most const is top-level, left-most is not</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r = ci; <span class="hljs-comment">// const in reference types is always low-level</span></code></pre><p>The <strong>distinction</strong> between top-level and low-level matters when we copy an object. </p><p><strong>When we copy an object, top-level consts are ignored:</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">// ok: copying the value of ci; top-level const in ci is ignored</span>i = ci; <span class="hljs-comment">// ok: pointed-to type matches; top-level const in p3 is ignored</span>p2 = p3;</code></pre><p>Copying an object doesn’t change the copied object. As a result, it is immaterial whether the object copied from or copied into is <strong>const</strong>.</p><p>On the other hand, <strong>low-level const is never ignored</strong>. </p><p>When we copy an object, both objects must have the same <strong>low-level const</strong> qualification or there must be a conversion between the types of the two objects. </p><p>In general, we can convert a <strong>nonconst</strong> to <strong>const</strong> but not the other way round:</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = p3; <span class="hljs-comment">// error: p3 has a low-level const but p doesn't</span>p2 = p3; <span class="hljs-comment">// ok: p2 has the same low-level const qualification as p3</span>p2 = &amp;i; <span class="hljs-comment">// ok: we can convert int* to const int*</span><span class="hljs-comment">// error: can't bind an ordinary int&amp; to a const int object</span><span class="hljs-keyword">int</span> &amp;r = ci; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = i; <span class="hljs-comment">// ok: can bind const int&amp; to plain int</span></code></pre><h2 id="5-int-const-const-int-and-int-const"><a href="#5-int-const-const-int-and-int-const" class="headerlink" title="(5) int const * , const int * and int *const"></a>(5) int const * , const int * and int *const</h2><p><a href="https://stackoverflow.com/a/1143272/12342782" target="_blank" rel="noopener">What is the difference between const int*, const int * const, and int const *</a></p><p><a href="https://www.cdecl.org/" target="_blank" rel="noopener">website to auto-translates C declarations </a></p><p><a href="http://c-faq.com/decl/spiral.anderson.html" target="_blank" rel="noopener">Clockwise/Spiral Rule</a></p><pre><code class="hljs nimrod"><span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> *p; // declare p <span class="hljs-keyword">as</span> <span class="hljs-built_in">pointer</span> to <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> *p; // same <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> * p<span class="hljs-built_in">int</span> * <span class="hljs-keyword">const</span> p; // declare p <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">pointer</span> to <span class="hljs-built_in">int</span></code></pre><h2 id="5-Constant-Expressions"><a href="#5-Constant-Expressions" class="headerlink" title="(5) Constant Expressions"></a>(5) Constant Expressions</h2><p>A constant expression is an expression whose value cannot change and that <strong><font color = red>can be evaluated at compile time</strong>.</font> </p><p>A literal is a constant expression. </p><p>A <strong>const</strong> object that is initialized from a constant expression is also a constant expression.</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max_files = <span class="hljs-number">20</span>; <span class="hljs-comment">// max_files is a constant expression</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> limit = max_files + <span class="hljs-number">1</span>; <span class="hljs-comment">// limit is a constant expression</span><span class="hljs-keyword">int</span> staff_size = <span class="hljs-number">27</span>; <span class="hljs-comment">// staff_size is not a constant expression</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = get_size(); <span class="hljs-comment">// sz is not a constant expression</span></code></pre><h2 id="6-Constexpr-Variables"><a href="#6-Constexpr-Variables" class="headerlink" title="(6) Constexpr Variables"></a>(6) Constexpr Variables</h2><p>In a large system, it can be difficult to determine (for certain) that an initializer is a <strong>constant expression</strong>.</p><p>In general, the definition of an object and its use in such a context can be widely separated.</p><p>Under the new standard, we can ask the compiler to verify that a variable is a <strong>constant expression</strong> by declaring the variable in a <strong>constexpr</strong> declaration. </p><p>Variables declared as <strong>constexpr</strong> are <strong>implicitly const</strong> and must be initialized by <strong>constant expressions</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> mf = <span class="hljs-number">20</span>; <span class="hljs-comment">// 20 is a constant expression</span><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> limit = mf + <span class="hljs-number">1</span>; <span class="hljs-comment">// mf + 1 is a constant expression</span><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> sz = size(); <span class="hljs-comment">// ok only if size is a constexpr function</span></code></pre><p>Although we cannot use an ordinary function as an initializer for a <strong>constexpr</strong> variable, the new standard lets us define certain functions as <strong>constexpr</strong>. </p><p>Such functions must be <strong>simple enough</strong> that the compiler can evaluate them at <strong>compile time</strong>. </p><p>We can use <strong>constexpr</strong> functions in the initializer of a <strong>constexpr</strong> variable.</p><p>The types we can use in a <strong>constexpr</strong> are known as “<strong>literal types</strong>“ because they are simple enough to have literal values.</p><p>Variables <strong>defined inside a function</strong> ordinarily are <strong>not</strong> stored at a <strong>fixed address</strong>. Hence, we cannot use a <strong>constexpr</strong> pointer to point to such variables. </p><p>On the other hand, the address of an object defined <strong>outside of any function</strong> is a <strong>constant expression</strong>, and so may be used to initialize a <strong>constexpr</strong> pointer. </p><h2 id="7-Pointers-and-constexpr"><a href="#7-Pointers-and-constexpr" class="headerlink" title="(7) Pointers and constexpr"></a>(7) Pointers and constexpr</h2><p>It is important to understand that when we define a pointer in a <strong>constexpr</strong> declaration, the <strong>constexpr</strong> specifier applies to the <strong>pointer</strong>, <strong>not</strong> the type to which the pointer points:</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// p is a pointer to a const int</span><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *q = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// q is a const pointer to int</span></code></pre><h1 id="4-Dealing-with-Types"><a href="#4-Dealing-with-Types" class="headerlink" title="4. Dealing with Types"></a>4. Dealing with Types</h1><h2 id="1-auto"><a href="#1-auto" class="headerlink" title="(1) auto"></a>(1) auto</h2><p>Under the new standard, we can let the compiler figure out the type for us by using the <strong>auto</strong> type specifier. </p><p><strong>auto</strong> tells the compiler to deduce the type from the <strong>initializer</strong>. </p><p>By implication, a variable that uses <strong>auto</strong> as its type specifier must have an <strong>initializer</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> item = val1 + val2; <span class="hljs-comment">// item initialized to the result of val1 + val2</span></code></pre><p>As with any other type specifier, we can define <strong>multiple variables</strong> using <strong>auto</strong>.</p><p>Because a declaration can involve only <strong>a single base type</strong>, the initializers for all the variables in the declaration must have types that are <strong>consistent</strong> with each other:</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i; <span class="hljs-comment">// ok: i is int and p is a pointer to int</span><span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>, pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// error: inconsistent types for sz and pi</span></code></pre><p>The type that the compiler infers for <strong>auto</strong> is <strong>not always exactly the same as the initializer’s type</strong>. Instead, the compiler adjusts the type to conform to normal initialization rules.</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, &amp;r = i;<span class="hljs-keyword">auto</span> a = r; <span class="hljs-comment">// a is an int (r is an alias for i, which has type int)</span></code></pre><p><strong>auto</strong> ordinarily ignores top-level consts. As usual in initializations, <strong>low-level consts, such as when an initializer is a pointer to const, are kept</strong>:</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i, &amp;cr = ci;<span class="hljs-keyword">auto</span> b = ci; <span class="hljs-comment">// b is an int (top-level const in ci is dropped)</span><span class="hljs-comment">// c is an int (cr is an alias for ci whose const is top-level)</span><span class="hljs-keyword">auto</span> c = cr; <span class="hljs-keyword">auto</span> d = &amp;i; <span class="hljs-comment">// d is an int*(&amp; of an int object is int*)</span><span class="hljs-comment">// e is const int*(&amp; of a const object is low-level const)</span><span class="hljs-keyword">auto</span> e = &amp;ci;</code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> f = ci; <span class="hljs-comment">// deduced type of ci is int; f has type const int</span></code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> &amp;g = ci; <span class="hljs-comment">// g is a const int&amp; that is bound to ci</span><span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>; <span class="hljs-comment">// error: we can't bind a plain reference to a literal</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;j = <span class="hljs-number">42</span>; <span class="hljs-comment">// ok: we can bind a const reference to a literal</span></code></pre><p>When we ask for a reference to an auto-deduced type, <strong>top-level consts in the initializer are not ignored</strong>. </p><p>As usual, <strong>consts are not top-level when we bind a reference to an initializer</strong>.</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> k = ci, &amp;l = i; <span class="hljs-comment">// k is int; l is int&amp;</span><span class="hljs-keyword">auto</span> &amp;m = ci, *p = &amp;ci; <span class="hljs-comment">// m is a const int&amp;;p is a pointer to const int</span><span class="hljs-comment">// error: type deduced from i is int; type deduced from &amp;ci is const int</span><span class="hljs-keyword">auto</span> &amp;n = i, *p2 = &amp;ci;</code></pre><h2 id="2-decltype"><a href="#2-decltype" class="headerlink" title="(2) decltype"></a>(2) decltype</h2><p>Sometimes we want to define a variable with a type that the compiler <strong>deduces from an expression but do not want to use</strong> that expression to initialize the variable. </p><p>For such cases, the new standard introduced a second type specifier, <strong>decltype</strong>, which returns the type of its operand. </p><p>The compiler analyzes the expression to determine its type but does not evaluate the expression:</p><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>(f()) sum = x; <span class="hljs-comment">// sum has whatever type f returns</span></code></pre><p>Here, the compiler <strong>does not call f</strong>, but it uses the type that such a call would return as the type for <code>sum</code>.</p><p>The way <strong>decltype</strong> handles <strong>top-level const and references</strong> differs subtly from the way <strong>auto</strong> does. </p><p>When the expression to which we apply <strong>decltype</strong> is a variable, <strong>decltype</strong> returns the type of that variable, including top-level const and references:</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>; <span class="hljs-comment">// x has type const int</span><span class="hljs-keyword">decltype</span>(cj) y = x; <span class="hljs-comment">// y has type const int&amp; and is bound to x</span><span class="hljs-keyword">decltype</span>(cj) z; <span class="hljs-comment">// error: z is a reference and must be initialized</span></code></pre><pre><code class="hljs cpp"><span class="hljs-comment">// decltype of an expression can be a reference type</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>, *p = &amp;i, &amp;r = i;<span class="hljs-comment">// ok: addition yields an int; b is an (uninitialized) int</span><span class="hljs-keyword">decltype</span>(r + <span class="hljs-number">0</span>) b; <span class="hljs-keyword">decltype</span>(*p) c; <span class="hljs-comment">// error: c is int&amp; and must be initialized</span></code></pre><p>Here <code>r</code> is a reference, so <code>decltype(r)</code> is a <strong>reference type</strong>. If we want the type to which <code>r</code> refers, we can use <code>r</code> in an expression, such as <code>r + 0</code>, which is an expression that yields a value that has a <strong>nonreference</strong> type.</p><p>On the other hand, the <strong>dereference operator</strong> is an example of an expression for which <strong>decltype</strong> returns a reference. </p><p>As we’ve seen, when we dereference a pointer, we get the object to which the pointer points. Moreover, we can assign to that object.</p><p>Thus, <strong>the type deduced by *<em>decltype(\</em>p)</strong> is <strong>int&amp;</strong>, not plain int**.</p><p>Another <strong>important difference</strong> between <strong>decltype and auto</strong> is that the deduction done by decltype depends on the form of its given expression.</p><p>When we apply <strong>decltype</strong> to a variable <strong>without any parentheses</strong>, we get the type of that variable. </p><p>If we <strong>wrap the variable’s name</strong> in one or more sets of parentheses, the compiler will evaluate the operand as an expression.</p><p>A variable is an expression that can be the left-hand side of an assignment. </p><p><strong>As a result, decltype on such an expression yields a reference:</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">// decltype of a parenthesized variable is always a reference</span><span class="hljs-keyword">decltype</span>((i)) d; <span class="hljs-comment">// error: d is int&amp; and must be initialized</span><span class="hljs-keyword">decltype</span>(i) e; <span class="hljs-comment">// ok: e is an (uninitialized) int</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Getting Started</title>
    <link href="/2020/12/29/Getting-Started/"/>
    <url>/2020/12/29/Getting-Started/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer(Fifth Edition) Chapter 1 Getting Started</p><a id="more"></a><h1 id="1-Formatting-of-C-Programs"><a href="#1-Formatting-of-C-Programs" class="headerlink" title="1. Formatting of C++ Programs"></a>1. Formatting of C++ Programs</h1><p>C++ programs are largely free-format, meaning that where we put curly braces, indentation, comments, and newlines usually has no effect on what our programs mean. </p><pre><code class="hljs cpp"><span class="hljs-comment">//c++</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello"</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; <span class="hljs-string">"world"</span> &lt;&lt; <span class="hljs-string">"!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs cpp">Hello world!</code></pre><p>That’s because C++’s free format rules treat <strong>newlines and spaces between tokens interchangeably</strong>.</p><pre><code class="hljs c"><span class="hljs-comment">//c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello\n"</span>);https:<span class="hljs-comment">//blog.csdn.net/Lee567/article/details/100099573#4_printf__148)</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre><p><a href="https://lxwcd.github.io/2020/11/28/Charater-Strings-and-Formatted-Input-Output/#4-Printing-Long-Strings">printf() Printing long strings</a></p><h1 id="2-lt-lt-Operator"><a href="#2-lt-lt-Operator" class="headerlink" title="2. &lt;&lt; Operator"></a>2. &lt;&lt; Operator</h1><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter two numbers:"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</code></pre><p>The <code>&lt;&lt;</code> operator takes two operands: The <strong>left-hand</strong> operand must be an <strong>ostream</strong> object; the <strong>right-hand</strong> operand is a <strong>value to print</strong>. </p><p>The operator <strong>writes</strong> the given value on the given <strong>ostream</strong>. </p><p>The <strong>result</strong> of the <strong>output operator</strong> is its <strong>left-hand operand</strong>. </p><p>As a result, we can chain together output requests. </p><p>Thus, our expression is equivalent to</p><pre><code class="hljs cpp">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter two numbers:"</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</code></pre><p>The <strong>second operator</strong> prints <code>endl</code>, which is a special value called a <strong>manipulator</strong>. Writing <code>endl</code> has the effect of ending the current line and <strong>flushing</strong> the buffer associated with that device. </p><p>Flushing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.</p><h1 id="3-Reading-an-Unknown-Number-of-Inputs"><a href="#3-Reading-an-Unknown-Number-of-Inputs" class="headerlink" title="3. Reading an Unknown Number of Inputs"></a>3. Reading an Unknown Number of Inputs</h1><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, value = <span class="hljs-number">0</span>;    <span class="hljs-comment">// read until end-of-file, calculating a running total of all values read</span>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; value)        sum += value; <span class="hljs-comment">// equivalent to sum = sum + value</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sum is: "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; value)</code></pre><p>Evaluating the while condition executes the expression<br><code>std::cin &gt;&gt; value</code> .</p><p>When we use an <code>istream</code> as a condition, the effect is to test the state of the stream. </p><p>If the stream is valid—that is, if the stream hasn’t encountered an error, then the test succeeds. </p><p>An <code>istream</code> becomes invalid when we hit <strong>end-of-file</strong> or encounter an <strong>invalid input</strong>, such as reading a value that is not an integer. </p><p>An <code>istream</code> that is in an invalid state will cause the condition to yield false.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++ Primer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The C Processor and the C Library</title>
    <link href="/2020/12/09/The-C-Processor-and-the-C-Library/"/>
    <url>/2020/12/09/The-C-Processor-and-the-C-Library/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 16 The C Processor and the C Library</p><a id="more"></a><p>The <strong>preprocessor</strong> looks at your program <strong>before</strong> it is <strong>compiled</strong> (hence the term <strong>preprocessor</strong>).</p><p>Following your <strong>preprocessor</strong> directives, the <strong>preprocessor</strong> <strong>replaces</strong> the <strong>symbolic abbreviations</strong> in your program with the <strong>directions</strong> they represent. </p><p>The <strong>preprocessor</strong> can include other files at your request, and it can select which code the compiler sees. </p><p>The <strong>preprocessor</strong> doesn’t know about <strong>C</strong>. Basically, it takes some text and <strong>converts</strong> it to other text. This description does <strong>not do justice</strong> to its true utility and value.</p><h1 id="1-First-Steps-in-Translating-a-Program"><a href="#1-First-Steps-in-Translating-a-Program" class="headerlink" title="1. First Steps in Translating a Program"></a>1. First Steps in Translating a Program</h1><p>The <strong>compiler</strong> has to put a program through some <strong>translation phases</strong> before jumping into <strong>preprocessing</strong>. </p><ol><li><p>The <strong>compiler</strong> <strong>starts</strong> its work by <strong>mapping characters</strong> appearing in the source code to the <strong>source character set</strong>.  This takes care of <strong>multibyte</strong> characters and <strong>trigraphs</strong>—character extensions that make the outer face of C more international. </p></li><li><p>The <strong>compiler</strong> locates each instance of a <strong>backslash</strong> followed by a <strong>newline character</strong> and <strong>deletes</strong> them. That is, two physical lines such as</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"That's wond\</span><span class="hljs-string">erful!\n"</span>);</code></pre><p>are converted to <strong>a single logical line</strong>:</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"That's wonderful\n!"</span>);</code></pre><p>Note that in this context, <strong>“newline character”</strong> means the character produced by pressing the <code>Enter key</code> to start a new line in your source code file; it <strong>doesn’t</strong> mean the symbolic representation <code>\n</code>.</p></li><li><p>The <strong>compiler</strong> breaks the text into a sequence of <strong>preprocessing tokens</strong> and sequences of <strong>whitespace</strong> and <strong>comments</strong>. (In basic terms, tokens are groups separated from each other by spaces, tabs, or line breaks;) <strong>Each comment</strong> is replaced by <strong>one space character</strong>. So something such as</p><pre><code class="hljs c"><span class="hljs-keyword">int</span><span class="hljs-comment">/* this doesn't look like a space*/</span>fox;</code></pre><p>becomes</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> fox;</code></pre><h1 id="2-Manifest-Constants-define"><a href="#2-Manifest-Constants-define" class="headerlink" title="2. Manifest Constants: #define"></a>2. Manifest Constants: #define</h1><p>A <strong>directive</strong> can appear anywhere in the source file, and the definition holds from its place of <strong>appearance to the end of the file</strong>. </p></li></ol><p><strong>Preprocessor</strong> directives run until the <strong>first newline</strong> following the <code>#</code>. </p><p>That is, a directive is limited to <strong>one line</strong> in length. However, as mentioned earlier, the combination <strong>backslash</strong> <strong>newline</strong> is deleted <strong>before preprocessing</strong> begins, so you can spread the directive over <strong>several physical lines</strong>. These lines, however, constitute <strong>a single logical line</strong>.</p><p>Each <strong>#define</strong> line (logical line, that is) has <strong>three</strong> parts:</p><ol><li><p>The <strong>first</strong> part is the <strong>#define directive</strong> itself. </p></li><li><p>The <strong>second</strong> part is your chosen <strong>abbreviation</strong>, known as a <strong>macro</strong>.  </p><p> The <strong>macro name</strong> must have <strong>no spaces</strong> in it, and it must conform to the same <strong>naming rules</strong> that C variables follow: Only <strong>letters</strong>, <strong>digits</strong>, and the <strong>underscore</strong> <code>(_)</code> character can be used, and the <strong>first character cannot be a digit</strong>. </p></li><li><p><strong>Replacement list</strong> or <strong>body</strong> . </p></li></ol><p>When the <strong>preprocessor</strong> finds an example of one of your <strong>macros</strong> within your program, it almost always <strong>replaces</strong> it with the body. ( The one exception to replacement is a <strong>macro</strong> found within <strong>double quotation marks</strong>.) </p><p>This process of going from a <strong>macro</strong> to a <strong>final replacement</strong> is called <strong>macro expansion</strong>. </p><h2 id="1-define-与-const"><a href="#1-define-与-const" class="headerlink" title="(1) define 与 const"></a>(1) define 与 const</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIMIT 20</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LIM = <span class="hljs-number">50</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> data1[LIMIT]; <span class="hljs-comment">// valid</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> data2[LIM]; <span class="hljs-comment">// storage size of 'data' isn't constant</span><span class="hljs-keyword">int</span> data3[LIM]; <span class="hljs-comment">//valid</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LIM2 = <span class="hljs-number">2</span> * LIMIT; <span class="hljs-comment">// valid</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LIM3 = <span class="hljs-number">2</span> * LIM; <span class="hljs-comment">// valid</span></code></pre><p>In <strong>C</strong>, the array size for <strong>nonautomatic</strong> arrays is supposed to be an <strong>integer constant expression</strong>, meaning that it’s a combination of integer constants, such as <code>5</code>, enumeration constants, and sizeof expressions. This doesn’t include values declared using <strong>const</strong>. (This is one respect in which <strong>C++</strong> differs from <strong>C</strong>; in <strong>C++</strong> you can use <strong>const values</strong> as part of <strong>constant expressions</strong>.) </p><p>However, an implementation may accept other forms of <a href="http://port70.net/~nsz/c/c11/n1570.html#6.6p2" target="_blank" rel="noopener">constant expression</a> . </p><p><strong>Note:</strong></p><ul><li>The value of a const-qualified object is not a constant expression. A constant expression can be evaluated during translation rather than runtime.</li><li>You must specify the size of a conventional C array with a constant expression, so the size is<br>determined at compile time. C99/C11 offers the variable-length array alternative for which the<br>size specifier can be a variable. This allows you to delay specifying the size of a VLA until the program is running. So, <code>int data3[LIM];</code> is permitted.</li><li>Static variables and external variables are already in place after a program is loaded into memory. Statically allocated memory is typically reserved in data segment of the program at compile time, while the automatically allocated memory is normally implemented as a transient call stack. Hence, <code>static int data2[LIM];</code> is invalid.</li></ul><h2 id="2-Tokens"><a href="#2-Tokens" class="headerlink" title="(2) Tokens"></a>(2) Tokens</h2><p>Technically, the body of a <strong>macro</strong> is considered to be a <strong>string of tokens</strong> rather than <strong>a string of characters</strong>. </p><p>C preprocessor <strong>tokens</strong> are the separate “words” in the body of a <strong>macro</strong> definition.</p><p>They are separated from one another by <strong>whitespace</strong>. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOUR 2*2</span></code></pre><p>has one token：2*2</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIX 2 * 3</span></code></pre><p>has three tokens: 2，*, 2</p><p><strong>Character strings</strong> and <strong>token strings</strong> differ in how multiple spaces in a body are treated. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EIGHT 4    *    8</span></code></pre><p>A <strong>preprocessor</strong> that interprets the body as a character string would replace <code>EIGHT</code> with 4&emsp;&emsp;*&emsp;&emsp;8.</p><p>That is, the extra spaces would be <strong>part of the replacement</strong>, but a <strong>preprocessor</strong> that interprets the body as <strong>tokens</strong> will replace <code>EIGHT</code> with <strong>three tokens</strong> separated by single spaces: 4 * 8. </p><p>In practice, some C compilers have viewed <strong>macro</strong> bodies as <strong>strings</strong> rather than as <strong>tokens</strong>. </p><h2 id="3-Redefining-Constants"><a href="#3-Redefining-Constants" class="headerlink" title="(3) Redefining Constants"></a>(3) Redefining Constants</h2><p>Suppose you define <code>LIMIT</code> to be 20, and then later in the same file you define it again as 25. This process is called <strong>redefining a constant</strong>. </p><p>The ANSI standard allows redefinition only if the new definition <strong>duplicates</strong> the old.</p><p>Having the same definition means the bodies must have the same <strong>tokens</strong> in the <strong>same order</strong>.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIX 2 * 3</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIX 2   *   3</span></code></pre><p>Both have the same <strong>three tokens</strong>, and the extra spaces are not part of the body. The next definition is considered different:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIX 2*3</span></code></pre><p>It has just <strong>one token</strong>, not three, so it doesn’t match. If you want to redefine a macro, use the <code>#undef</code> directive.</p><h1 id="3-Using-Arguments-with-define"><a href="#3-Using-Arguments-with-define" class="headerlink" title="3. Using Arguments with #define"></a>3. Using Arguments with #define</h1><p><strong>Function-like macro</strong> definitions have one or more <strong>arguments</strong> in <strong>parentheses</strong>, and these arguments then appear in the replacement portion.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SQUARE(X) (X)*(X)</span></code></pre><p>Now <code>SQUARE(x+2)</code> becomes $(x+2)*(x+2)$, you get the correct result.</p><p>However, <code>100/SQUARE(2)</code> becomes $100/(2)*(2)$ instead of $100/4$.</p><h2 id="1-Creating-Strings-from-Macro-Arguments-The-Operator"><a href="#1-Creating-Strings-from-Macro-Arguments-The-Operator" class="headerlink" title="(1) Creating Strings from Macro Arguments: The # Operator"></a>(1) Creating Strings from Macro Arguments: The # Operator</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PSQR(X) printf(<span class="hljs-meta-string">"The square of X is %d.\n"</span>, ((X)*(X)));</span>PSQR(<span class="hljs-number">8</span>);</code></pre><p>output:</p><pre><code class="hljs c">The square of X is <span class="hljs-number">64.</span></code></pre><p>Note that the <code>X</code> in the <strong>quoted string</strong> is treated as ordinary text, not as a <strong>token</strong> that can be replaced.</p><p>Within the replacement part of a <strong>function-like macro</strong>, the <code>#</code> symbol becomes a <strong>preprocessing</strong> operator that <strong>converts tokens into strings</strong>. </p><p>For example, say that <code>x</code>is a macro parameter, and then <code>#x</code> is that parameter name converted to the string <code>&quot;x&quot;</code>. This process is called <strong>stringizing</strong>.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PSQR(x) printf(<span class="hljs-meta-string">"The square of "</span> #x <span class="hljs-meta-string">" is %d.\n"</span>,((x)*(x)))</span>PSQR(y);PSQR(<span class="hljs-number">2</span> + <span class="hljs-number">4</span>);</code></pre><p>output:</p><pre><code class="hljs c">The square of y is <span class="hljs-number">25.</span>The square of <span class="hljs-number">2</span> + <span class="hljs-number">4</span> is <span class="hljs-number">36.</span></code></pre><p>In the first call to the macro, <code>#x</code> was replaced by <code>&quot;y&quot;</code>, and in the second call <code>#x</code> was replaced by <code>&quot;2 + 4&quot;</code>. </p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"The square of "</span> <span class="hljs-string">"y"</span> <span class="hljs-string">" is %d.\n"</span>,((y)*(y)));</code></pre><p>Then string <strong>concatenation</strong> converts the three adjacent strings to one string, which ANSI C introduced, is <strong>string concatenation</strong>.</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"The square of y is %d.\n"</span>,((y)*(y)));</code></pre><p>If you follow one quoted string constant with another, separated only by <strong>whitespace</strong>, C treats the combination as a single string. </p><h2 id="2-Preprocessor-Glue-The-Operator"><a href="#2-Preprocessor-Glue-The-Operator" class="headerlink" title="(2)  Preprocessor Glue: The ## Operator"></a>(2)  Preprocessor Glue: The ## Operator</h2><p>Like the <code>#</code> operator, the <code>##</code> operator can be used in the replacement section of a <strong>function-like macro</strong>. Additionally, it can be used in the replacement section of an <strong>object-like macro</strong>. </p><p>The <code>##</code> operator combines <strong>two tokens</strong> into a <strong>single token</strong>. For example, you could do this:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XNAME(n) x ## n</span></code></pre><p>Then the macro <code>XNAME(4)</code> becomes <code>x4</code>.</p><pre><code class="hljs c"><span class="hljs-comment">// glue.c -- use the ## operator</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XNAME(n) x ## n</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRINT_XN(n) printf(<span class="hljs-meta-string">"x"</span> #n <span class="hljs-meta-string">" = %d\n"</span>, x ## n);</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">XNAME</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span> </span>= <span class="hljs-number">14</span>; <span class="hljs-comment">// becomes int x1 = 14;</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">XNAME</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span> </span>= <span class="hljs-number">20</span>; <span class="hljs-comment">// becomes int x2 = 20;</span>    <span class="hljs-keyword">int</span> x3 = <span class="hljs-number">30</span>;    PRINT_XN(<span class="hljs-number">1</span>); <span class="hljs-comment">// becomes printf("x1 = %d\n", x1);</span>    PRINT_XN(<span class="hljs-number">2</span>); <span class="hljs-comment">// becomes printf("x2 = %d\n", x2);</span>    PRINT_XN(<span class="hljs-number">3</span>); <span class="hljs-comment">// becomes printf("x3 = %d\n", x3);</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Note how the <code>PRINT_XN()</code> <strong>macro</strong> uses the <code>#</code> operator to combine <strong>strings</strong> and the <code>##</code> operator to combine <strong>tokens</strong> into a new identifier.</p><h2 id="3-Variadic-Macros-…-and-VA-ARGS"><a href="#3-Variadic-Macros-…-and-VA-ARGS" class="headerlink" title="(3) Variadic Macros: … and _ VA_ARGS _"></a>(3) Variadic Macros: … and _ <em>VA_ARGS</em> _</h2><p>Some functions, such as <code>printf()</code>, accept a <strong>variable number of arguments</strong>. The <code>stdvar.h</code> header file provides tools for creating user-defined functions with a variable number of arguments. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PR(...) printf(_ _VA_ARGS_ _)</span></code></pre><p>Suppose you later invoke the <strong>macro</strong> like this:</p><pre><code class="hljs c">PR(<span class="hljs-string">"Howdy"</span>);PR(<span class="hljs-string">"weight = %d, shipping = $%.2f\n"</span>, wt, sp);</code></pre><p>For the first invocation,<code>_ _VA_ARGS_ _</code> expands to one argument: <code>&quot;Howdy&quot;</code>.</p><p>For the second invocation, it expands to three arguments: <code>&quot;weight = %d, shipping = $%.2f\n&quot;, wt, sp</code>.</p><p>Thus, the resulting code is this:</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Howdy"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"weight = %d, shipping = $%.2f\n"</span>, wt, sp);</code></pre><pre><code class="hljs c"><span class="hljs-comment">// variadic.c -- variadic macros</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PR(X, ...) printf(<span class="hljs-meta-string">"Message "</span> #X <span class="hljs-meta-string">": "</span> _ _VA_ARGS_ _)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> x = <span class="hljs-number">48</span>;    <span class="hljs-keyword">double</span> y;    y = <span class="hljs-built_in">sqrt</span>(x);    PR(<span class="hljs-number">1</span>, <span class="hljs-string">"x = %g\n"</span>, x);    PR(<span class="hljs-number">2</span>, <span class="hljs-string">"x = %.2f, y = %.4f\n"</span>, x, y);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>In the first <strong>macro call</strong>, <code>X</code>has the value <code>1</code>, so <code>#X</code> becomes <code>&quot;1&quot;</code>. That makes the expansion look like this:</p><pre><code class="hljs c"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Message "</span> <span class="hljs-string">"1"</span> <span class="hljs-string">": "</span> <span class="hljs-string">"x = %g\n"</span>, x);</code></pre><p>Then the four strings are <strong>concatenated</strong>, reducing the call to this:</p><pre><code class="hljs c"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Message 1: x = %g\n"</span>, x);</code></pre><p><strong>Note:</strong> the ellipses have to be the <strong>last macro argument</strong>:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRONG(X, ..., Y) #X #_ _VA_ARGS_ _ #y <span class="hljs-comment">// don't work</span></span></code></pre><h1 id="4-Macro-or-Function"><a href="#4-Macro-or-Function" class="headerlink" title="4. Macro or Function?"></a>4. Macro or Function?</h1><p>The <strong>macro-versus-function</strong> choice represents a trade-off between <strong>time</strong> and <strong>space</strong>. </p><p>A macro produces <strong>inline code</strong>; that is, you get a statement in your program. </p><p>If you use the <strong>macro</strong> 20 times, you get 20 lines of code inserted into your program. </p><p>If you use a <strong>function</strong> 20 times, you have just <strong>one copy</strong> of the function statements in your program, so <strong>less space</strong> is used. </p><p>On the other hand, program control must <strong>shift to</strong> where the function is and then return to the calling program, and this takes <strong>longer</strong> than <strong>inline code</strong>.</p><p><strong>Macros</strong> have an <strong>advantage</strong> in that they don’t worry about <strong>variable types</strong>. (This is because they deal with character strings, not with actual values.) </p><p>Therefore, the <strong>SQUARE(x)</strong> macro can be used equally well with <strong>int</strong> or <strong>float</strong>.</p><p>Here are some points to note:</p><ol><li>Remember that there are <strong>no spaces</strong> in the <strong>macro name</strong>, but that <strong>spaces</strong> can appear in the <strong>replacement string</strong>. </li><li>Use <strong>parentheses</strong> around <strong>each argument</strong> and around the definition as a whole.</li><li>Use capital letters for macro function names.</li><li>A macro inside a <strong>nested loop</strong> is a much better candidate for <strong>speed improvements</strong>. </li></ol><h1 id="5-File-Inclusion-include"><a href="#5-File-Inclusion-include" class="headerlink" title="5. File Inclusion: #include"></a>5. File Inclusion: #include</h1><p>When the preprocessor spots an <strong>#include</strong> directive, it looks for the following filename and includes the contents of that file within the current file. </p><p>Including a large header file doesn’t necessarily add much to the size of your program. The content of header files, for the most part, is information used by the compiler to generate the final code, not material to be added to the final code.</p><h1 id="6-Other-Directives"><a href="#6-Other-Directives" class="headerlink" title="6. Other Directives"></a>6. Other Directives</h1><h2 id="1-The-undef-Directive"><a href="#1-The-undef-Directive" class="headerlink" title="(1) The #undef Directive"></a>(1) The #undef Directive</h2><p>The <strong>#undef</strong> directive “undefines” a given <strong>#define</strong>. That is, suppose you have this definition:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIMIT 400</span>Then the directive<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> LIMIT</span></code></pre><p>removes that definition. Now, if you like, you can redefine LIMIT so that it has a new value.<br>Even if LIMIT is not defined in the first place, it is still valid to undefine it. </p><h2 id="2-Conditional-Compilation"><a href="#2-Conditional-Compilation" class="headerlink" title="(2) Conditional Compilation"></a>(2) Conditional Compilation</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> MAVIS <span class="hljs-comment">// or #if defined MAVIS</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"horse.h"</span> <span class="hljs-comment">// gets done if MAVIS is #defined</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STABLES 5</span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"cow.h"</span> <span class="hljs-comment">// gets done if MAVIS isn't #defined</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STABLES 15</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SIZE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE 100</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><h2 id="3-Predefined-Macros"><a href="#3-Predefined-Macros" class="headerlink" title="(3) Predefined Macros"></a>(3) Predefined Macros</h2><table><thead><tr><th align="left">Macro</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">_ <em>DATE</em> _</td><td align="left">A character string literal in the form “Mmm dd yyyy” representing the date of preprocessing, as in Nov 23 2013</td></tr><tr><td align="left">_ <em>FILE</em> _</td><td align="left">A character string literal representing the name of the current source code file</td></tr><tr><td align="left">_ <em>LINE</em> _</td><td align="left">An integer constant representing the line number in the current source code file</td></tr><tr><td align="left">_ <em>STDC</em> _</td><td align="left">Set to 1 to indicate the implementation conforms to the C Standard</td></tr><tr><td align="left">_ <em>STDC_HOSTED</em> _</td><td align="left">Set to 1 for a hosted environment; 0 otherwise</td></tr><tr><td align="left">_ <em>STDC_VERSION</em> _</td><td align="left">For C99, set to 199901L; for C11, set to 201112L</td></tr><tr><td align="left">_ <em>TIME</em> _</td><td align="left">The time of translation in the form “hh:mm:ss”</td></tr></tbody></table><p>the C99 standard provides for one called <strong>_ <em>func</em> _</strong>. It expands to a string representing the name of the function containing the identifier. </p><p>For this reason, the identifier has to have function scope, whereas macros essentially have file scope. Therefore, <strong>_ <em>func</em> _</strong> is a C language predefined identifier rather than a <strong>predefined macro</strong>.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">why_me</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The file is %s.\n"</span>, __FILE__);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The date is %s.\n"</span>, __DATE__);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The version is %ld.\n"</span>, __STDC_VERSION__);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The line is %d.\n"</span>, __LINE__);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The function is %s.\n"</span>, __func__);    why_me();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">why_me</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The line is %d.\n"</span>, __LINE__);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The function is %s.\n"</span>, __func__);&#125;</code></pre><p>Result:</p><pre><code class="hljs c">The file is predef.c.The date is Dec  <span class="hljs-number">9</span> <span class="hljs-number">2020.</span>The version is <span class="hljs-number">201710.</span>The <span class="hljs-built_in">line</span> is <span class="hljs-number">8.</span>The function is main.The <span class="hljs-built_in">line</span> is <span class="hljs-number">15.</span>The function is why_me.</code></pre><h2 id="4-line-and-error"><a href="#4-line-and-error" class="headerlink" title="(4) #line and #error"></a>(4) #line and #error</h2><p>The <strong>#line</strong> directive lets you reset the line numbering and the filename as reported by the <strong>_ <em>LINE</em> _</strong> and *<em>_ <em>FILE</em> _ *</em>macros. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">line</span> 1000 <span class="hljs-comment">// reset current line number to 1000</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">line</span> 10 <span class="hljs-meta-string">"cool.c"</span> <span class="hljs-comment">// reset line number to 10, file name to cool.c</span></span></code></pre><p>The <strong>#error</strong> directive causes the preprocessor to issue an error message that includes any text in the directive. If possible, the compilation process should halt. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">why_me</span><span class="hljs-params">()</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _ _STDC_VERSION_ _ != 201112L</span><span class="hljs-meta">#<span class="hljs-meta-keyword">error</span> Not C11</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><span class="hljs-function"></span>&#123;    ...&#125;</code></pre><p>Attempting to compile the program <code>predef.c</code>could then produce results like this:</p><pre><code class="hljs bash">$ gcc predef.cpredef.c:4:2: error: <span class="hljs-comment">#error Not C11</span>    4 | <span class="hljs-comment">#error Not C11</span>      |  ^~~~~$ gcc -std=c11 predef.c //normal</code></pre><h2 id="5-pragma"><a href="#5-pragma" class="headerlink" title="(5) #pragma"></a>(5) #pragma</h2><p>The <strong>#pragma</strong> lets you place compiler instructions in the source code.</p><p>For example, while C99 was being developed, it was referred to as C9X, and one compiler used the following pragma to turn on C9X support:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> c9x on</span></code></pre><p>Generally, each compiler has its own set of pragmas. C99 also provides the _Pragma preprocessor operator. It converts a string into a regular pragma.</p><pre><code class="hljs c">_Pragma(<span class="hljs-string">"nonstandardtreatmenttypeB on"</span>)</code></pre><p>is equivalent to the following:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> nonstandardtreatmenttypeB on</span></code></pre><p>Because the operator doesn’t use the <strong># symbol</strong>, you can use it as part of a macro expansion:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRAGMA(X) <span class="hljs-meta-keyword">_Pragma</span>(#X)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIMRG(X) PRAGMA(STDC CX_LIMITED_RANGE X)</span></code></pre><h2 id="6-Generic-Selection-C11"><a href="#6-Generic-Selection-C11" class="headerlink" title="(6) Generic Selection (C11)"></a>(6) Generic Selection (C11)</h2><p>In programming, the term <strong>generic programming</strong> indicates code that is not specific to a particular type but which, once a type is specified, can be translated into code for that type.</p><p>A generic selection expression looks like this:</p><pre><code class="hljs c">_Generic(x, <span class="hljs-keyword">int</span>: <span class="hljs-number">0</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span>: <span class="hljs-number">2</span>, <span class="hljs-keyword">default</span>: <span class="hljs-number">3</span>)</code></pre><p>Here <strong>_Generic</strong> is a new C11 keyword. The parentheses following <strong>_Generic</strong> contain several comma-separated terms. </p><p>The first term is an expression, and each remaining item is a type followed by a colon followed by a value, such as float: 1. The type of the first term is matched to one of the labels, and the value of the whole expression is the value following the matched label. </p><p>A generic selection statement is a little like a <strong>switch</strong> statement, except that the <strong>type of an expression</strong> rather than the** value of an expression** is matched to a label.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MYTYPE(X) _Generic((X),\</span><span class="hljs-keyword">int</span>: <span class="hljs-string">"int"</span>,\<span class="hljs-keyword">float</span> : <span class="hljs-string">"float"</span>,\<span class="hljs-keyword">double</span>: <span class="hljs-string">"double"</span>,\<span class="hljs-keyword">default</span>: <span class="hljs-string">"other"</span>\)</code></pre><h1 id="7-Inline-Functions-C99"><a href="#7-Inline-Functions-C99" class="headerlink" title="7. Inline Functions (C99)"></a>7. Inline Functions (C99)</h1><p>What the C99 and C11 standards actually say is this: “Making a function an inline function suggests that calls to the function be as fast as possible. The extent to which such suggestions are effective is implementation-defined.” </p><p>So making a function an inline function may cause the compiler to replace the function call with inline code and/or perform some other sorts of optimizations, or it may have no effect.</p><p>There are different ways to create inline function definitions. The standard says that a function with internal linkage can be made inline and that the definition for the inline function must be in the same file in which the function is used. </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eatline</span><span class="hljs-params">()</span> <span class="hljs-comment">// inline definition/prototype</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">'\n'</span>)        <span class="hljs-keyword">continue</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ...    eatline(); <span class="hljs-comment">// function call</span>    ...&#125;</code></pre><p>Because an inline function doesn’t have a separate block of code set aside for it, you can’t take its address. (Actually, you can take the address, but then the compiler will generate a non-inline function.) </p><p>Also, an inline function may not show up in a debugger.</p><p>An inline function should be short. </p><p>For the compiler to make inline optimizations, it has to know the contents of the function definition. This means the inline function definition has to be in the same file as the function call. For this reason, an inline function ordinarily has internal linkage. Therefore, if you have a multifile program, you need an inline definition in each file that calls the function. The simplest way to accomplish this is to put the inline function definition in a header file and then include the header file in those files that use the function.</p><h1 id="8-Noreturn-Functions-C11"><a href="#8-Noreturn-Functions-C11" class="headerlink" title="8. _Noreturn Functions (C11)"></a>8. _Noreturn Functions (C11)</h1><p> C11 adds a second function specifier, _Noreturn, to indicate a function that, upon completion, does not return to the <strong>calling function</strong>. </p><p>The exit() function is an example of a _Noreturn function, for once exit() is called, the calling function never resumes. </p><p>Note that this is different from the void return type. A typical void function does return to the calling function; it just doesn’t provide an assignable value.</p><p>The purpose of _Noreturn is to inform the user and the compiler that a particular function won’t return control to the calling program. Informing the user helps to prevent misuse of the function, and informing the compiler may enable it to make some code optimizations.</p><h1 id="9-The-General-Utilities-Library"><a href="#9-The-General-Utilities-Library" class="headerlink" title="9. The General Utilities Library"></a>9. The General Utilities Library</h1><h2 id="1-The-exit-and-atexit-Functions"><a href="#1-The-exit-and-atexit-Functions" class="headerlink" title="(1) The exit() and atexit() Functions"></a>(1) The exit() and atexit() Functions</h2><p>To use the atexit() function, simply pass it the address of the function you want called on exit. </p><pre><code class="hljs c"><span class="hljs-comment">/* byebye.c -- atexit() example */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sign_off</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">too_bad</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    atexit(sign_off); <span class="hljs-comment">/* register the sign_off() function */</span>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter an integer:"</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n) != <span class="hljs-number">1</span>)    &#123;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"That's no integer!"</span>);        atexit(too_bad); <span class="hljs-comment">/* register the too_bad() function */</span>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d is %s.\n"</span>, n, (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)? <span class="hljs-string">"even"</span> : <span class="hljs-string">"odd"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sign_off</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Thus terminates another magnificent program from"</span>);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"SeeSaw Software!"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">too_bad</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"SeeSaw Software extends its heartfelt condolences"</span>);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"to you upon the failure of your program."</span>);&#125;</code></pre><pre><code class="hljs c">Enter an integer:<span class="hljs-number">212</span><span class="hljs-number">212</span> is even.Thus terminates another magnificent program from <span class="hljs-comment">//sign_off</span>SeeSaw Software!</code></pre><pre><code class="hljs c">Here’s a second <span class="hljs-built_in">run</span>:Enter an integer:what?That<span class="hljs-number">'</span>s no integer!SeeSaw Software extends its heartfelt condolences <span class="hljs-comment">//too_bad</span>to you upon the failure of your program.Thus terminates another magnificent program from  <span class="hljs-comment">//sign_off</span>SeeSaw Software!</code></pre><p>Because the name of a function acts as an address when used as a function argument, use <code>sign_off</code> or <code>too_bad</code> as the argument. </p><p>Then atexit() registers that function in a list of functions to be executed when exit() is called.</p><p>ANSI guarantees that you can place at least 32 functions on the list. Each function is added with a separate call to atexit(). When the exit() function is finally called, it executes these functions, with the last function added being executed first.</p><p>The functions registered by atexit() should be type void functions taking no arguments. </p><p>Typically, they would perform housekeeping tasks, such as updating a program-monitoring file or resetting environmental variables.</p><p>Note that sign_off() is called even when exit() is not called explicitly; that’s because <strong>exit() is called implicitly when main() terminates</strong>.</p><p>After exit() executes the functions specified by atexit(), it does some tidying of its own. It flushes all output streams, closes all open streams, and closes temporary files created by calls to the standard I/O function tmpfile(). </p><p>Then exit() returns control to the host environment and, if possible, reports a termination status to the environment. </p><p>ANSI C defined a macro called EXIT_FAILURE that can be used portably to indicate failure. Similarly, it defined EXIT_SUCCESS to indicate success, but exit() also accepts 0 for that purpose. </p><p>Under ANSI C, using the exit() function in a nonrecursive main() function is equivalent to using the keyword return. However, exit() also terminates programs when used in functions other than main().</p><h1 id="10-The-Assert-Library"><a href="#10-The-Assert-Library" class="headerlink" title="10. The Assert Library"></a>10. The Assert Library</h1><p>The assert library, supported by the assert.h header file, is a small one designed to help with debugging programs. </p><p>It consists of a macro named assert(). It takes as its argument an integer expression. If the expression evaluates as false (nonzero), the assert() macro writes an error message to the standard error stream (stderr) and calls the abort() function, which terminates the program. (The abort() function is prototyped in the stdlib.h header file.) </p><p>The idea is to identify critical locations in a program where certain conditions should be true and to use the assert() statement to terminate the program if one of the specified conditions is not true. </p><p>Typically, the argument is a relational or logical expression. If assert() does abort the program, it first displays the test that failed, the name of the file containing the test, and a line number.</p><pre><code class="hljs c"><span class="hljs-comment">/* assert.c -- use assert() */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> x, y, z;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter a pair of numbers (0 0 to quit): "</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>, &amp;x, &amp;y) == <span class="hljs-number">2</span> &amp;&amp; (x != <span class="hljs-number">0</span> || y != <span class="hljs-number">0</span>))    &#123;        z = x * x - y * y; <span class="hljs-comment">/* should be + */</span>        assert(z &gt;= <span class="hljs-number">0</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"answer is %f\n"</span>, <span class="hljs-built_in">sqrt</span>(z));        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Next pair of numbers: "</span>);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Done"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function">Enter a pair of <span class="hljs-title">numbers</span> <span class="hljs-params">(<span class="hljs-number">0</span> <span class="hljs-number">0</span> to quit)</span>: </span><span class="hljs-function">4 3</span>answer is 2.645751Next pair of numbers: <span class="hljs-number">3</span> <span class="hljs-number">5</span>assert: assert.c:<span class="hljs-number">12</span>: main: Assertion `z &gt;= <span class="hljs-number">0'</span> failed.Aborted (core dumped)</code></pre><p> If you think you’ve eliminated the program bugs, place the macro definition<code>#define NDEBUG</code> before the location where assert.h is included and then recompile the program, and the compiler will deactivate all assert() statements in the file. </p><p>The assert() expression is a run-time check. C11 adds a feature, the <strong>_Static_assert</strong> declaration, that does a <strong>compile-time</strong> check. So, assert() can cause a running program to abort, while _Static_assert() can cause a program not to compile. </p><p>The latter takes two arguments. The first is a constant integer expression, and the second is a string. </p><p>If the first expression evaluates to 0 (or _False), the compiler displays the string and does not compile the program.</p><pre><code class="hljs c"><span class="hljs-comment">// statasrt.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;limits.h&gt;</span></span>_Static_assert(CHAR_BIT == <span class="hljs-number">16</span>, <span class="hljs-string">"16-bit char falsely assumed"</span>);<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">"char is 16 bits."</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs bash">statasrt.c:4:1: error: static assertion failed: <span class="hljs-string">"16-bit char falsely assumed"</span>    4 | _Static_assert(CHAR_BIT == 16, <span class="hljs-string">"16-bit char falsely assumed"</span>);      | ^~~~~~~~~~~~~~</code></pre><h1 id="11-memcpy-and-memmove-from-the-string-h-Library"><a href="#11-memcpy-and-memmove-from-the-string-h-Library" class="headerlink" title="11. memcpy() and memmove() from the string.h Library"></a>11. memcpy() and memmove() from the string.h Library</h1><p>You can’t assign one array to another, so we’ve been using loops to copy one array to another, element by element. </p><p>The one exception is that we’ve used the strcpy() and strncpy() functions for character arrays. </p><p>The memcpy() and memmove() functions offer you almost the same convenience for other kinds of arrays. </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">restrict</span> s2, <span class="hljs-keyword">size_t</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memmove</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>Both of these functions copy <code>n</code> bytes from the location pointed to by <code>s2</code> to the location pointed to by <code>s1</code>, and both return the value of <code>s1</code>. </p><p>The difference between the two, as indicated by the keyword <code>restrict</code>, is that memcpy() is free to assume that there is no overlap between the two memory ranges. </p><p>The memmove() function doesn’t make that assumption, so copying takes place as if all the bytes are first copied to a temporary buffer before being copied to the final destination. </p><p>What if you use memcpy() when there are overlapping ranges? The behavior is undefined, meaning it might work or it might not. </p><p>Because these functions are designed to work with any data type, the two pointer arguments are type pointer-to-void. C allows you to assign any pointer type to pointers of the void * type. </p><p>The other side of this tolerant acceptance is that these functions have no way of knowing what type of data is being copied. Therefore, they use the third argument to indicate the number of bytes to be copied. </p><p>Note that for an array, the number of bytes is not, in general, the number of elements. So if you were copying an array of 10 double values, you would use <code>10*sizeof(double)</code>, not 10, as the third argument.</p><h1 id="10-Variable-Arguments-stdarg-h"><a href="#10-Variable-Arguments-stdarg-h" class="headerlink" title="10. Variable Arguments: stdarg.h"></a>10. Variable Arguments: stdarg.h</h1><p>Earlier, this chapter discussed variadic macros—macros that can accept a variable number of arguments. The stdarg.h header file provides a similar capability for functions. But the usage is a bit more involved. You have to do the following:</p><ol><li>Provide a function prototype using an ellipsis.</li><li>Create a va_list type variable in the function definition.</li><li>Use a macro to initialize the variable to an argument list.</li><li>Use a macro to access the argument list.</li><li>Use a macro to clean up.</li></ol><p>The prototype for such a function should have a parameter list with at least one parameter followed by an ellipsis:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, ...)</span></span>; <span class="hljs-comment">// valid</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s, <span class="hljs-keyword">int</span> k, ...)</span></span>; <span class="hljs-comment">// valid</span><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c1, ..., <span class="hljs-keyword">char</span> c2)</span></span>; <span class="hljs-comment">// invalid, ellipsis not last</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f3</span><span class="hljs-params">(...)</span></span>; <span class="hljs-comment">// invalid, no parameter</span></code></pre><p>The rightmost parameter (the one just before the ellipses) plays a special role; the standard uses the term parmN as a name to use in discussion. </p><p>In the preceding examples, parmN would be n for the first case and k for the second case. </p><p>The actual argument passed to this parameter will be the number of arguments represented by the ellipses section. </p><pre><code class="hljs c">f1(<span class="hljs-number">2</span>, <span class="hljs-number">200</span>, <span class="hljs-number">400</span>); <span class="hljs-comment">// 2 additional arguments</span>f1(<span class="hljs-number">4</span>, <span class="hljs-number">13</span>, <span class="hljs-number">117</span>, <span class="hljs-number">18</span>, <span class="hljs-number">23</span>); <span class="hljs-comment">// 4 additional arguments</span></code></pre><p>Next, the va_list type, which is declared in the stdargs.h header file, represents a data object used to hold the parameters corresponding to the ellipsis part of the parameter list. The beginning of a definition of a variadic function would look something like this:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lim,...)</span></span><span class="hljs-function"></span>&#123;    va_list ap; <span class="hljs-comment">// declare object to hold arguments</span>&#125;</code></pre><p>In this example, lim is the parmN parameter, and it will indicate the number of arguments in the variable-argument list.</p><p>After this, the function will use the va_start() macro, also defined in stdargs.h, to copy the argument list to the va_list variable. The macro has two arguments: the va_list variable and the parmN parameter. Continuing with the previous example, the va_list variable is called ap and the parmN parameter is call lim, so the call would look like this:</p><pre><code class="hljs c">va_start(ap, lim); <span class="hljs-comment">// initialize ap to argument list</span></code></pre><p>The next step is gaining access to the contents of the argument list. This involves using va_arg(), another macro. It takes two arguments: a type va_list variable and a type name. </p><p>The first time it’s called, it returns the first item in the list; the next time it’s called, it returns the next item, and so on. The type argument specifies the type of value returned. </p><pre><code class="hljs c"><span class="hljs-keyword">double</span> tic;<span class="hljs-keyword">int</span> toc;...tic = va_arg(ap, <span class="hljs-keyword">double</span>); <span class="hljs-comment">// retrieve first argument</span>toc = va_arg(ap, <span class="hljs-keyword">int</span>); <span class="hljs-comment">// retrieve second argument</span></code></pre><p>Be careful. The argument type really has to match the specification. If the first argument is 10.0, the previous code for tic works fine. But if the argument is 10, the code may not work; the automatic conversion of double to int that works for assignment doesn’t take place here.</p><p>Finally, you should clean up by using the va_end() macro. </p><pre><code class="hljs c">va_end(ap); <span class="hljs-comment">// clean up</span></code></pre><p>After you do this, the variable ap may not be usable unless you use va_start to reinitialize it.</p><p>Because va_arg() doesn’t provide a way to back up to previous arguments, it may be useful to preserve a copy of the va_list type variable. C99 has added a macro for that purpose. It’s called va_copy(). </p><p>Its two arguments are both type va_list variables, and it copies the second argument to the first:</p><pre><code class="hljs c">va_list ap;va_list apcopy;<span class="hljs-keyword">double</span><span class="hljs-keyword">double</span> tic;<span class="hljs-keyword">int</span> toc;...va_start(ap, lim); <span class="hljs-comment">// initialize ap to argument list</span>va_copy(apcopy, ap); <span class="hljs-comment">// make apcopy a copy of ap</span>tic = va_arg(ap, <span class="hljs-keyword">double</span>); <span class="hljs-comment">// retrieve first argument</span>toc = va_arg(ap, <span class="hljs-keyword">int</span>); <span class="hljs-comment">// retrieve second argument</span></code></pre><p>At this point, you could still retrieve the first two items from apcopy, even though they have been removed from ap.</p><pre><code class="hljs c"><span class="hljs-comment">//varargs.c -- use variable number of arguments</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, ...)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> s,t;    s = sum(<span class="hljs-number">3</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">13.3</span>);    t = sum(<span class="hljs-number">6</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">2.1</span>, <span class="hljs-number">13.1</span>, <span class="hljs-number">4.1</span>, <span class="hljs-number">5.1</span>, <span class="hljs-number">6.1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"return value for "</span>    <span class="hljs-string">"sum(3, 1.1, 2.5, 13.3): %g\n"</span>, s);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"return value for "</span>    <span class="hljs-string">"sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): %g\n"</span>, t);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lim,...)</span></span><span class="hljs-function"></span>&#123;    va_list ap; <span class="hljs-comment">// declare object to hold arguments</span>    <span class="hljs-keyword">double</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> i;    va_start(ap, lim); <span class="hljs-comment">// initialize ap to argument list</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; lim; i++)        tot += va_arg(ap, <span class="hljs-keyword">double</span>); <span class="hljs-comment">// access each item in argument list</span>    va_end(ap); <span class="hljs-comment">// clean up</span>    <span class="hljs-keyword">return</span> tot;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bit Fidding</title>
    <link href="/2020/12/06/Bit-Fidding/"/>
    <url>/2020/12/06/Bit-Fidding/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 15 Bit Fidding</p><a id="more"></a><h1 id="1-Binary-Numbers-Bits-and-Bytes"><a href="#1-Binary-Numbers-Bits-and-Bytes" class="headerlink" title="1. Binary Numbers, Bits, and Bytes"></a>1. Binary Numbers, Bits, and Bytes</h1><h2 id="1-Binary-Integers"><a href="#1-Binary-Integers" class="headerlink" title="(1) Binary Integers"></a>(1) Binary Integers</h2><p>Usually, a <strong>byte</strong> contains 8 bits. C, remember, uses the term byte to denote the size used to hold a system’s character set, so a C byte could be 8 bits, 9 bits, 16 bits, or some other value.</p><p>However, the 8-bit byte is the byte used to describe memory chips and the byte used to describe data transfer rates. To keep matters simple, this chapter assumes an 8-bit byte.</p><h2 id="2-Signed-Integers"><a href="#2-Signed-Integers" class="headerlink" title="(2) Signed Integers"></a>(2) Signed Integers</h2><p>The representation of <strong>signed numbers</strong> is determined by the <strong>hardware</strong>, not by <strong>C</strong>. </p><h3 id="符号量表示法"><a href="#符号量表示法" class="headerlink" title="符号量表示法"></a>符号量表示法</h3><p>用1位（如， 高阶位） 储存符号， 只剩下7位表示数字本身（假设储存在1字节中，假设一个字节是8位） 。 用这种符号量（sign-magnitude） 表示法， 10000001表示−1，00000001表示1。 因此， 其表示范围−127～+127。</p><p><strong>缺点:</strong> 有两个0： +0和-0。 这很容易混淆， 而且用两个位组合来表示一个值也有些浪费。</p><h3 id="二进制补码表示法"><a href="#二进制补码表示法" class="headerlink" title="二进制补码表示法"></a>二进制补码表示法</h3><p>补码内容参看：</p><blockquote><p>深入理解计算机系统英文版第二版 – 第二章 p94</p></blockquote><p>该部分内容介绍参考<a href="https://www.cnblogs.com/ysocean/p/7531660.html#_label3" target="_blank" rel="noopener"> 深入理解计算机系统（2.4）——整数的表示（无符号编码和补码编码）</a></p><h3 id="二进制浮点型"><a href="#二进制浮点型" class="headerlink" title="二进制浮点型"></a>二进制浮点型</h3><p>该内容参看：</p><blockquote><p>深入理解计算机系统英文版第二版 – 第二章 p133</p></blockquote><p>该部分内容介绍参考<a href="https://www.cnblogs.com/ysocean/p/7531667.html" target="_blank" rel="noopener">深入理解计算机系统（2.7）——二进制小数和IEEE浮点标准</a></p><h1 id="2-C’s-Bitwise-Operators"><a href="#2-C’s-Bitwise-Operators" class="headerlink" title="2. C’s Bitwise Operators"></a>2. C’s Bitwise Operators</h1><blockquote><p>深入理解计算机系统英文版第二版 – 第二章 p85</p></blockquote><h2 id="1-Bitwise-Logical-Operators"><a href="#1-Bitwise-Logical-Operators" class="headerlink" title="(1) Bitwise Logical Operators"></a>(1) Bitwise Logical Operators</h2><h3 id="二进制反码或按位取反：-～"><a href="#二进制反码或按位取反：-～" class="headerlink" title="二进制反码或按位取反： ～"></a>二进制反码或按位取反： ～</h3><p>一元运算符<strong>～</strong>把1变为0， 把0变为1。</p><pre><code class="hljs c">~(<span class="hljs-number">10011010</span>) <span class="hljs-comment">// expression</span>(<span class="hljs-number">01100101</span>) <span class="hljs-comment">// resulting value</span></code></pre><h3 id="按位与：-amp"><a href="#按位与：-amp" class="headerlink" title="按位与： &amp;"></a>按位与： &amp;</h3><p>二元运算符<strong>&amp;</strong>通过逐位比较两个运算对象， 生成一个新值。<br>对于每个位， 只有两个运算对象中相应的位都为1时， 结果才为1（从真/假方面看，只有当两个位都为真时， 结果才为真）。 </p><h3 id="按位或："><a href="#按位或：" class="headerlink" title="按位或： |"></a>按位或： |</h3><p>二元运算符<strong>|</strong>， 通过逐位比较两个运算对象， 生成一个新值。<br>对于每个位， 如果两个运算对象中相应的位为1， 结果就为1（从真/假方面看， 如果两个运算对象中相应的一个位为真或两个位都为真， 那么结果为真） 。 </p><h3 id="按位异或："><a href="#按位异或：" class="headerlink" title="按位异或： ^"></a>按位异或： ^</h3><p>二元运算符<strong>^</strong>逐位比较两个运算对象。<br>只有当两个值<strong>相异</strong>时为真（值为1），同为1或同为0为假（值为0）。</p><h2 id="2-Masks"><a href="#2-Masks" class="headerlink" title="(2) Masks"></a>(2) Masks</h2><p>按位与运算符常用于掩码（mask） 。 所谓掩码指的是一些设置为开（1） 或关（0） 的位组合。 </p><p>例如， 假设定义符号常量MASK为2 （即，二进制形式为00000010） ， 只有1号位是1， 其他位都是0。 下面的语句：</p><pre><code class="hljs c">flags = flags &amp; MASK;</code></pre><p>把flags中除1号位以外的所有位都设置为0， 因为使用按位与运算符（&amp;） 任何位与0组合都得0。 1号位的值不变（如果1号位是1， 那么 1&amp;1得1； 如果 1号位是0， 那么 0&amp;1也得0） 。 这个过程叫作“使用掩码”， 因为掩码中的0隐藏了flags中相应的位。</p><p>可以这样类比： 把掩码中的0看作不透明， 1看作透明。 表达式flags &amp;MASK相当于用掩码覆盖在flags的位组合上， 只有MASK为1的位才可见。</p><h2 id="3-Turning-Bits-On-Setting-Bits"><a href="#3-Turning-Bits-On-Setting-Bits" class="headerlink" title="(3) Turning Bits On (Setting Bits)"></a>(3) Turning Bits On (Setting Bits)</h2><p>有时， 需要打开一个值中的特定位， 同时保持其他位不变。如：</p><pre><code class="hljs c">flags = flags | MASK;</code></pre><p>根据MASK中为1的位， 把flags中对应的位设置为1， 其他位不变。</p><h2 id="4-Turning-Bits-Off-Clearing-Bits"><a href="#4-Turning-Bits-Off-Clearing-Bits" class="headerlink" title="(4) Turning Bits Off (Clearing Bits)"></a>(4) Turning Bits Off (Clearing Bits)</h2><p>和打开特定的位类似， 有时也需要在不影响其他位的情况下关闭指定的位。 假设要关闭变量flags中的1号位。将 MASK设为只有1号位为0，其余全为1，则：</p><pre><code class="hljs c">flags = flags &amp; MASK;</code></pre><p>将1号位变为0，其余不变。</p><h2 id="5-Toggling-Bits"><a href="#5-Toggling-Bits" class="headerlink" title="(5) Toggling Bits"></a>(5) Toggling Bits</h2><p>切换位指的是打开已关闭的位， 或关闭已打开的位。 可以使用按位异或运算符（^） 切换位。</p><p>将 flag 中需要进行切换位的地方对应的mask的部分设为1，其余为0。</p><pre><code class="hljs c">flags ^= MASK;</code></pre><p>flags中与MASK为1的位相对应的位都被切换了， MASK为0的位相对应的位不变。</p><h2 id="6-Checking-the-Value-of-a-Bit"><a href="#6-Checking-the-Value-of-a-Bit" class="headerlink" title="(6)  Checking the Value of a Bit"></a>(6)  Checking the Value of a Bit</h2><p>有时， 需要检查某位的值。 例如， flags中1号位是否被设置为1。</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((flags &amp; MASK) == MASK)    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Wow!"</span>);</code></pre><p>将mask中检查的位设为1，其余设为0，这样确保其余位与mask相同，均为0，只比较检查的位。</p><h2 id="7-Bitwise-Shift-Operators"><a href="#7-Bitwise-Shift-Operators" class="headerlink" title="(7) Bitwise Shift Operators"></a>(7) Bitwise Shift Operators</h2><h3 id="左移：-lt-lt"><a href="#左移：-lt-lt" class="headerlink" title="左移： &lt;&lt;"></a>左移： &lt;&lt;</h3><p>左移运算符（&lt;&lt;） 将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数。 左侧运算对象移出左末端位的值丢失， 用0填充右边空出的位置。 </p><h3 id="右移：-gt-gt"><a href="#右移：-gt-gt" class="headerlink" title="右移： &gt;&gt;"></a>右移： &gt;&gt;</h3><p><strong>逻辑右移:</strong> 右移后左边的空出来位补0，对于 unsigned 数据为逻辑右移。</p><p><strong>算数右移:</strong> 右移后左边空出的数据全部用数据的最高位值填充。对于 signed 数据，可用逻辑右移或算数右移，但通常用算数右移。</p><p>测试对signed 和 unsigned 进行右移测试，得到，<strong>unsigned 采用逻辑右移，signed 采用算数右移</strong>。见下面程序：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0xfffffffe</span>;    <span class="hljs-keyword">unsigned</span> m = <span class="hljs-number">0xfffffffe</span>;    <span class="hljs-keyword">int</span> n1 = n &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> m1 = m &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> n2 = (<span class="hljs-keyword">unsigned</span>) n &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//对signed先强制转换为unsigned</span>    <span class="hljs-keyword">int</span> m2 = m &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"n1 = 0x%x, n2 = 0x%x\nm1 = 0x%x, m2 = 0x%x\n"</span>,n1,n2,m1,m2);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>结果：</p><pre><code class="hljs c">n1 = <span class="hljs-number">0xffffffff</span>, n2 = <span class="hljs-number">0x7fffffff</span>m1 = <span class="hljs-number">0x7fffffff</span>, m2 = <span class="hljs-number">0x7fffffff</span></code></pre><h2 id="8-Programming-Example"><a href="#8-Programming-Example" class="headerlink" title="(8) Programming Example"></a>(8) Programming Example</h2><p>以下程序实现功能：将一个 int 型数字转换为二进制</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;limits.h&gt;//for CHAR_BIT, #of bits per char</span></span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">itobs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span> *)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_bstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    char bin_str[CHAR_BIT *sizeof(int) + 1];    <span class="hljs-keyword">int</span> number;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter integers and see them in library."</span>);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Non-numeric input terminates program."</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;number)==<span class="hljs-number">1</span>)    &#123;        itobs(number,bin_str);        show_bstr(bin_str);        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Next interger:"</span>);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">itobs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> *ps)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = CHAR_BIT * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);    <span class="hljs-keyword">for</span>(i = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--, n &gt;&gt;= <span class="hljs-number">1</span>)        ps[i] = (<span class="hljs-number">01</span> &amp; n) + <span class="hljs-string">'0'</span>;    ps[<span class="hljs-built_in">size</span>] = <span class="hljs-string">'\0'</span>;    <span class="hljs-keyword">return</span> ps;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_bstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(str[i])    &#123;        <span class="hljs-built_in">putchar</span>(str[i]);        <span class="hljs-keyword">if</span>(++i % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; str[i])            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">' '</span>);   &#125;&#125;</code></pre><p>程序分析：</p><ol><li><code>CHAR_BIT</code> 为 <strong>limits.h</strong> 头文件中定义的宏，一个字节的比特数。</li><li><code>char bin_str[CHAR_BIT *sizeof(int) + 1];</code> 声明一个字符串数组存放转化后的二进制数，<code>CHAR_BIT *sizeof(int)</code> 得到 <strong>int</strong> 的比特数，还需要加1为存储字符串结束符。</li><li><code>char *itobs(int n, char *ps)</code> 函数中<code>ps[i] = (01 &amp; n) + &#39;0&#39;;</code> 语句中 01 值八进制数据，与 n 按位与后得到 n 的最低位，因为存储的是字符串，需要转化为 ascall 码，因此加 ‘0’得到实际的数值。</li></ol><p>下面是反转指定位数函数，将最后bits位的数反转：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">invert_end</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> bits)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> bitval = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (bits--&gt; <span class="hljs-number">0</span>)    &#123;        mask |= bitval;        bitval &lt;&lt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> num ^ mask;&#125;</code></pre><p>该函数中 bits 为需要反转的位数，反转最后 bits 位。</p><h1 id="3-Bit-Fields"><a href="#3-Bit-Fields" class="headerlink" title="3. Bit Fields"></a>3. Bit Fields</h1><p>The second method of <strong>manipulating bits</strong> is to use a <strong>bit field</strong>, which is just a set of neighboring bits within a <strong>signed int</strong> or an <strong>unsigned int</strong>. (C99 and C11 additionally allow <strong>type _Bool</strong> bit fields.) </p><p>A bit field is set up with a <strong>structure declaration</strong> that labels each field and determines its <strong>width</strong>. For example, the following declaration sets up four 1-bit fields:</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> autfd : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bldfc : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> undln : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> itals : <span class="hljs-number">1</span>;&#125; prnt;</code></pre><p>This definition causes <code>prnt</code> to contain four 1-bit fields. Now you can use the usual structure membership operator to assign values to individual fields:</p><pre><code class="hljs c">prnt.itals = <span class="hljs-number">0</span>;prnt.undln = <span class="hljs-number">1</span>;</code></pre><p>Because each of these particular fields is just 1 bit, 1 and 0 are the only values you can use for assignment. The variable <code>prnt</code> is stored in an int-sized memory cell, but only 4 bits are used in this example.</p><p>A structure with bit fields allows you to store several settings in a single unit.</p><p>Sometimes there are more than two choices for a setting, so you need more than a single bit to represent all the choices. That’s not a problem because fields aren’t limited to 1-bit sizes. </p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> code1 : <span class="hljs-number">2</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> code2 : <span class="hljs-number">2</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> code3 : <span class="hljs-number">8</span>;&#125; prcode;prcode.code1 = <span class="hljs-number">0</span>;prcode.code2 = <span class="hljs-number">3</span>;prcode.code3 = <span class="hljs-number">102</span>;</code></pre><p>Just make sure the value doesn’t exceed the capacity of the field.</p><p>If the total number of bits you declare exceeds the size of an unsigned int, then the next unsigned int storage location is used. </p><p>A single field is not allowed to overlap the boundary between two unsigned ints. </p><p>The compiler automatically shifts an overlapping field definition so that the field is aligned with the <strong>unsigned int</strong> boundary. </p><p>When this occurs, it leaves an <strong>unnamed hole</strong> in the first unsigned int. You can “pad” a field structure with <strong>unnamed holes</strong> by using <strong>unnamed field widths</strong>. </p><p>Using an unnamed field width of 0 forces the next field to align with the next integer:</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> field1 : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">2</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> field2 : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">0</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> field3 : <span class="hljs-number">1</span>;&#125; stuff;</code></pre><p>Here, there is a 2-bit gap between <code>stuff.field1</code> and <code>stuff.field2</code>, and <code>stuff.field3</code> is stored in the next int.</p><p>One important machine dependency is the order in which fields are placed into an int. On some machines, the order is left to right; on others, it is right to left.</p><p>Also, machines differ in the location of boundaries between fields. For these reasons, bit fields tend not to be very portable. </p><blockquote><p>深入理解计算机系统英文版第二版 – p73<br>字节存储顺序：从小到大，从大到小</p></blockquote><p>Often bit fields are used as a more <strong>compact</strong> way of storing data. Suppose, for example, you decided to represent the properties of an onscreen box. Let’s keep the graphics simple and suppose the box has the following properties:</p><ul><li>The box is opaque or transparent.</li><li>The fill color is selected from the following palette of colors: black, red, green, yellow, blue, magenta, cyan, or white.</li><li>The border can be shown or hidden.</li><li>The border color is selected from the same palette used for the fill color.</li><li>The border can use one of three line styles—solid, dotted, or dashed.<pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">box_props</span> &#123;</span><span class="hljs-keyword">bool</span> opaque : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fill_color : <span class="hljs-number">3</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">4</span>;<span class="hljs-keyword">bool</span> show_border : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> border_color : <span class="hljs-number">3</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> border_style : <span class="hljs-number">2</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">2</span>;&#125;;</code></pre>The padding brings the structure up to 16 bits. Without padding, the structure would be 10 bits. Keep in mind, however, that C uses <strong>unsigned int</strong> as the basic layout unit for structures with bit fields. So even if the sole member of a structure is a single 1-bit field, the structure will have the same size as an unsigned int, which is 32 bits on our system. Also, this coding assumes that the C99 _Bool type is available and is aliased as bool in <strong>stdbool.h</strong>.</li></ul><p>You can use a value of 1 for the <code>opaque</code> member to indicate that the box is opaque and a 0 value to indicate transparency. </p><p>You can do the same for the <code>show_border</code> member. </p><p>For <strong>colors</strong>, you can use a simple RGB (red-green-blue) representation. These are the primary colors for mixing light. A monitor blends red, green, and blue pixels to reproduce different colors. </p><p> Finally, you can choose to let 0, 1, and 2 represent the <strong>solid</strong>, <strong>dotted</strong>, and <strong>dashed</strong> styles; they can be used as values for the <code>border_style</code> member.</p><p><img src="_v_images/20201207230858132_355553505.png" srcset="/img/loading.gif" alt="Color"></p><pre><code class="hljs c"><span class="hljs-comment">/* dualview.c -- bit fields and bitwise operators */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;limits.h&gt;</span></span><span class="hljs-comment">/* BIT-FIELD CONSTANTS */</span><span class="hljs-comment">/* line styles */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOLID 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DOTTED 1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DASHED 2</span><span class="hljs-comment">/* primary colors */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLUE 4</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GREEN 2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RED 1</span><span class="hljs-comment">/* mixed colors */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLACK 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> YELLOW (RED | GREEN)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAGENTA (RED | BLUE)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CYAN (GREEN | BLUE)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WHITE (RED | GREEN | BLUE)</span><span class="hljs-comment">/* BITWISE CONSTANTS */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OPAQUE 0x1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILL_BLUE 0x8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILL_GREEN 0x4</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILL_RED 0x2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILL_MASK 0xE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BORDER 0x100</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BORDER_BLUE 0x800</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BORDER_GREEN 0x400</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BORDER_RED 0x200</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BORDER_MASK 0xE00</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_SOLID 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_DOTTED 0x1000</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_DASHED 0x2000</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STYLE_MASK 0x3000</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *colors[<span class="hljs-number">8</span>] = &#123;<span class="hljs-string">"black"</span>, <span class="hljs-string">"red"</span>, <span class="hljs-string">"green"</span>, <span class="hljs-string">"yellow"</span>,<span class="hljs-string">"blue"</span>, <span class="hljs-string">"magenta"</span>, <span class="hljs-string">"cyan"</span>, <span class="hljs-string">"white"</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">box_props</span> &#123;</span><span class="hljs-keyword">bool</span> opaque : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fill_color : <span class="hljs-number">3</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">4</span>;<span class="hljs-keyword">bool</span> show_border : <span class="hljs-number">1</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> border_color : <span class="hljs-number">3</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> border_style : <span class="hljs-number">2</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> : <span class="hljs-number">2</span>;&#125;;<span class="hljs-keyword">union</span> Views <span class="hljs-comment">/* look at data as struct or as unsigned short */</span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">box_props</span> <span class="hljs-title">st_view</span>;</span>    <span class="hljs-keyword">unsigned</span> short us_view;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_settings</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct box_props * pb)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_settings1</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> short)</span></span>;<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">itobs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> * ps)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">/* create Views object, initialize struct box view */</span>    <span class="hljs-keyword">union</span> Views box = &#123;&#123;<span class="hljs-literal">true</span>, YELLOW , <span class="hljs-literal">true</span>, GREEN, DASHED&#125;&#125;;    <span class="hljs-keyword">char</span> bin_str[<span class="hljs-number">8</span> *<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) + <span class="hljs-number">1</span>];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Original box settings:\n"</span>);    show_settings(&amp;box.st_view);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nBox settings using unsigned int view:\n"</span>);    show_settings1(box.us_view);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"bits are %s\n"</span>,    itobs(box.us_view,bin_str));    box.us_view &amp;= ~FILL_MASK; <span class="hljs-comment">/* clear fill bits */</span>    box.us_view |= (FILL_BLUE | FILL_GREEN); <span class="hljs-comment">/* reset fill */</span>    box.us_view ^= OPAQUE; <span class="hljs-comment">/* toggle opacity */</span>    box.us_view |= BORDER_RED; <span class="hljs-comment">/* wrong approach */</span>    box.us_view &amp;= ~STYLE_MASK; <span class="hljs-comment">/* clear style bits */</span>    box.us_view |= B_DOTTED; <span class="hljs-comment">/* set style to dotted */</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nModified box settings:\n"</span>);    show_settings(&amp;box.st_view);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nBox settings using unsigned int view:\n"</span>);    show_settings1(box.us_view);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"bits are %s\n"</span>,    itobs(box.us_view,bin_str));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_settings</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct box_props * pb)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Box is %s.\n"</span>,    pb-&gt;opaque == <span class="hljs-literal">true</span> ? <span class="hljs-string">"opaque"</span>: <span class="hljs-string">"transparent"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The fill color is %s.\n"</span>, colors[pb-&gt;fill_color]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Border %s.\n"</span>,    pb-&gt;show_border == <span class="hljs-literal">true</span> ? <span class="hljs-string">"shown"</span> : <span class="hljs-string">"not shown"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The border color is %s.\n"</span>, colors[pb-&gt;border_color]);    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"The border style is "</span>);    <span class="hljs-keyword">switch</span>(pb-&gt;border_style)    &#123;        <span class="hljs-keyword">case</span> SOLID : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"solid.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> DOTTED : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dotted.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> DASHED : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dashed.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span> : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"unknown type.\n"</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_settings1</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> short us)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"box is %s.\n"</span>,    (us &amp; OPAQUE) == OPAQUE? <span class="hljs-string">"opaque"</span>: <span class="hljs-string">"transparent"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The fill color is %s.\n"</span>,    colors[(us &gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">07</span>]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Border %s.\n"</span>,    (us &amp; BORDER) == BORDER? <span class="hljs-string">"shown"</span> : <span class="hljs-string">"not shown"</span>);    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"The border style is "</span>);    <span class="hljs-keyword">switch</span>(us &amp; STYLE_MASK)    &#123;        <span class="hljs-keyword">case</span> B_SOLID : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"solid.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> B_DOTTED : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dotted.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> B_DASHED : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dashed.\n"</span>); <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span> : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"unknown type.\n"</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The border color is %s.\n"</span>,    colors[(us &gt;&gt; <span class="hljs-number">9</span>) &amp; <span class="hljs-number">07</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">itobs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> * ps)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = CHAR_BIT * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);    <span class="hljs-keyword">for</span> (i = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--, n &gt;&gt;= <span class="hljs-number">1</span>)        ps[i] = (<span class="hljs-number">01</span> &amp; n) + <span class="hljs-string">'0'</span>;    ps[<span class="hljs-built_in">size</span>] = <span class="hljs-string">'\0'</span>;    <span class="hljs-keyword">return</span> ps;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>File Input/Output</title>
    <link href="/2020/12/06/File-Input-Output/"/>
    <url>/2020/12/06/File-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 13 File Input/Output</p><a id="more"></a><h1 id="1-Communicating-with-Files"><a href="#1-Communicating-with-Files" class="headerlink" title="1. Communicating with Files"></a>1. Communicating with Files</h1><h2 id="1-File"><a href="#1-File" class="headerlink" title="(1) File"></a>(1) File</h2><p>A <strong>file</strong> is a named section of storage, usually on a disk, or, more recently, on a solid-state device.</p><p>C views a <strong>file</strong> as a continuous sequence of bytes, each of which can be read individually. C provides two ways to view files: the <strong>text view</strong> and the <strong>binary view</strong>.</p><p>All file content is in <strong>binary form</strong> (zeros and ones). But if a file primarily uses the <strong>binary codes</strong> for <strong>characters</strong> (for instance, <strong>ASCII</strong> or <strong>Unicode</strong>) to represent <strong>text</strong>, much as a <strong>C string</strong> does, then it is a <strong>text file</strong>; it has text content. </p><p>If the <strong>binary values</strong> in the file represent <strong>machinelanguage code</strong> or <strong>numeric data</strong> (using the same internal representation as, say, used for long or double values) or image or music encoding, the content is <strong>binary</strong>.</p><p>To bring some regularity to the handling of text files, C provides two ways of accessing a file: <strong>binary mode</strong> and <strong>text mode</strong>. </p><p>In the <strong>binary mode</strong>, each and every byte of the file is accessible to a program. </p><p>In the <strong>text mode</strong>, however, what the program sees can differ from what is in the file. </p><p>For example, a C program compiled on an older Macintosh and using text mode would convert \r to \n when reading a file in text mode and convert \n to \r when writing to a file. </p><h2 id="2-Standard-Files"><a href="#2-Standard-Files" class="headerlink" title="(2) Standard Files"></a>(2) Standard Files</h2><p>C programs automatically open three files on your behalf. They are termed the <strong>standard input</strong>, the <strong>standard output</strong>, and the <strong>standard error output</strong>. </p><p>The <strong>standard input</strong>, by default, is the normal input device for your system, usually your keyboard. Both the <strong>standard output</strong> and the <strong>standard error output</strong>, by default, are the normal output device for your system, usually your display screen.</p><p>The purpose of the <strong>standard error output</strong> file is to provide a logically distinct place to send error messages. If, for example, you use redirection to send output to a file instead of to the screen, output sent to the standard error output still goes to the screen. </p><h1 id="2-Standard-I-O"><a href="#2-Standard-I-O" class="headerlink" title="2. Standard I/O"></a>2. Standard I/O</h1><p>The <strong>standard I/O package</strong> has two advantages, besides <strong>portability</strong>, over low-level I/O. </p><p>First, it has many specialized functions that simplify handling different I/O problems. </p><p>Second, input and output are <strong>buffered</strong>. That is, information is transferred in large chunks (typically 512 bytes at a time or more) instead of a byte at a time. </p><h2 id="1-The-fopen-Function"><a href="#1-The-fopen-Function" class="headerlink" title="(1) The fopen() Function"></a>(1) The fopen() Function</h2><p>The program uses <strong>fopen()</strong> to open the file. This function is declared in <strong>stdio.h</strong>. </p><p>Its <strong>first argument</strong> is the name of the file to be opened; more exactly, it is the address of a string containing that name. The <strong>second argument</strong> is a string identifying the <strong>mode</strong> in which the file is to be opened.</p><table><thead><tr><th align="left">Mode String</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">“r”</td><td align="left"></td></tr><tr><td align="left">“w”</td><td align="left">Open a text file for writing, truncating an existing file to zero length, or creating the file if it does not exist.</td></tr><tr><td align="left">“a”</td><td align="left">Open a text file for writing, appending to the end of an existing file, or creating the file if it does not exist.</td></tr><tr><td align="left">“r+”</td><td align="left">Open a text file for update (that is, for both reading and writing).</td></tr><tr><td align="left">“w+</td><td align="left">Open a text file for update (reading and writing), first truncating the file to zero length if it exists or creating the file if it does not exist.</td></tr><tr><td align="left">“a+</td><td align="left">Open a text file for update (reading and writing), appending to the end of an existing file, or creating the file if it does not yet exist; the whole file can be read, but writing can only be appended.</td></tr><tr><td align="left">“rb”, “wb”, “ab”, “ab+”, “a+b”, “wb+”, “w+b”, “ab+”, “a+b”</td><td align="left">Like the preceding modes, except they use binary mode instead of text mode.</td></tr><tr><td align="left">“wx”, “wbx”, “w+x”, “wb+x” or “w+bx”</td><td align="left">(C11) Like the non-x modes, except they fail if the file already exists and they open a file in exclusive mode, if possible.</td></tr></tbody></table><p>After your program successfully opens a file, <strong>fopen()</strong> returns a <strong>file pointer</strong>, which the other I/O functions can then use to specify the file. The file pointer is of type <strong>pointer-to-FILE</strong>. The pointer points to a <strong>data object</strong> containing information about the file, including information about the buffer used for the file’s I/O. </p><p>The <strong>fopen()</strong> function returns the <strong>null pointer</strong> (also defined in stdio.h) if it cannot open the file. </p><h2 id="2-The-getc-and-putc-Functions"><a href="#2-The-getc-and-putc-Functions" class="headerlink" title="(2) The getc() and putc() Functions"></a>(2) The getc() and putc() Functions</h2><p>The two functions <strong>getc()</strong> and <strong>putc()</strong> work very much like <strong>getchar()</strong> and <strong>putchar()</strong>. The difference is that you must tell these newcomers <strong>which file to use</strong>. </p><pre><code class="hljs c">ch = getchar();<span class="hljs-comment">//get a character from the file identified by fp</span>ch = getc(fp);</code></pre><pre><code class="hljs c"><span class="hljs-comment">//put the character ch into the file identified by the FILE pointer fpout</span>putc(ch, fpout);</code></pre><p><code>putc(ch,stdout)</code> is the same as <code>putchar(ch)</code>. </p><h2 id="3-End-of-File"><a href="#3-End-of-File" class="headerlink" title="(3) End-of-File"></a>(3) End-of-File</h2><p>The <strong>getc()</strong> function returns the special value <strong>EOF</strong> if it tries to read a character and discovers it has reached the end of the file. So a C program discovers it has reached the end of a file only after it tries to read past the end of the file. </p><h2 id="4-The-fclose-Function"><a href="#4-The-fclose-Function" class="headerlink" title="(4) The fclose() Function"></a>(4) The fclose() Function</h2><p>The <strong>fclose(fp)</strong> function closes the file identified by <code>fp</code>, flushing buffers as needed. </p><p>The function <strong>fclose()</strong> returns a value of <strong>0</strong> if successful, and <strong>EOF</strong> if not:</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fclose(fp) != <span class="hljs-number">0</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error in closing file %s\n"</span>, argv[<span class="hljs-number">1</span>]);</code></pre><p>The <strong>fclose()</strong> function can fail if, for example, the disk is full, a removable storage device has been removed, or there has been an I/O error.</p><h2 id="5-Pointers-to-the-Standard-Files"><a href="#5-Pointers-to-the-Standard-Files" class="headerlink" title="(5) Pointers to the Standard Files"></a>(5) Pointers to the Standard Files</h2><p>The <strong>stdio.h</strong> file associates three file pointers with the three standard files automatically opened by C programs:</p><table><thead><tr><th align="left">Standard File</th><th align="left">File Pointer</th><th align="left">Normally</th></tr></thead><tbody><tr><td align="left">Standard input</td><td align="left">stdin</td><td align="left">Your keyboard</td></tr><tr><td align="left">Standard output</td><td align="left">stdout</td><td align="left"></td></tr><tr><td align="left">Standard error</td><td align="left">stderr</td><td align="left">Your screen</td></tr></tbody></table><p>These pointers are all type <strong>pointer-to-FILE</strong>, so they can be used as arguments to the <strong>standard I/O functions</strong>.</p><h1 id="3-File-I-O-fprintf-fscanf-fgets-and-fputs"><a href="#3-File-I-O-fprintf-fscanf-fgets-and-fputs" class="headerlink" title="3. File I/O: fprintf(), fscanf(), fgets(), and fputs()"></a>3. File I/O: fprintf(), fscanf(), fgets(), and fputs()</h1><h2 id="1-The-fprintf-and-fscanf-Functions"><a href="#1-The-fprintf-and-fscanf-Functions" class="headerlink" title="(1) The fprintf() and fscanf() Functions"></a>(1) The fprintf() and fscanf() Functions</h2><p>The file I/O functions <strong>fprintf()</strong> and <strong>fscanf()</strong> work just like <strong>printf()</strong> and <strong>scanf()</strong>, except that they require an additional first argument to identify the proper <strong>file</strong>.</p><pre><code class="hljs c"><span class="hljs-comment">/* addaword.c -- uses fprintf(), fscanf(), and rewind() */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 41</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    FILE *fp;    <span class="hljs-keyword">char</span> words[MAX];    <span class="hljs-keyword">if</span> ((fp = fopen(<span class="hljs-string">"wordy"</span>, <span class="hljs-string">"a+"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>,<span class="hljs-string">"Can't open \"wordy\" file.\n"</span>);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter words to add to the file; press the #"</span>);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"key at the beginning of a line to terminate."</span>);    <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">fscanf</span>(<span class="hljs-built_in">stdin</span>,<span class="hljs-string">"%40s"</span>, words) == <span class="hljs-number">1</span>) &amp;&amp; (words[<span class="hljs-number">0</span>] != <span class="hljs-string">'#'</span>))        <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">"%s\n"</span>, words);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"File contents:"</span>);    rewind(fp); <span class="hljs-comment">/* go back to beginning of file */</span>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">"%s"</span>,words) == <span class="hljs-number">1</span>)        <span class="hljs-built_in">puts</span>(words);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Done!"</span>);    <span class="hljs-keyword">if</span> (fclose(fp) != <span class="hljs-number">0</span>)        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Error closing file\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre><p>The <strong>rewind()</strong> command takes the program to the <strong>file beginning</strong> so that the final while loop can print the file contents.</p><h2 id="2-The-fgets-and-fputs-Functions"><a href="#2-The-fgets-and-fputs-Functions" class="headerlink" title="(2) The fgets() and fputs() Functions"></a>(2) The fgets() and fputs() Functions</h2><pre><code class="hljs c">fgets(buf, STLEN, fp);</code></pre><p><strong>The first argument</strong> of <strong>fgets()</strong>, as with the banished <strong>gets()</strong>, is the address (type <strong>char *</strong>) where input should be stored. </p><p><strong>The second argument</strong> is an integer representing the <strong>maximum size of the input string</strong>. </p><p><strong>The final argument</strong> is the <strong>file pointer</strong> identifying the file to be read. </p><p>The <strong>fgets()</strong> function reads input through the <strong>first newline character</strong>, until one fewer than the upper limit of characters is read, or until the end-of-file is found; <strong>fgets()</strong> then adds a <strong>terminating null character</strong> to form a string. </p><p>Therefore, the <strong>upper limit</strong> represents the <strong>maximum number of characters</strong> plus the <strong>null character</strong>. </p><p>If <strong>fgets()</strong> reads in a whole line before running into the character limit, it places the <strong>newline character</strong>, marking the end of the line into the string, just before the <strong>null character</strong>. </p><p>The <strong>fgets()</strong> function returns the value <strong>NULL</strong> when it encounters <strong>EOF</strong>. You can use this to check for the end of a file. Otherwise, it returns the address passed to it.</p><pre><code class="hljs c"><span class="hljs-built_in">fputs</span>(buf, fp);</code></pre><p>The <strong>fputs()</strong> function takes two arguments: first, an <strong>address of a string</strong> and then a <strong>file pointer</strong>.</p><p>It writes the string found at the pointed-to location into the indicated file. <strong>Unlike puts()</strong>, <strong>fputs()</strong> does not append a <strong>newline</strong> when it prints. </p><h1 id="4-fseek-and-ftell"><a href="#4-fseek-and-ftell" class="headerlink" title="4. fseek() and ftell()"></a>4. fseek() and ftell()</h1><p>The <strong>fseek()</strong> function enables you to treat a <strong>file</strong> like an <strong>array</strong> and move directly to any particular byte in a <strong>file</strong> opened by <strong>fopen()</strong>. </p><pre><code class="hljs c"><span class="hljs-comment">/* reverse.c -- displays a file in reverse order */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CNTL_Z <span class="hljs-meta-string">'\032'</span> <span class="hljs-comment">/* eof marker in DOS text files */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLEN 81</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> file[SLEN];    <span class="hljs-keyword">char</span> ch;    FILE *fp;    <span class="hljs-keyword">long</span> count, last;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter the name of the file to be processed:"</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%80s"</span>, file);    <span class="hljs-keyword">if</span> ((fp = fopen(file,<span class="hljs-string">"rb"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;   <span class="hljs-comment">/* read-only mode */</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"reverse can't open %s\n"</span>, file);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    fseek(fp, <span class="hljs-number">0L</span>, SEEK_END); <span class="hljs-comment">/* go to end of file */</span>    last = ftell(fp);    <span class="hljs-keyword">for</span> (count = <span class="hljs-number">1L</span>; count &lt;= last; count++)    &#123;        fseek(fp, -count, SEEK_END); <span class="hljs-comment">/* go backward */</span>        ch = getc(fp);        <span class="hljs-keyword">if</span> (ch != CNTL_Z &amp;&amp; ch != <span class="hljs-string">'\r'</span>) <span class="hljs-comment">/* MS-DOS files */</span>            <span class="hljs-built_in">putchar</span>(ch);    &#125;    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);    fclose(fp);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>The <strong>first of the three arguments</strong> to <strong>fseek()</strong> is a <strong>FILE pointer</strong> to the file being searched. The file should have been opened by using <strong>fopen()</strong>.</p><p>The <strong>second argument</strong> to <strong>fseek()</strong> is called the <strong>offset</strong>. This argument tells how far to move from the <strong>starting point</strong> (see the following list of mode starting points). The argument must be a <strong>long value</strong>. It can be <strong>positive</strong> (move forward), <strong>negative</strong> (move backward), or <strong>zero</strong> (stay put).</p><p><strong>The third argument</strong> is the <strong>mode</strong>, and it identifies the <strong>starting point</strong>. Since the <strong>ANSI standard</strong>, the <strong>stdio.h</strong> header file specifies the following manifest constants for the mode:</p><table><thead><tr><th align="left">Mode</th><th align="left">Measures Offset From</th></tr></thead><tbody><tr><td align="left">SEEK_SET</td><td align="left">Beginning of file</td></tr><tr><td align="left">SEEK_CUR</td><td align="left">Current position</td></tr><tr><td align="left">SEEK_END</td><td align="left">End of file</td></tr></tbody></table><p>Older implementations may lack these definitions and, instead, use the numeric values <code>0L</code>, <code>1L</code>, and <code>2L</code>, respectively, for these <strong>modes</strong>. The <code>L</code> suffix identifies type <strong>long values</strong>. </p><pre><code class="hljs c">fseek(fp, <span class="hljs-number">0L</span>, SEEK_SET); <span class="hljs-comment">// go to the beginning of the file</span>fseek(fp, <span class="hljs-number">10L</span>, SEEK_SET); <span class="hljs-comment">// go 10 bytes into the file</span>fseek(fp, <span class="hljs-number">2L</span>, SEEK_CUR); <span class="hljs-comment">// advance 2 bytes from the current position</span>fseek(fp, <span class="hljs-number">0L</span>, SEEK_END); <span class="hljs-comment">// go to the end of the file</span>fseek(fp, <span class="hljs-number">-10L</span>, SEEK_END); <span class="hljs-comment">// back up 10 bytes from the end of the file</span></code></pre><p>The value <strong>returned</strong> by <strong>fseek()</strong> is <strong>0</strong> if everything is okay, and <strong>-1</strong> if there is an error, such as attempting to move <strong>past the bounds</strong> of the <strong>file</strong>.</p><p>The <strong>ftell()</strong> function is type <strong>long</strong>, and it <strong>returns</strong> the <strong>current file location</strong>. Under <strong>ANSI C</strong>, it is declared in <strong>stdio.h</strong>. </p><p>As originally implemented in Unix, <strong>ftell()</strong> specifies the <strong>file position</strong> by returning the number of bytes from the <strong>beginning</strong>, with the <strong>first byte</strong> being byte <strong>0</strong>, and so on.</p><p>Under <strong>ANSI C</strong>, this definition applies to files opened in the <strong>binary mode</strong>, but not necessarily to files opened in the <strong>text mode</strong>. </p><p>The <strong>ftell()</strong> function may work <strong>differently</strong> in the <strong>text mode</strong> than in the <strong>binary mode</strong>. </p><h1 id="5-The-fgetpos-and-fsetpos-Functions"><a href="#5-The-fgetpos-and-fsetpos-Functions" class="headerlink" title="5. The fgetpos() and fsetpos() Functions"></a>5. The fgetpos() and fsetpos() Functions</h1><p>One potential problem with <strong>fseek()</strong> and ftell()<strong>** is that they **limit file sizes</strong> to values that can be represented by type <strong>long</strong>. </p><p><strong>ANSI C</strong> introduced two <strong>new positioning functions</strong> designed to work with <strong>larger file sizes</strong>. Instead of using a <strong>long</strong> value to represent a position, it uses a new type, called <strong>fpos_t</strong> (for file position type) for that purpose.</p><p>The <strong>fpos_t</strong> type is not a fundamental type; rather, it is defined in terms of other types. A variable or data object of <strong>fpos_t</strong> type can <strong>specify a location</strong> within a file, and it <strong>cannot be an array type</strong>, but its nature is not specified beyond that. </p><p><strong>ANSI C</strong> does define how <strong>fpos_t</strong> is used. The <strong>fgetpos()</strong> function has this prototype:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fgetpos</span><span class="hljs-params">(FILE * <span class="hljs-keyword">restrict</span> stream, <span class="hljs-keyword">fpos_t</span> * <span class="hljs-keyword">restrict</span> pos)</span></span>;</code></pre><p>When called, it places an <strong>fpos_t</strong> value in the location pointed to by <code>pos</code>; the value describes a location in the file. The function <strong>returns zero</strong> if successful and a <strong>nonzero</strong> value for failure.</p><p>The <strong>fsetpos()</strong> function has this prototype: </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fsetpos</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">fpos_t</span> *pos)</span></span>;</code></pre><p>When called, it uses the <strong>fpos_t</strong> value in the location pointed to by <code>pos</code> to set the file pointer to the location indicated by that value. The function <strong>returns zero</strong> if successful and a <strong>nonzero</strong> value for failure. The <strong>fpos_t</strong> value should have been obtained by a previous call to <strong>fgetpos()</strong>.</p><h1 id="6-Other-Standard-I-O-Functions"><a href="#6-Other-Standard-I-O-Functions" class="headerlink" title="6. Other Standard I/O Functions"></a>6. Other Standard I/O Functions</h1><h2 id="1-The-int-ungetc-int-c-FILE-fp-Function"><a href="#1-The-int-ungetc-int-c-FILE-fp-Function" class="headerlink" title="(1) The int ungetc(int c, FILE *fp) Function"></a>(1) The int ungetc(int c, FILE *fp) Function</h2><p>The <strong>int ungetc()</strong> function pushes the character specified by <code>c</code> back onto the input stream.</p><p>If you push a character onto the input stream, the next call to a standard input function reads that character.</p><p>The <strong>ANSI C</strong> standard guarantees <strong>only one pushback</strong> at a time. If an implementation permits you to push back <strong>several characters in a row</strong>, the input functions read them in the <strong>reversed order of pushing</strong>.</p><p><img src="_v_images/20201206172345396_1469727691.png" srcset="/img/loading.gif" alt="The ungetc() Function"></p><h2 id="2-The-int-fflush-Function"><a href="#2-The-int-fflush-Function" class="headerlink" title="(2) The int fflush() Function"></a>(2) The int fflush() Function</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fflush</span><span class="hljs-params">(FILE *fp)</span></span>;</code></pre><p>Calling the <strong>fflush()</strong> function causes any <strong>unwritten data in the output buffer</strong> to be sent to the <strong>output file</strong> identified by <code>fp</code>. This process is called <strong>flushing a buffer</strong>. </p><p>If <code>fp</code> is the <strong>null pointer</strong>, all output buffers are flushed. </p><p>The effect of using <strong>fflush()</strong> on an <strong>input stream</strong> is <strong>undefined</strong>. </p><h2 id="3-The-int-setvbuf-Function"><a href="#3-The-int-setvbuf-Function" class="headerlink" title="(3) The int setvbuf() Function"></a>(3) The int setvbuf() Function</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setvbuf</span><span class="hljs-params">(FILE * <span class="hljs-keyword">restrict</span> fp, <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> buf, <span class="hljs-keyword">int</span> mode, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span></span>;</code></pre><p>The <strong>setvbuf()</strong> function sets up an <strong>alternative buffer</strong> to be used by the standard I/O functions. It is called <strong>after the file has been opened</strong> and <strong>before any other operations have been performed</strong> on the stream. </p><p>The pointer <code>fp</code> identifies the stream, and <code>buf</code> points to the storage to be used. If the value of <code>buf</code> is <strong>not NULL</strong>, you must create the <strong>buffer</strong>. </p><p>For instance, you could declare an array of 1,024 chars and pass the address of that array. However, if you use <strong>NULL</strong> for the value of <code>buf</code>, the function allocates a <strong>buffer</strong> itself. The size variable tells <strong>setvbuf()</strong> how big the array is.</p><p>The <strong>mode</strong> is selected from the following choices: <strong>_IOFBF</strong> means <strong>fully buffered</strong> (buffer flushed when full), <strong>_IOLBF</strong> means <strong>line-buffered</strong> (buffer flushed when full or when a <strong>newline</strong> is written), and <strong>_IONBF</strong> means <strong>nonbuffered</strong>. </p><p>The function returns <strong>zero</strong> if successful, <strong>nonzero</strong> otherwise.</p><p>Suppose you have a program that works with stored data objects having, say, a size of 3,000 bytes each. You could use <strong>setvbuf()</strong> to create a <strong>buffer</strong> whose size is a multiple of the data object’s size. </p><h2 id="4-Binary-I-O-fread-and-fwrite"><a href="#4-Binary-I-O-fread-and-fwrite" class="headerlink" title="(4) Binary I/O: fread() and fwrite()"></a>(4) Binary I/O: fread() and fwrite()</h2><p>In general, <strong>fprintf()</strong> converts <strong>numeric values</strong> to <strong>character data</strong>, possibly <strong>altering the value</strong>.</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> num = <span class="hljs-number">1.</span>/<span class="hljs-number">3.</span>;<span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">"%f"</span>, num);</code></pre><p>saves <code>num</code> as a sequence of eight characters: <code>0.333333</code>. Using a <code>%.2f</code> specifier saves it as four characters: <code>0.33</code>.</p><p>Changing the specifier alters the amount of space needed to store the value; it can also result in different values being stored. After the value of <code>num</code> is stored as <code>0.33</code>, there is <strong>no way to get back the full precision</strong> when the file is read. </p><p>The <strong>most accurate and consistent</strong> way to store a number is to use the <strong>same pattern of bits</strong> that the computer does. Therefore, a <strong>double</strong> value should be stored in a size <strong>double unit</strong>. </p><p>When data is stored in a file using the same representation that the program uses, we say that the data is stored in <strong>binary form</strong>. There is <strong>no conversion from</strong> numeric forms to character sequences. </p><p>For <strong>standard I/O</strong>, the <strong>fread()</strong> and <strong>fwrite()</strong> functions provide this <strong>binary service</strong>.</p><p><img src="_v_images/20201206174743443_124649534.png" srcset="/img/loading.gif" alt="Binary and text output"></p><h3 id="The-size-t-fwrite-Function"><a href="#The-size-t-fwrite-Function" class="headerlink" title="The size_t fwrite() Function"></a>The size_t fwrite() Function</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">restrict</span> ptr, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">size_t</span> nmemb, FILE * <span class="hljs-keyword">restrict</span> fp)</span></span>;</code></pre><p>The <strong>fwrite()</strong> function <strong>writes binary data</strong> to a file. </p><p>The <strong>size_t</strong> type is defined in terms of the standard C types. It is the type returned by the <strong>sizeof</strong> operator. Typically, it is <strong>unsigned int</strong>, but an implementation can choose another type. </p><p>The pointer <code>ptr</code> is the address of the chunk of data to be written. </p><p>Also, <code>size</code> represents the size, in <strong>bytes</strong>, of the chunks to be written, and<br><code>nmemb</code> represents the number of chunks to be written. As usual, <code>fp</code> identifies the file to be written to. </p><p>For instance, to save a data object (such as an array) that is 256 bytes in size, you<br>can do this:</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> <span class="hljs-built_in">buffer</span>[<span class="hljs-number">256</span>];fwrite(<span class="hljs-built_in">buffer</span>, <span class="hljs-number">256</span>, <span class="hljs-number">1</span>, fp);</code></pre><p>This call writes one chunk of 256 bytes from buffer to the file. </p><p>Or, to save an array of 10 double values, you can do this:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> earnings[<span class="hljs-number">10</span>];fwrite(earnings, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>), <span class="hljs-number">10</span>, fp);</code></pre><p>This call writes data from the <code>earnings</code> array to the file in 10 chunks, each of size double.</p><p>One problem with <strong>fwrite()</strong> is that its <strong>first argument</strong> is <strong>not a fixed type</strong>. Under ANSI C function prototyping, these actual arguments are converted to the <strong>pointer-to-void</strong> type, which acts as a sort of catchall type for pointers. </p><p>The <strong>fwrite()</strong> function <strong>returns</strong> the <strong>number of items</strong> successfully written. Normally, this equals <code>nmemb</code>, but it can be less if there is a write error.</p><h3 id="The-size-t-fread-Function"><a href="#The-size-t-fread-Function" class="headerlink" title="The size_t fread() Function"></a>The size_t fread() Function</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * <span class="hljs-keyword">restrict</span> ptr, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">size_t</span> nmemb, FILE * <span class="hljs-keyword">restrict</span> fp)</span></span>;</code></pre><p>The <strong>fread()</strong> function takes the same set of arguments that <strong>fwrite()</strong> does. </p><p>This time <code>ptr</code> is the address of the memory storage into which file data is read, and <code>fp</code> identifies the file to be read. </p><p>For example, to recover the array of 10 doubles saved in the previous example, use this call:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> earnings[<span class="hljs-number">10</span>];fread(earnings, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>), <span class="hljs-number">10</span>, fp);</code></pre><p>This call copies 10 size <strong>double</strong> values into the <code>earnings</code> array.</p><p>The <strong>fread()</strong> function returns the <strong>number of items</strong> successfully read. Normally, this equals <code>nmemb</code>, but it can be less if there is a read error or if the <strong>end-of-file</strong> is reached.</p><h2 id="5-The-int-feof-FILE-fp-and-int-ferror-FILE-fp-Functions"><a href="#5-The-int-feof-FILE-fp-and-int-ferror-FILE-fp-Functions" class="headerlink" title="(5) The int feof(FILE *fp) and int ferror(FILE *fp) Functions"></a>(5) The int feof(FILE *fp) and int ferror(FILE *fp) Functions</h2><p>When the standard input functions return <strong>EOF</strong>, this usually means they have reached the <strong>end of a file</strong>. However, it can also indicate that a <strong>read error</strong> has occurred. </p><p>The <strong>feof()</strong> and <strong>ferror()</strong> functions enable you to <strong>distinguish between the two possibilities</strong>. </p><p>The <strong>feof()</strong> function returns a <strong>nonzero</strong> value if the last input call detected the <strong>end-of-file</strong>, and it returns <strong>zero</strong> otherwise. </p><p>The <strong>ferror()</strong> function returns a <strong>nonzero</strong> value if a read or write <strong>error</strong> has occurred, and it returns <strong>zero</strong> otherwise.</p><h2 id="6-An-fread-and-fwrite-Example"><a href="#6-An-fread-and-fwrite-Example" class="headerlink" title="(6) An fread() and fwrite() Example"></a>(6) An fread() and fwrite() Example</h2><pre><code class="hljs c"><span class="hljs-comment">/* append.c -- appends files to a file */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFSIZE 4096</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLEN 81</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(FILE *source, FILE *dest)</span></span>;<span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * st, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    FILE *fa, *fs; <span class="hljs-comment">// fa for append file, fs for source file</span>    <span class="hljs-keyword">int</span> files = <span class="hljs-number">0</span>; <span class="hljs-comment">// number of files appended</span>    <span class="hljs-keyword">char</span> file_app[SLEN]; <span class="hljs-comment">// name of append file</span>    <span class="hljs-keyword">char</span> file_src[SLEN]; <span class="hljs-comment">// name of source file</span>    <span class="hljs-keyword">int</span> ch;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter name of destination file:"</span>);    s_gets(file_app, SLEN);    <span class="hljs-keyword">if</span> ((fa = fopen(file_app, <span class="hljs-string">"a+"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Can't open %s\n"</span>, file_app);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-keyword">if</span> (setvbuf(fa, <span class="hljs-literal">NULL</span>, _IOFBF, BUFSIZE) != <span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">"Can't create output buffer\n"</span>, <span class="hljs-built_in">stderr</span>);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter name of first source file (empty line to quit):"</span>);    <span class="hljs-keyword">while</span> (s_gets(file_src, SLEN) &amp;&amp; file_src[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span>)    &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(file_src, file_app) == <span class="hljs-number">0</span>)            <span class="hljs-built_in">fputs</span>(<span class="hljs-string">"Can't append file to itself\n"</span>,<span class="hljs-built_in">stderr</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fs = fopen(file_src, <span class="hljs-string">"r"</span>)) == <span class="hljs-literal">NULL</span>)            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Can't open %s\n"</span>, file_src);        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span> (setvbuf(fs, <span class="hljs-literal">NULL</span>, _IOFBF, BUFSIZE) != <span class="hljs-number">0</span>)            &#123;                <span class="hljs-built_in">fputs</span>(<span class="hljs-string">"Can't create input buffer\n"</span>,<span class="hljs-built_in">stderr</span>);                <span class="hljs-keyword">continue</span>;            &#125;            append(fs, fa);            <span class="hljs-keyword">if</span> (ferror(fs) != <span class="hljs-number">0</span>)            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Error in reading file %s.\n"</span>,            file_src);            <span class="hljs-keyword">if</span> (ferror(fa) != <span class="hljs-number">0</span>)            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Error in writing file %s.\n"</span>,            file_app);            fclose(fs);            files++;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"File %s appended.\n"</span>, file_src);            <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Next file (empty line to quit):"</span>);        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Done appending. %d files appended.\n"</span>, files);    rewind(fa);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s contents:\n"</span>, file_app);    <span class="hljs-keyword">while</span> ((ch = getc(fa)) != EOF)        <span class="hljs-built_in">putchar</span>(ch);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Done displaying."</span>);    fclose(fa);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(FILE *source, FILE *dest)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">size_t</span> bytes;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> temp[BUFSIZE]; <span class="hljs-comment">// allocate once</span>    <span class="hljs-keyword">while</span> ((bytes = fread(temp,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>),BUFSIZE,source)) &gt; <span class="hljs-number">0</span>)        fwrite(temp, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), bytes, dest);&#125;<span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * st, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> * ret_val;    <span class="hljs-keyword">char</span> * <span class="hljs-built_in">find</span>;    ret_val = fgets(st, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span> (ret_val)    &#123;        <span class="hljs-built_in">find</span> = <span class="hljs-built_in">strchr</span>(st, <span class="hljs-string">'\n'</span>); <span class="hljs-comment">// look for newline</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>) <span class="hljs-comment">// if the address is not NULL,</span>            *<span class="hljs-built_in">find</span> = <span class="hljs-string">'\0'</span>; <span class="hljs-comment">// place a null character there</span>        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">'\n'</span>)                <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret_val;&#125;</code></pre><h2 id="7-Random-Access-with-Binary-I-O"><a href="#7-Random-Access-with-Binary-I-O" class="headerlink" title="(7) Random Access with Binary I/O"></a>(7) Random Access with Binary I/O</h2><pre><code class="hljs c"><span class="hljs-comment">/* randbin.c -- random access, binary i/o */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARSIZE 1000</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> numbers[ARSIZE];    <span class="hljs-keyword">double</span> value;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file = <span class="hljs-string">"numbers.dat"</span>;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">long</span> pos;    FILE *iofile;    <span class="hljs-comment">// create a set of double values</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; ARSIZE; i++)        numbers[i] = <span class="hljs-number">100.0</span> * i + <span class="hljs-number">1.0</span> / (i + <span class="hljs-number">1</span>);    <span class="hljs-comment">// attempt to open file</span>    <span class="hljs-keyword">if</span> ((iofile = fopen(file, <span class="hljs-string">"wb"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not open %s for output.\n"</span>, file);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-comment">// write array in binary format to file</span>    fwrite(numbers, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>), ARSIZE, iofile);    fclose(iofile);    <span class="hljs-keyword">if</span> ((iofile = fopen(file, <span class="hljs-string">"rb"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,        <span class="hljs-string">"Could not open %s for random access.\n"</span>, file);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-comment">// read selected items from file</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter an index in the range 0-%d.\n"</span>, ARSIZE<span class="hljs-number">-1</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;i) == <span class="hljs-number">1</span> &amp;&amp; i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; ARSIZE)    &#123;        pos = (<span class="hljs-keyword">long</span>)i * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>);<span class="hljs-comment">// calculate offset</span>        fseek(iofile, pos, SEEK_SET); <span class="hljs-comment">// go there</span>        fread(&amp;value, <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">double</span>), <span class="hljs-number">1</span>, iofile);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The value there is %f.\n"</span>, value);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Next index (out of range to quit):\n"</span>);    &#125;    <span class="hljs-comment">// finish up</span>    fclose(iofile);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Character Strings and String Functions</title>
    <link href="/2020/12/01/Character-Strings-and-String-Functions/"/>
    <url>/2020/12/01/Character-Strings-and-String-Functions/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 11 Character Strings and String Functions</p><a id="more"></a><h1 id="1-Representing-Strings-and-String-I-O"><a href="#1-Representing-Strings-and-String-I-O" class="headerlink" title="1. Representing Strings and String I/O"></a>1. Representing Strings and String I/O</h1><p>The <strong>puts()</strong> function, like <strong>printf()</strong>, belongs to the the <strong>stdio.h</strong> family of <strong>input/output</strong> functions. It only displays <strong>strings</strong>, and, unlike <strong>printf()</strong>, it automatically <strong>appends a newline</strong> to the string it displays. </p><p>There are many ways to define a string. The principal ways are using string constants, using char arrays, and using char pointers. </p><p>A program should make sure there is a place to store a string.</p><h2 id="1-Character-String-Literals-String-Constants"><a href="#1-Character-String-Literals-String-Constants" class="headerlink" title="(1) Character String Literals (String Constants)"></a>(1) Character String Literals (String Constants)</h2><p>A <strong>string literal</strong>, also termed a <strong>string constant</strong>, is anything enclosed in <strong>double quotation marks</strong>. The enclosed characters, plus a terminating <code>\0</code> character automatically provided by the compiler, are stored in memory as a character string. </p><p><strong>Character string constants</strong> are placed in the <strong>static storage class</strong>, which means that if you use a <strong>string constant</strong> in a function, the string is <strong>stored just once</strong> and <strong>lasts for the duration of the program</strong>, even if the function is called several times. </p><h2 id="2-Character-String-Arrays-and-Initialization"><a href="#2-Character-String-Arrays-and-Initialization" class="headerlink" title="(2) Character String Arrays and Initialization"></a>(2) Character String Arrays and Initialization</h2><p>When you define a <strong>character string array</strong>, you must let the compiler know <strong>how much space</strong> is needed. </p><h1 id="2-Array-Versus-Pointer"><a href="#2-Array-Versus-Pointer" class="headerlink" title="2. Array Versus Pointer"></a>2. Array Versus Pointer</h1><p>In short, initializing the <strong>array</strong> copies a <strong>string</strong> from <strong>static storage</strong> to the <strong>array</strong>, whereas initializing the <strong>pointer</strong> merely copies the <strong>address</strong> of the <strong>string</strong>.</p><h2 id="1-Array-and-Pointer-Differences"><a href="#1-Array-and-Pointer-Differences" class="headerlink" title="(1) Array and Pointer Differences"></a>(1) Array and Pointer Differences</h2><p>The chief <strong>difference</strong> is that the <strong>array name</strong> is a <strong>constant</strong>, but the <strong>pointer</strong> is a variable. </p><p>In short, don’t use a <strong>pointer to a string literal</strong> if you plan to alter the string.</p><h2 id="2-Arrays-of-Character-Strings"><a href="#2-Arrays-of-Character-Strings" class="headerlink" title="(2) Arrays of Character Strings"></a>(2) Arrays of Character Strings</h2><p><img src="https://img-blog.csdnimg.cn/20190615215441173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="3-String-Input"><a href="#3-String-Input" class="headerlink" title="3. String Input"></a>3. String Input</h1><p>If you want to read a <strong>string</strong> into a program, you must first <strong>set aside space</strong> to store the <strong>string</strong> and then use an <strong>input function</strong> to fetch the string.</p><h2 id="1-Creating-Space"><a href="#1-Creating-Space" class="headerlink" title="(1) Creating Space"></a>(1) Creating Space</h2><p>The first order of business is setting up a place to put the string after it is read. </p><h2 id="2-The-Unfortunate-gets-Function"><a href="#2-The-Unfortunate-gets-Function" class="headerlink" title="(2) The Unfortunate gets() Function"></a>(2) The Unfortunate gets() Function</h2><p> It reads an entire <strong>line up</strong> through the <strong>newline character</strong>, <strong>discards</strong> the <strong>newline character</strong>, stores the remaining characters, <strong>adding a null character</strong> to create a C <strong>string</strong>. </p><p>It’s often paired with <strong>puts()</strong>, which displays a <strong>string</strong>, <strong>adding a newline</strong>. </p><p>The problem is that <strong>gets()</strong> doesn’t check to see if the input line actually fits into the array. </p><h2 id="3-The-fgets-Function"><a href="#3-The-fgets-Function" class="headerlink" title="(3) The fgets() Function"></a>(3) The fgets() Function</h2><p>The <strong>fgets()</strong> function meets the possible <strong>overflow</strong> problem by taking a second argument that <strong>limits the number of characters</strong> to be read. </p><p>This function is designed for <strong>file input</strong>, which makes it a little more awkward to use. Here is how <strong>fgets()</strong> differs from <strong>gets()</strong>:</p><ul><li><p>It takes a <strong>second argument</strong> indicating the <strong>maximum number of characters to read</strong>. If this argument has the value <strong>n</strong>, <strong>fgets()</strong> reads up to <strong>n-1</strong> characters or through the <strong>newline character</strong>, whichever comes first.</p></li><li><p>If <strong>fgets()</strong> reads the <strong>newline</strong>, it <strong>stores it in the string</strong>, unlike <strong>gets()</strong>, which discards it.</p></li><li><p>It takes a <strong>third argument</strong> indicating <strong>which file to read</strong>. To read from the <strong>keyboard</strong>, use <strong>stdin</strong> (for standard input) as the argument; this identifier is defined in <code>stdio.h</code>.</p><h3 id="Null-and-NULL"><a href="#Null-and-NULL" class="headerlink" title="Null and NULL"></a>Null and NULL</h3><p>The <strong>null character</strong>, or <strong>‘\0’</strong>, is the character used to mark the end of a <strong>C string</strong>. It’s the character whose code is <strong>zero</strong>. Because that isn’t the code of any character, it won’t show up accidentally in some other part of the string.</p></li></ul><p>The <strong>null pointer</strong>, or <strong>NULL</strong>, <strong>has a value</strong> that doesn’t correspond to a <strong>valid address</strong> of data. It’s often used by functions that otherwise return valid addresses to indicate some special occurrence, such as encountering <strong>end-of-file</strong> or failing to perform as expected.</p><p>So the <strong>null character</strong> is an <strong>integer type</strong>, while the <strong>null pointer</strong> is a <strong>pointer type</strong>. </p><h2 id="4-The-s-gets-Function"><a href="#4-The-s-gets-Function" class="headerlink" title="(4) The s _ gets() Function"></a>(4) The s _ gets() Function</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* st, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> * ret_val;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    ret_val = fgets(st, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span> (ret_val) <span class="hljs-comment">// i.e., ret_val != NULL</span>    &#123;        <span class="hljs-keyword">while</span> (st[i] != <span class="hljs-string">'\n'</span> &amp;&amp; st[i] != <span class="hljs-string">'\0'</span>)            i++;        <span class="hljs-keyword">if</span> (st[i] == <span class="hljs-string">'\n'</span>)            st[i] = <span class="hljs-string">'\0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">// must have words[i] == '\0'</span>            <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">'\n'</span>)                <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret_val;&#125;</code></pre><h1 id="4-String-Output"><a href="#4-String-Output" class="headerlink" title="4. String Output"></a>4. String Output</h1><h2 id="1-The-puts-Function"><a href="#1-The-puts-Function" class="headerlink" title="(1) The puts() Function"></a>(1) The puts() Function</h2><p>The <strong>puts()</strong> function is very easy to use. Just give it the <strong>address of a string</strong> for an argument.</p><p><strong>puts()</strong> automatically <strong>appends a newline</strong> when it displays a string.</p><h2 id="2-The-fputs-Function"><a href="#2-The-fputs-Function" class="headerlink" title="(2) The fputs() Function"></a>(2) The fputs() Function</h2><p>The <strong>fputs()</strong> function is the <strong>file-oriented</strong> version of <strong>puts()</strong>. The main differences are these:</p><ul><li><p>The <strong>fputs()</strong> function takes a <strong>second argument</strong> indicating the <strong>file</strong> to which to <strong>write</strong>. You can use <strong>stdout</strong> (for standard output), which is defined in <code>stdio.h</code>, as an argument to output to your display.</p></li><li><p>Unlike <strong>puts()</strong>, <strong>fputs()</strong> does not automatically append a <strong>newline</strong> to the output.</p></li></ul><p>Note that <strong>gets()</strong> discards a <strong>newline</strong> on input, but <strong>puts()</strong> adds a <strong>newline</strong> on output. On the other hand, <strong>fgets()</strong> stores the <strong>newline</strong> on input, and <strong>fputs()</strong> doesn’t add a <strong>newline</strong> on output. </p><p><strong>gets()</strong> returns the <strong>null pointer</strong> if it encounters <strong>end-of-file</strong>. The <strong>null pointer *<em>evaluates as *</em>zero</strong>, or <strong>false</strong>, so that terminates the loop.</p><h1 id="5-String-Functions"><a href="#5-String-Functions" class="headerlink" title="5. String Functions"></a>5. String Functions</h1><h2 id="1-The-strlen-Function"><a href="#1-The-strlen-Function" class="headerlink" title="(1) The strlen() Function"></a>(1) The strlen() Function</h2><p>The <strong>strlen()</strong> function, finds the <strong>length</strong> of a string. </p><h2 id="2-The-strcat-Function"><a href="#2-The-strcat-Function" class="headerlink" title="(2) The strcat() Function"></a>(2) The strcat() Function</h2><p>The <strong>strcat()</strong> (for string concatenation) function takes <strong>two strings for arguments</strong>. A copy of the second string is tacked onto the end of the first, and this combined version becomes the new first string. </p><p>The second string is <strong>not altered</strong>. The <strong>strcat()</strong> function is type <code>char *</code> (that is, a pointer-to-char).</p><p>It <strong>returns</strong> the value of its <strong>first argument</strong>—the <strong>address</strong> of the first character of the string to which the second string is appended.</p><h2 id="3-The-strncat-Function"><a href="#3-The-strncat-Function" class="headerlink" title="(3) The strncat() Function"></a>(3) The strncat() Function</h2><p>Alternatively, you can use <strong>strncat()</strong>, which takes a second argument indicating the <strong>maximum number of characters</strong> to add. For example, <code>strncat(bugs, addon, 13)</code> will add the contents of the <code>addon</code> string to bugs, stopping when it reaches <code>13</code> additional characters or the <strong>null character</strong>, whichever comes first. </p><h2 id="4-The-strcmp-Function"><a href="#4-The-strcmp-Function" class="headerlink" title="(4) The strcmp() Function"></a>(4) The strcmp() Function</h2><p>These results suggest that <strong>strcmp()</strong> returns a <strong>negative number</strong> if the <strong>first string precedes the second</strong> alphabetically and that it <strong>returns a positive number</strong> if the order is the other way.  It returns <strong>0</strong> if they are the <strong>same</strong>.</p><p>The <strong>strcmp()</strong> function is for <strong>comparing strings</strong>, not <strong>characters</strong>.</p><h2 id="5-The-strncmp-Variation"><a href="#5-The-strncmp-Variation" class="headerlink" title="(5) The strncmp() Variation"></a>(5) The strncmp() Variation</h2><p>The <strong>strncmp()</strong> function compares the strings until they differ or until it has compared a number of characters specified by a third argument.</p><h2 id="6-The-sprintf-Function"><a href="#6-The-sprintf-Function" class="headerlink" title="(6) The sprintf() Function"></a>(6) The sprintf() Function</h2><p>The <strong>sprintf()</strong> function is declared in <code>stdio.h</code> instead of <code>string.h</code>. It works like <strong>printf()</strong>, but it <strong>writes</strong> to a string instead of writing to a display. </p><h2 id="7-Other-String-Functions"><a href="#7-Other-String-Functions" class="headerlink" title="(7) Other String Functions"></a>(7) Other String Functions</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2)</span></span>;</code></pre><p>This function <strong>copies *<em>the string (including the *</em>null character</strong>) pointed to by <code>s2</code> to the location pointed to by <code>s1</code>. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strncpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>This function <strong>copies</strong> to the location pointed to by <code>s1</code> no more than <code>n</code> characters from the string pointed to by <code>s2</code>. The return value is <code>s1</code>. No characters after a <strong>null character</strong> are copied and, if the source string is shorter than <code>n</code> characters, the <strong>target string</strong> is padded with <strong>null characters</strong>. If the source string has <code>n</code> or more characters, <strong>no null character is copied</strong>. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2)</span></span>;</code></pre><p>The string pointed to by <code>s2</code> is copied to the <strong>end of the string</strong> pointed to by <code>s1</code>. The first character of the <code>s2</code> string is copied <strong>over the null character</strong> of the <code>s1</code> string. The <strong>return value</strong> is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strncat</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>No more than the first <code>n</code> characters of the <code>s2</code> string are appended to the <code>s1</code> string, with the first character of the <code>s2</code> string being copied <strong>over the null character</strong> of the <code>s1</code> string. The <strong>null character</strong> and any characters following it in the <code>s2</code> string are <strong>not copied</strong>, and a <strong>null character</strong> is appended to the result. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>positive value</strong> if the <code>s1</code> string follows the <code>s2</code> string in the machine collating sequence, the value <strong>0</strong> if the two strings are <strong>identical</strong>, and a <strong>negative</strong> value if the <strong>first string</strong> precedes the <strong>second string</strong> in the machine collating sequence.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strncmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>This function works like <strong>strcmp()</strong>, except that the comparison stops after <code>n</code> characters or when the first <strong>null character</strong> is encountered, whichever comes first.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s, <span class="hljs-keyword">int</span> c)</span></span>;</code></pre><p>This function <strong>returns a pointer to the first location</strong> in the string <code>s</code> that holds the character <code>c</code>. (The terminating <strong>null character</strong> is part of the string, so it can be searched for.) The function returns the <strong>null pointer</strong> if the character is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strpbrk</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>pointer to the first location</strong> in the string <code>s1</code> that holds <strong>any character</strong> found in the <code>s2</code> string. The function returns the <strong>null pointer</strong> if no character is found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strrchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s, <span class="hljs-keyword">int</span> c)</span></span>;</code></pre><p>This function returns a <strong>pointer to the last occurrence of the character</strong> <code>c</code> in the strings. (The terminating <strong>null character</strong> is part of the string, so it can be searched for.) The function returns the <strong>null pointer</strong> if the character is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>pointer to the first occurrence</strong> of string <code>s2</code> in string <code>s1</code>. The function returns the <strong>null pointer</strong> if the string is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s)</span></span>;</code></pre><p>This function returns the <strong>number of characters</strong>, not including the terminating <strong>null character</strong>, found in the <strong>strings</strong>.</p><h1 id="6-Command-Line-Arguments"><a href="#6-Command-Line-Arguments" class="headerlink" title="6. Command-Line Arguments"></a>6. Command-Line Arguments</h1><p><img src="_v_images/20201201201425398_503175558.png" srcset="/img/loading.gif" alt=""><br>A C program reads these items by using arguments to <strong>main()</strong>.</p><pre><code class="hljs c"><span class="hljs-comment">/* 11.31 repeat.c -- main() with arguments */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> count;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"The command line has %d arguments:\n"</span>, argc - <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (count = <span class="hljs-number">1</span>; count &lt; argc; count++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: %s\n"</span>, count, argv[count]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs bash">$ repeat Resistance is futile</code></pre><p>repeat is the name of the program.</p><pre><code class="hljs vim"><span class="hljs-built_in">argv</span>[<span class="hljs-number">0</span>] points <span class="hljs-keyword">to</span> <span class="hljs-built_in">repeat</span> (<span class="hljs-keyword">for</span> most systems)<span class="hljs-built_in">argv</span>[<span class="hljs-number">1</span>] points <span class="hljs-keyword">to</span> Resistance<span class="hljs-built_in">argv</span>[<span class="hljs-number">2</span>] points <span class="hljs-keyword">to</span> <span class="hljs-keyword">is</span><span class="hljs-built_in">argv</span>[<span class="hljs-number">3</span>] points <span class="hljs-keyword">to</span> futile</code></pre><p>output:</p><pre><code class="hljs c">The command <span class="hljs-built_in">line</span> has <span class="hljs-number">3</span> arguments:<span class="hljs-number">1</span>: Resistance<span class="hljs-number">2</span>: is<span class="hljs-number">3</span>: futile</code></pre><p>C compilers allow <strong>main()</strong> to have <strong>no arguments</strong> or else to have <strong>two arguments</strong>. (Some implementations allow additional arguments, but that would be an extension of the standard.) </p><p>With two arguments, the <strong>first argument</strong> is the number of strings in the command line. </p><p>The system uses <strong>spaces</strong> to tell when one string ends and the next begins. Therefore, the repeat example has <strong>four strings</strong>, including the command <strong>name</strong>. </p><p>The program stores the command line strings in memory and stores the <strong>address of each string</strong> in an <strong>array of pointers</strong>. </p><p>The address of this array is stored in the <strong>second argument</strong>.</p><h1 id="7-String-to-Number-Conversions"><a href="#7-String-to-Number-Conversions" class="headerlink" title="7. String-to-Number Conversions"></a>7. String-to-Number Conversions</h1><h2 id="1-atoi"><a href="#1-atoi" class="headerlink" title="(1) atoi( )"></a>(1) atoi( )</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*str)</span></span>;</code></pre><p>It takes a <strong>string</strong> str as  an argument and returns the corresponding <strong>integer value</strong>.  The <code>stdlib.h</code> header contains the function declaration<br>for <strong>atoi()</strong>.</p><p>该函数会扫描字符串，跳过空白字符，直到遇到数字或者正负符号才开始转换，一直到遇到非数字或者字符串结束符 <strong>‘\0’</strong> 结束扫描，如果一开始扫描到是非数字，则结束扫描，未扫描到数字返回数字 <strong>0</strong>，否则返回转换后的数字，能识别<strong>正负号</strong>。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> i,j;  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)  &#123;    j = atoi(argv[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %-10scorresponding integer: %d\n"</span>,argv[i], j);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>output:</p><pre><code class="hljs c">./atoi1.o jds323sd <span class="hljs-number">898</span>dsj23 js<span class="hljs-number">-98</span>dk +<span class="hljs-number">23</span>sd33 <span class="hljs-number">-92</span>d89s i<span class="hljs-number">-988</span>sj<span class="hljs-built_in">string</span>: jds323sd  corresponding integer: <span class="hljs-number">0</span><span class="hljs-built_in">string</span>: <span class="hljs-number">898</span>dsj23  corresponding integer: <span class="hljs-number">898</span><span class="hljs-built_in">string</span>: js<span class="hljs-number">-98</span>dk   corresponding integer: <span class="hljs-number">0</span><span class="hljs-built_in">string</span>: +<span class="hljs-number">23</span>sd33   corresponding integer: <span class="hljs-number">23</span><span class="hljs-built_in">string</span>: <span class="hljs-number">-92</span>d89s   corresponding integer: <span class="hljs-number">-92</span><span class="hljs-built_in">string</span>: i<span class="hljs-number">-988</span>sj   corresponding integer: <span class="hljs-number">0</span></code></pre><p>Implementation of <strong>atoi()</strong>:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *st)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sign, ret;    ret = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(*st))        st++;    sign = (*st == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(*st == <span class="hljs-string">'+'</span> || *st == <span class="hljs-string">'-'</span>)        st++;    <span class="hljs-keyword">for</span>( ; *st; st++)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*st))            ret = *st - <span class="hljs-string">'0'</span> + ret * <span class="hljs-number">10</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">return</span> sign * ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)    &#123;        n = atoi(argv[i]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %10sint: %d;\n"</span>, argv[i], n);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>output:</p><pre><code class="hljs c">./atoi.o sdj87<span class="hljs-number">-08</span> <span class="hljs-number">98</span>sjd09 <span class="hljs-number">-98</span>sd88 <span class="hljs-number">-09</span>sdj88<span class="hljs-built_in">string</span>:   sdj87<span class="hljs-number">-08</span><span class="hljs-keyword">int</span>: <span class="hljs-number">0</span>;<span class="hljs-built_in">string</span>:    <span class="hljs-number">98</span>sjd09<span class="hljs-keyword">int</span>: <span class="hljs-number">98</span>;<span class="hljs-built_in">string</span>:    <span class="hljs-number">-98</span>sd88<span class="hljs-keyword">int</span>: <span class="hljs-number">-98</span>;<span class="hljs-built_in">string</span>:   <span class="hljs-number">-09</span>sdj88<span class="hljs-keyword">int</span>: <span class="hljs-number">-9</span>;```                                                                                                                                                                                ## (<span class="hljs-number">2</span>) atof() ```c<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">atof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;</code></pre><p>该函数将参数 <strong>str</strong> 所指向的字符串转换为一个<strong>double</strong> 型浮点数。</p><p>浮点数合法表示:</p><pre><code class="hljs angelscript"><span class="hljs-number">3.123</span><span class="hljs-number">.2</span><span class="hljs-number">-.32</span><span class="hljs-number">2e-2</span><span class="hljs-number">2.E-2</span><span class="hljs-number">.3e-2</span></code></pre><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *ret, *<span class="hljs-built_in">find</span>;    ret = fgets(s, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span>(ret)    &#123;        <span class="hljs-built_in">find</span> = <span class="hljs-built_in">strchr</span>(s, <span class="hljs-string">'\n'</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>)        &#123;            *<span class="hljs-built_in">find</span> = <span class="hljs-string">'\0'</span>;        &#125;        <span class="hljs-keyword">else</span>        <span class="hljs-keyword">while</span>(getchar() != <span class="hljs-string">'\n'</span>)            <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> n;    <span class="hljs-keyword">char</span> s[<span class="hljs-number">10</span>];    <span class="hljs-keyword">while</span>(s_gets(s, <span class="hljs-number">10</span>) &amp;&amp; s[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span>)    &#123;        n = atof(s);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %s, float: %f\n"</span>, s, n); <span class="hljs-comment">//printf()输出双精度也是%f,输出形式为小数点形式</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Answer:</p><pre><code class="hljs c"><span class="hljs-number">.023e-3</span><span class="hljs-number">.2</span>sj<span class="hljs-built_in">string</span>: <span class="hljs-number">.023e-3</span><span class="hljs-number">.2</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000023</span><span class="hljs-number">-.32</span><span class="hljs-number">.3e2</span><span class="hljs-built_in">string</span>: <span class="hljs-number">-.32</span><span class="hljs-number">.3e2</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">-0.320000</span>sj3<span class="hljs-built_in">string</span>: sj3, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span>.e3<span class="hljs-built_in">string</span>: .e3, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span><span class="hljs-number">0.e3</span><span class="hljs-built_in">string</span>: <span class="hljs-number">0.e3</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span><span class="hljs-number">2.e-3</span><span class="hljs-number">.32</span><span class="hljs-built_in">string</span>: <span class="hljs-number">2.e-3</span><span class="hljs-number">.32</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.002000</span><span class="hljs-number">.22e-3</span><span class="hljs-built_in">string</span>: <span class="hljs-number">.22e-3</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000220</span></code></pre><p>Implementation of <strong>atof()</strong>:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEN 10</span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myatof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> s[LEN];    <span class="hljs-keyword">double</span> num;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter strings, enter a newline to quit:"</span>);    <span class="hljs-keyword">while</span>(s_gets(s,LEN) &amp;&amp; s[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span>)    &#123;        num = myatof(s);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %s, corresponding number: %f;\n"</span>, s,num);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *ret, *<span class="hljs-built_in">find</span>;    ret = fgets(s, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span>(ret)    &#123;        <span class="hljs-built_in">find</span> = <span class="hljs-built_in">strchr</span>(s,<span class="hljs-string">'\n'</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>)            *<span class="hljs-built_in">find</span> = <span class="hljs-string">'\0'</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">while</span>(getchar() != <span class="hljs-string">'\n'</span>)                <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myatof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sign, sign_e;    <span class="hljs-keyword">int</span> hasdot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> hasE = <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span> intpart = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">double</span> decpart = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">int</span> decdigit = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span> ret;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(*str))<span class="hljs-comment">//跳过开始的空格</span>        str++;      <span class="hljs-comment">//判断符号</span>    sign = (*str == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;    <span class="hljs-comment">//跳过符号位</span>    <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'-'</span> || *str == <span class="hljs-string">'+'</span>)        str++;    <span class="hljs-keyword">for</span>(;*str;str++)     &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*str)) <span class="hljs-comment">//计算整数部分</span>            intpart = <span class="hljs-number">10</span> * intpart + *str - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'.'</span>) <span class="hljs-comment">//小数点</span>        &#123;          hasdot = <span class="hljs-number">1</span>;          str++;          <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'e'</span> || *str == <span class="hljs-string">'E'</span>)<span class="hljs-comment">//科学计数法</span>        &#123;            hasE = <span class="hljs-number">1</span>;            str++;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//不合要求字符，退出</span>            <span class="hljs-keyword">return</span> sign * intpart;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">425 退出上面函数有一下情况：</span><span class="hljs-comment">426  1. 数字加非法字符：2s 直接计算结果后退出</span><span class="hljs-comment">427  2. 数字加小数点：2.</span><span class="hljs-comment">428  3. 数字加e或E：2e</span><span class="hljs-comment">429  4. e或E：e</span><span class="hljs-comment">430  5. 小数点：.</span><span class="hljs-comment">431  6. 非法字符：s 直接退出</span><span class="hljs-comment">432 */</span>        <span class="hljs-keyword">for</span>( ; *str; str++)    &#123;        <span class="hljs-keyword">if</span>(hasdot &amp;&amp; <span class="hljs-built_in">isdigit</span>(*str)) <span class="hljs-comment">//两种表达：2.3 .3; </span>        <span class="hljs-comment">//2.34小数部分计算：3 / 10  + 4 / (10 *10)</span>        <span class="hljs-comment">//pow() 函数位于math.h头文件中，计算幂，pow(10,2) == 10 * 10，但编译时要加lm</span>            decpart += (*str - <span class="hljs-string">'0'</span>) / <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span> , decdigit++);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasdot &amp;&amp; (*str == <span class="hljs-string">'e'</span> || *str ==<span class="hljs-string">'E'</span>))        <span class="hljs-comment">//情况：2.3e，.3e，.e;最后一种 .e 不合法，但最终计算结果还是为0</span>        &#123;            hasE = <span class="hljs-number">1</span>;            str++;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hasE) <span class="hljs-comment">//用科学计数法，但是前面没有小数点，情况：3e3 e3 3e- 3e+ 3e. 3ek </span>            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//遇到不合要求字符 3k 3.k 3.3k .k; 不存在有科学计数法 e 或 E情况 </span>            <span class="hljs-keyword">return</span> sign * (intpart + decpart);    &#125;    <span class="hljs-comment">//退出有一下情况：</span>    <span class="hljs-comment">// 1. 扫描数字直到结束 1.23</span>    <span class="hljs-comment">// 2. 科学计数法，前面数字部分有小数点 或者没有</span>    <span class="hljs-comment">// 3. 扫描不合法字符退出函数</span>    sign_e = (*str == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>; <span class="hljs-comment">//指数部分符号</span>    <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'+'</span> || *str == <span class="hljs-string">'-'</span>)        str++;    <span class="hljs-keyword">for</span>( ; *str; str++)<span class="hljs-comment">//识别指数部分</span>    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*str))            <span class="hljs-built_in">exp</span> = <span class="hljs-built_in">exp</span> * <span class="hljs-number">10</span> + *str - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//非法字符</span>            <span class="hljs-keyword">break</span>;    &#125;    ret = sign * ( (intpart + decpart) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span> , sign_e * <span class="hljs-built_in">exp</span>) );    <span class="hljs-keyword">return</span> ret;&#125;</code></pre><h2 id="3-atol"><a href="#3-atol" class="headerlink" title="(3)  atol()"></a>(3)  atol()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">atol</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;</code></pre><p>该函数将参数 <strong>str</strong> 所指向的字符串转换为<strong>long int</strong>。</p><h2 id="4-strtol"><a href="#4-strtol" class="headerlink" title="(4) strtol()"></a>(4) strtol()</h2><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strtol</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr, <span class="hljs-keyword">int</span> <span class="hljs-keyword">base</span></span>)</span>;</code></pre><p><strong>string to long int</strong>，该函数把参数 <strong>str</strong> 所指向的字符串根据给定的 <strong>base</strong> 转换为<strong>long int</strong>，<strong>base</strong> 必须介于 <strong>2</strong> 和 <strong>36</strong>（包含）之间，或者是特殊值 <strong>0</strong>。<br>&nbsp;<br>参数说明:<br><strong>str</strong>: 要转换的字符串，起始扫描时会跳过开头的空白字符，直到遇到数字或者正负符号开始做转换，知道遇到不合条件字符或者字符串结束字符才结束。<br>&nbsp;<br><strong>endptr</strong>: 指向指针的指针，<strong>*endptr</strong> 为指向第一个非法字符。<br>&nbsp;<br><strong>base</strong>: 基数。代表将 <strong>str</strong> 进行转换采用的进制。范围为 <strong>2~36</strong>，或者 <strong>0</strong>；<br>如 <strong>base</strong> 是 <strong>0</strong>，默认采用 <strong>10</strong> 进制，但如果遇到 <strong>‘0x’</strong> 或者 <strong>‘0X’</strong> 前置的字符，采用 <strong>16</strong> 进制，遇到 <strong>‘0’</strong> 前置非第一种情况，则用 <strong>8</strong> 进制。<br>&nbsp;<br><strong>返回值</strong>: 函数返回转换后的长整型数字，若无有效数字，返回 <strong>0</strong>。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> *end1, *end2;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> n1, n2;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)    &#123;         n1 = strtol(argv[i], &amp;end1, <span class="hljs-number">10</span>);        n2 = strtol(argv[i], &amp;end2, <span class="hljs-number">16</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string%d: %15s, base 10 input, base 10 output: %ld, stopped at %s"</span>        <span class="hljs-string">" (%d);\n"</span>,i, argv[i], n1, end1, *end1);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string%d: %15s, base 16 input, base 10 output: %ld, stopped at %s"</span>         <span class="hljs-string">" (%d);\n"</span>,i, argv[i], n2, end2, *end2);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="5-strtod"><a href="#5-strtod" class="headerlink" title="(5) strtod()"></a>(5) strtod()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">strtod</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr)</span></span>;</code></pre><p><strong>string to double</strong>，将参数 <strong>str</strong> 所指向的字符串转换为<strong>double</strong>型浮点数。</p><p>该函数返回转换后的<strong>double</strong>浮点数，如果没有执行有效的转换，则返回零（<strong>0.0</strong>）。</p><h2 id="6-strtoul"><a href="#6-strtoul" class="headerlink" title="(6) strtoul()"></a>(6) strtoul()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strtoul</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr, <span class="hljs-keyword">int</span> base)</span></span>;</code></pre><p><strong>string to unsigned long int</strong>，参数<strong>str</strong>所指向的字符串根据给定的<strong>base</strong>转换为<strong>unsigned long int</strong>型，<strong>base</strong>必须介于 <strong>2</strong> 和 <strong>36</strong>（包含）之间，或者是特殊值<strong>0</strong>。</p><p>该函数返回转换后的<strong>unsigned long int</strong>长整数，如果没有执行有效的转换，则返回 <strong>0</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arrays and Pointers</title>
    <link href="/2020/11/30/Arrays-and-Pointers/"/>
    <url>/2020/11/30/Arrays-and-Pointers/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 10 Arrays and Pointers</p><a id="more"></a><h1 id="1-Arrays"><a href="#1-Arrays" class="headerlink" title="1. Arrays"></a>1. Arrays</h1><p>An array is composed of a series of elements of <strong>one data type</strong>.</p><h2 id="1-Initialization"><a href="#1-Initialization" class="headerlink" title="(1) Initialization"></a>(1) Initialization</h2><pre><code class="hljs c"><span class="hljs-keyword">int</span> powers[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>&#125;; <span class="hljs-comment">/* ANSI C and later */</span></code></pre><p>As you can see, you initialize an array by using a <strong>comma-separated</strong> list of values enclosed in braces. You can use spaces between the values and the commas, if you want.</p><p>Sometimes you might use an array that’s intended to be a <strong>read-only</strong> array. In such cases, you can, and should, use the <strong>const</strong> keyword when you declare and initialize the array.</p><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;</code></pre><p><strong>C99</strong> added a new capability: <strong>designated initializers</strong>. This feature allows you to pick and choose which elements are initialized.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>, [<span class="hljs-number">4</span>] = <span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>, [<span class="hljs-number">1</span>] = <span class="hljs-number">29</span>&#125;;</code></pre><p><strong>First</strong>, if the code follows a designated initializer with further values, as in the sequence [4] = 31,30,31, these further values are used to initialize the subsequent elements. That is, after initializing <code>days[4]</code> to <code>31</code>, the code initializes <code>days[5]</code> and <code>days[6]</code> to <code>30</code> and <code>31</code>, respectively. </p><p><strong>Second</strong>, if the code initializes a particular element to a value <strong>more than once</strong>, the <strong>last initialization</strong> is the one that takes effect.</p><h2 id="2-Assigning-Array-Values"><a href="#2-Assigning-Array-Values" class="headerlink" title="(2) Assigning Array Values"></a>(2) Assigning Array Values</h2><p><strong>C doesn’t let you assign one array to another as a unit. Nor can you use the list-in-braces form except when initializing.</strong></p><pre><code class="hljs c"><span class="hljs-keyword">int</span> oxen[SIZE] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>&#125;; <span class="hljs-comment">/* ok here */</span><span class="hljs-keyword">int</span> yaks[SIZE];yaks = oxen; <span class="hljs-comment">/* not allowed */</span>yaks[SIZE] = oxen[SIZE]; <span class="hljs-comment">/* out of range */</span> oxen[SIZE<span class="hljs-number">-1</span>] is the last element of <span class="hljs-built_in">array</span> oxenyaks[SIZE] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>&#125;; <span class="hljs-comment">/* doesn't work */</span></code></pre><p><strong>Why can’t assign one array to another as a unit</strong><br>From <code>The C Programming Language</code></p><blockquote><p>There is one difference between an <strong>array name</strong> and a <strong>pointer</strong> that must be kept in mind. A <strong>pointer</strong> is a variable. But an <strong>array name</strong> is not a variable;</p></blockquote><blockquote><p>The <strong>array name</strong> is the <strong>address</strong> of the zeroth element.</p></blockquote><p>理解：<br>数组名为第一个元素的地址，是常量，不能被赋值。</p><h2 id="3-Array-Bounds"><a href="#3-Array-Bounds" class="headerlink" title="(3) Array Bounds"></a>(3) Array Bounds</h2><p>The compiler doesn’t check to see <strong>whether the indices are valid</strong>. The result of using a bad index is, in the language of the C standard, undefined. That means when you run the program, it might seem to work, it might work oddly, or it might abort.</p><h2 id="4-Multidimensional-Arrays"><a href="#4-Multidimensional-Arrays" class="headerlink" title="(4) Multidimensional Arrays"></a>(4) Multidimensional Arrays</h2><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> rain[YEARS][MONTHS] =&#123;&#123;<span class="hljs-number">4.3</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">2.4</span>,<span class="hljs-number">3.5</span>,<span class="hljs-number">6.6</span>&#125;,&#123;<span class="hljs-number">8.5</span>,<span class="hljs-number">8.2</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">1.6</span>,<span class="hljs-number">2.4</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">5.2</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">1.4</span>,<span class="hljs-number">7.3</span>&#125;,&#123;<span class="hljs-number">9.1</span>,<span class="hljs-number">8.5</span>,<span class="hljs-number">6.7</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">2.1</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">1.1</span>,<span class="hljs-number">2.3</span>,<span class="hljs-number">6.1</span>,<span class="hljs-number">8.4</span>&#125;,&#123;<span class="hljs-number">7.2</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">8.4</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">1.7</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">6.2</span>&#125;,&#123;<span class="hljs-number">7.6</span>,<span class="hljs-number">5.6</span>,<span class="hljs-number">3.8</span>,<span class="hljs-number">2.8</span>,<span class="hljs-number">3.8</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.3</span>,<span class="hljs-number">2.6</span>,<span class="hljs-number">5.2</span>&#125;&#125;;</code></pre><h1 id="2-Pointers-and-Arrays"><a href="#2-Pointers-and-Arrays" class="headerlink" title="2. Pointers and Arrays"></a>2. Pointers and Arrays</h1><p>An <strong>array name</strong> is also the address of the first element of the array. </p><p>That is, if <code>flizny</code> is an <strong>array</strong>, the following is true:</p><pre><code class="hljs c">flizny == &amp;flizny[<span class="hljs-number">0</span>]; <span class="hljs-comment">// name of array is the address of the first element</span></code></pre><p>Both are <strong>constants</strong> because they <strong>remain fixed</strong> for the duration of the program. </p><pre><code class="hljs c">dates + <span class="hljs-number">2</span> == &amp;date[<span class="hljs-number">2</span>] <span class="hljs-comment">// same address</span>*(dates + <span class="hljs-number">2</span>) == dates[<span class="hljs-number">2</span>] <span class="hljs-comment">// same value</span></code></pre><pre><code class="hljs c"><span class="hljs-comment">/* day_mon3.c -- uses pointer notation */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MONTHS 12</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<span class="hljs-keyword">int</span> index;<span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; MONTHS; index++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Month %2d has %d days.\n"</span>, index +<span class="hljs-number">1</span>,*(days + index)); <span class="hljs-comment">// same as days[index]</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Here, <code>days</code> is the address of the first element of the array, <code>days + index</code> is the address of element <code>days[index]</code>, and <code>*(days + index)</code> is the value of that element, just as <code>days[index]</code> is. </p><h1 id="3-Functions-Arrays-and-Pointers"><a href="#3-Functions-Arrays-and-Pointers" class="headerlink" title="3. Functions, Arrays, and Pointers"></a>3. Functions, Arrays, and Pointers</h1><pre><code class="hljs c"><span class="hljs-keyword">int</span>* ar:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;</code></pre><p>The form <code>int* ar</code> always means that ar is type <strong>pointer-to-int</strong>. The form <code>int ar[]</code> also means that <code>ar</code> is type <strong>pointer-to-int</strong>, but only when used to declare <strong>formal parameters</strong>. </p><p>The idea is that the second form reminds the reader that not only does <code>ar</code> point to an int, it points to an int that’s an element of an array.</p><p>In this context, and only in this context, C interprets <code>int ar[]</code> to mean the same as <code>int* ar</code>; that is, <code>ar</code> is type <strong>pointer-to-int</strong>.</p><p>Because <strong>prototypes</strong> allow you to omit a name, all four of the following prototypes are equivalent:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *, <span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [], <span class="hljs-keyword">int</span>)</span></span>;</code></pre><p>You <strong>can’t omit names</strong> in function definitions, so, for definitions, the following two forms are equivalent:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// code goes here</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;&#123;<span class="hljs-comment">// code goes here</span>&#125;</code></pre><p><strong>Dereferencing an Uninitialized Pointer:</strong> Do not dereference an uninitialized pointer. For example, consider the following:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt; <span class="hljs-comment">// an uninitialized pointer</span>*pt = <span class="hljs-number">5</span>; <span class="hljs-comment">// a terrible error</span></code></pre><p>The second line means store the value <code>5</code> in the location to which <code>pt</code> points. But <code>pt</code>, being <strong>uninitialized</strong>, has a random value, so there is no knowing where the <code>5</code> will be placed. It might go somewhere harmless, it might overwrite data or code, or it might cause the program to crash. </p><h1 id="4-Using-Pointer-Parameters"><a href="#4-Using-Pointer-Parameters" class="headerlink" title="4. Using Pointer Parameters"></a>4. Using Pointer Parameters</h1><p>A function working on an array needs to know where to start and stop. </p><p>The two expressions <code>ar[i]</code> and <code>*(ar+i)</code> are equivalent in meaning. Both work if ar is the name of an <strong>array</strong>, and both work if ar is a <strong>pointer</strong> variable.<br>However, using an expression such as <code>ar++</code> only works if <code>ar</code> is a <strong>pointer</strong> variable.</p><p>You must use <strong>pointers</strong> if you want a function to affect variables in the calling function. The second use is in functions designed to manipulate arrays.</p><h1 id="5-Protecting-Array-Contents"><a href="#5-Protecting-Array-Contents" class="headerlink" title="5. Protecting Array Contents"></a>5. Protecting Array Contents</h1><p>The usual rule is to pass quantities by value unless the program needs to alter the value, in which case you pass a pointer. </p><p>Arrays don’t give you that choice; you must pass a pointer. The reason is efficiency. </p><p>If a function passed an array by value, it would have to allocate enough space to hold a copy of the original array and then copy all the data from the original array to the new array. </p><p>It is much quicker to pass the address of the array and have the function work with the original data.</p><h1 id="6-Using-const-with-Formal-Parameters"><a href="#6-Using-const-with-Formal-Parameters" class="headerlink" title="6. Using const with Formal Parameters"></a>6. Using const with Formal Parameters</h1><p>If a function’s intent is that it not change the contents of the array, use the keyword <strong>const</strong> when declaring the formal parameter in the prototype and in the <strong>function definition</strong>. </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>; <span class="hljs-comment">/* prototype */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">/* definition */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; n; i++)        total += ar[i];    <span class="hljs-keyword">return</span> total;&#125;</code></pre><p>It’s important to understand that using <strong>const</strong> this way <strong>does not require that the original array be constant</strong>; it just says that the function has to treat the array as though it were constant. </p><p>It prevents a function from modifying data in the calling function. </p><p><strong>There are some rules you should know about pointer assignments and const.</strong></p><p><strong>First</strong>, it’s valid to <strong>assign</strong> the <strong>address</strong> of either <strong>constant data</strong> or <strong>non-constant</strong> data to a <strong>pointer-to-constant</strong>:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> locked[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0.08</span>, <span class="hljs-number">0.075</span>, <span class="hljs-number">0.0725</span>, <span class="hljs-number">0.07</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *pc = rates; <span class="hljs-comment">// valid</span>pc = locked; <span class="hljs-comment">// valid</span>pc = &amp;rates[<span class="hljs-number">3</span>]; <span class="hljs-comment">// valid</span></code></pre><p><strong>However</strong>, only the addresses of <strong>non-constant data</strong> can be assigned to <strong>regular pointers</strong>:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> locked[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0.08</span>, <span class="hljs-number">0.075</span>, <span class="hljs-number">0.0725</span>, <span class="hljs-number">0.07</span>&#125;;<span class="hljs-keyword">double</span> *pnc = rates; <span class="hljs-comment">// valid</span>pnc = locked; <span class="hljs-comment">// not valid</span>pnc = &amp;rates[<span class="hljs-number">3</span>]; <span class="hljs-comment">// valid</span></code></pre><p>This is a reasonable rule. Otherwise, you could use the pointer to change data that was supposed to be constant.</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">double</span>* <span class="hljs-keyword">const</span> pc = rates; <span class="hljs-comment">// pc points to beginning of the array</span>pc = &amp;rates[<span class="hljs-number">2</span>]; <span class="hljs-comment">// not allowed to point elsewhere</span>*pc = <span class="hljs-number">92.99</span>; <span class="hljs-comment">// ok -- changes rates[0]</span></code></pre><h1 id="7-Pointers-and-Multidimensional-Arrays"><a href="#7-Pointers-and-Multidimensional-Arrays" class="headerlink" title="7. Pointers and Multidimensional Arrays"></a>7. Pointers and Multidimensional Arrays</h1><p><img src="https://img-blog.csdnimg.cn/20190604210825828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1-Pointers-to-Multidimensional-Arrays"><a href="#1-Pointers-to-Multidimensional-Arrays" class="headerlink" title="(1) Pointers to Multidimensional Arrays"></a>(1) Pointers to Multidimensional Arrays</h2><pre><code class="hljs c"><span class="hljs-keyword">int</span> (*pz)[<span class="hljs-number">2</span>]; <span class="hljs-comment">// pz points to an array of 2 ints</span></code></pre><p>This statement says that <code>pz</code> is a pointer to an array of two ints. </p><p><code>[ ]</code> has a higher precedence than <code>*</code>. Therefore, with a declaration such as:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span>* pax[<span class="hljs-number">2</span>]; <span class="hljs-comment">// pax is an array of two pointers-to-int</span></code></pre><p>You can use notation such as <code>pz[2][1]</code>, even though <code>pz</code> is a <strong>pointer</strong>, not an <strong>array</strong> name. </p><p>More generally, you can represent individual elements by using <strong>array notation</strong> or <strong>pointer notation</strong> with either an <strong>array</strong> name or a <strong>pointer</strong>:</p><pre><code class="hljs c">zippo[m][n] == *(*(zippo + m) + n)pz[m][n] == *(*(pz + m) + n)</code></pre><h2 id="2-Pointer-Compatibility"><a href="#2-Pointer-Compatibility" class="headerlink" title="(2) Pointer Compatibility"></a>(2) Pointer Compatibility</h2><p>The rules for assigning one <strong>pointer</strong> to another are tighter than the rules for <strong>numeric types</strong>. </p><p>For example, you can assign an <strong>int</strong> value to a <strong>double</strong> variable without using a <strong>type conversion</strong>, but you can’t do the same for <strong>pointers</strong> to these two types:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;<span class="hljs-keyword">double</span> x;<span class="hljs-keyword">int</span> * p1 = &amp;n;<span class="hljs-keyword">double</span>* pd = &amp;x;x = n; <span class="hljs-comment">// implicit type conversion</span>pd = p1; <span class="hljs-comment">// compile-time error</span></code></pre><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt;<span class="hljs-keyword">int</span> (*pa)[<span class="hljs-number">3</span>];<span class="hljs-keyword">int</span> ar1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<span class="hljs-keyword">int</span> ar2[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> **p2; <span class="hljs-comment">// a pointer to a pointer</span>Then we have the following:pt = &amp;ar1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>pt = ar1[<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>pt = ar1; <span class="hljs-comment">// not valid</span>pa = ar1; <span class="hljs-comment">// both pointer-to-int[3]</span>pa = ar2; <span class="hljs-comment">// not valid</span>p2 = &amp;pt; <span class="hljs-comment">// both pointer-to-int *</span>*p2 = ar2[<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>p2 = ar2; <span class="hljs-comment">// not valid</span></code></pre><h2 id="3-Functions-and-Multidimensional-Arrays"><a href="#3-Functions-and-Multidimensional-Arrays" class="headerlink" title="(3) Functions and Multidimensional Arrays"></a>(3) Functions and Multidimensional Arrays</h2><p>You can declare a function parameter of this type like this:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">somefunction</span><span class="hljs-params">( <span class="hljs-keyword">int</span> (*pt)[<span class="hljs-number">4</span>])</span></span>; <span class="hljs-comment">// pt is a pointer to an array of four ints.</span></code></pre><p>Alternatively, if (and only if) <code>pt</code> is a <strong>formal parameter</strong> to a function, you can declare it as follows:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">somefunction</span><span class="hljs-params">( <span class="hljs-keyword">int</span> pt[][<span class="hljs-number">4</span>] )</span></span>;</code></pre><p><strong>Note that the first set of brackets is empty. The empty brackets identify pt as being a pointer.</strong></p><p>Recall that the compiler converts <strong>array</strong> notation to <strong>pointer</strong> notation. This means, for example, that <code>ar[1]</code> will become <code>ar+1</code>. For the compiler to evaluate this, it needs to know the size object to which ar points. </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[][<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// valid declaration</span></code></pre><p>says that <code>ar</code> points to an array of four ints.</p><p>You can also include a size in the other bracket pair, as shown here, but the compiler ignores it: </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// valid declaration, 3 ignored</span></code></pre><p>In general, to declare a <strong>pointer</strong> corresponding to an <strong>N-dimensional array</strong>, <strong>you must supply values for all but the leftmost set of brackets</strong>:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum4d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[][<span class="hljs-number">12</span>][<span class="hljs-number">20</span>][<span class="hljs-number">30</span>], <span class="hljs-keyword">int</span> rows)</span></span>;</code></pre><p>That’s because the <strong>first set of brackets</strong> indicates a <strong>pointer</strong>, whereas the rest of the brackets describe the type of data object <strong>being pointed to</strong>, as the following equivalent prototype illustrates:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum4d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*ar)[<span class="hljs-number">12</span>][<span class="hljs-number">20</span>][<span class="hljs-number">30</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// ar a pointer</span></code></pre><p>Here, ar points to a <code>12×20×30</code> array of ints.</p><h2 id="4-Variable-Length-Arrays-VLAs"><a href="#4-Variable-Length-Arrays-VLAs" class="headerlink" title="(4) Variable-Length Arrays (VLAs)"></a>(4) Variable-Length Arrays (VLAs)</h2><p><strong>VLAs Do Not Change Size</strong>:<br>The term <strong>variable in variable-length array</strong> does not mean that you can modify the length of the array after you create it. Once created, a <strong>VLA</strong> keeps the <strong>same size</strong>. What the term variable does mean is that you can use a variable when specifying the array dimensions when <strong>first creating the array</strong>.</p><p>First, here’s how to declare a function with a <strong>two-dimensional VLA</strong> argument:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">int</span> ar[rows][cols])</span></span>; <span class="hljs-comment">// ar a VLA</span></code></pre><p>One point to note is that a <strong>VLA</strong> declaration in a function definition parameter list doesn’t actually create an array. Just as with the old syntax, the <strong>VLA</strong> name really is a <strong>pointer</strong>. This means a function with a <strong>VLA</strong> parameter actually works with the data in the <strong>original array</strong>, and therefore has the ability to <strong>modify the array</strong> passed as an argument. </p><pre><code class="hljs c"><span class="hljs-keyword">int</span> thing[<span class="hljs-number">10</span>][<span class="hljs-number">6</span>];twoset(<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,thing);...<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">twoset</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> ar[n][m])</span> <span class="hljs-comment">// ar a pointer to</span></span><span class="hljs-function"><span class="hljs-comment">// an array of m ints</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp[n][m]; <span class="hljs-comment">// temp an n x m array of int</span>    temp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// set an element of temp to 2</span>    ar[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// set thing[0][0] to 2</span>&#125;</code></pre><p>When <code>twoset()</code> is called as shown, <code>ar</code> becomes a pointer to <code>thing[0]</code>, and <code>temp</code> is created as a <code>10×6</code>array. Because both <code>ar</code> and <code>thing</code> are pointers to <code>thing[0]</code>, <code>ar[0][0]</code> accesses the same data location as <code>thing[0][0]</code>.</p><p><strong>Variable-length</strong> arrays also allow for <strong>dynamic memory allocation</strong>. This means you can specify the size of the array while the program is running. </p><h1 id="8-Compound-Literals"><a href="#8-Compound-Literals" class="headerlink" title="8. Compound Literals"></a>8. Compound Literals</h1><p>Suppose you want to pass a value to a function with an <strong>int</strong> parameter; you can pass an <strong>int</strong> variable, but you also can pass an <strong>int constant</strong>, such as <strong>5</strong>. Before <strong>C99</strong>, the situation for a function with an <strong>array argument</strong> was different; you could pass an <strong>array</strong>, but there was no equivalent to an <strong>array constant</strong>. <strong>C99</strong> changed that with the addition of compound literals. </p><p><strong>Literals</strong> are <strong>constants</strong> that aren’t symbolic. For example, <strong>5</strong> is a type <strong>int literal</strong>, <strong>81.3</strong> is a <strong>type double literal</strong>, <strong>‘Y’</strong> is a type <strong>char literal</strong>, and <strong>“elephant”</strong> is a <strong>string literal</strong>. </p><p>For <strong>arrays</strong>, a <strong>compound literal</strong> looks like an <strong>array initialization list</strong> preceded by a type name that is enclosed in parentheses. For example, here’s an ordinary array declaration:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> diva[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;</code></pre><p>And here’s a compound literal that creates a nameless array containing the same two int values:</p><pre><code class="hljs c">(<span class="hljs-keyword">int</span> [<span class="hljs-number">2</span>])&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125; <span class="hljs-comment">// a compound literal</span></code></pre><p>Because these <strong>compound literals</strong> are nameless, you can’t just create them in one statement and then use them later. Instead, you have to use them somehow when you make them.<br>One way is to use a *<em>pointer *</em>to keep track of the location. That is, you can do something like this:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt1;pt1 = (<span class="hljs-keyword">int</span> [<span class="hljs-number">2</span>]) &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;</code></pre><p>Another thing you could do with a <strong>compound literal</strong> is pass it as an actual argument to a function with a matching formal parameter:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;...<span class="hljs-keyword">int</span> total3;total3 = sum((<span class="hljs-keyword">int</span> [])&#123;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>&#125;, <span class="hljs-number">6</span>);</code></pre><p>Keep in mind that a <strong>compound literal</strong> is a means for providing values that are needed only <strong>temporarily</strong>. It has block scope. That means its existence is not guaranteed once program execution leaves the block in which the compound literal is defined, that is, the innermost pair of braces containing the definition.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Functions</title>
    <link href="/2020/11/30/Functions/"/>
    <url>/2020/11/30/Functions/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 9 Functions</p><a id="more"></a><h1 id="1-Function-Arguments"><a href="#1-Function-Arguments" class="headerlink" title="1. Function Arguments"></a>1. Function Arguments</h1><h2 id="1-Defining-a-Function-with-an-Argument-Formal-Parameters"><a href="#1-Defining-a-Function-with-an-Argument-Formal-Parameters" class="headerlink" title="(1) Defining a Function with an Argument: Formal Parameters"></a>(1) Defining a Function with an Argument: Formal Parameters</h2><p>Formal parameters are local variables, private to the function.  </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dubs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span></span>;</code></pre><h2 id="2-Calling-a-Function-with-an-Argument-Actual-Arguments"><a href="#2-Calling-a-Function-with-an-Argument-Actual-Arguments" class="headerlink" title="(2) Calling a Function with an Argument: Actual Arguments"></a>(2) Calling a Function with an Argument: Actual Arguments</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_n_char</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> num)</span></span>;show_n_char(SPACE, <span class="hljs-number">12</span>);</code></pre><p>The <strong>actual arguments</strong> are the <code>space</code> character and <code>12</code>. These values are assigned to the corresponding <strong>formal parameters</strong> in <strong>show_n_char()</strong>—the variables <code>ch</code> and <code>num</code>. </p><p>In short, the <strong>formal parameter</strong> is a variable in the <strong>called function</strong>, and the <strong>actual argument</strong> is the particular value assigned to the function variable by the <strong>calling function</strong>. </p><p>The <strong>actual argument</strong> can be a constant, a variable, or an even more elaborate expression. Regardless of which it is, the <strong>actual argument</strong> is evaluated, and <strong>its value is copied to the corresponding formal parameter for the function</strong>.</p><p><strong>Because the called function works with data copied from the calling function, the original data in the calling function is protected from whatever manipulations the called function applies to the copies.</strong></p><h1 id="2-Returning-a-Value-from-a-Function-with-return"><a href="#2-Returning-a-Value-from-a-Function-with-return" class="headerlink" title="2. Returning a Value from a Function with return"></a>2. Returning a Value from a Function with return</h1><p>Using <strong>return</strong> has one other effect. It terminates the function and returns control to the next statement in the calling function. <strong>This occurs even if the return statement is not the last in the function.</strong></p><h1 id="3-Finding-Addresses-The-amp-Operator"><a href="#3-Finding-Addresses-The-amp-Operator" class="headerlink" title="3. Finding Addresses: The &amp; Operator"></a>3. Finding Addresses: The &amp; Operator</h1><p>One of the most important C concepts (and sometimes one of the most perplexing) is the <strong>pointer</strong>, which is a variable used to store an address.  </p><p>The unary <strong>&amp;</strong> operator gives you the address where a variable is stored. </p><h1 id="4-Pointers-A-First-Look"><a href="#4-Pointers-A-First-Look" class="headerlink" title="4. Pointers: A First Look"></a>4. Pointers: A First Look</h1><p>Basically, a <strong>pointer</strong> is a variable (or, more generally, a data object) whose value is a memory address. </p><pre><code class="hljs c">ptr = &amp;pooh; <span class="hljs-comment">// assigns pooh's address to ptr</span></code></pre><p>We say that ptr  “points to” pooh. The difference between ptr and &amp;pooh is that <strong>ptr</strong> is a variable, and <strong>&amp;pooh</strong> is a constant. </p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pi; <span class="hljs-comment">// pi is a pointer to an integer variable</span><span class="hljs-keyword">char</span> * pc; <span class="hljs-comment">// pc is a pointer to a character variable</span><span class="hljs-keyword">float</span> * pf, * pg; <span class="hljs-comment">// pf, pg are pointers to float variables</span></code></pre><p>A <strong>pointer</strong> really is a new type, not an <strong>integer</strong> type. Therefore, as mentioned before, ANSI C provides the <strong>%p</strong> form specifically for pointers.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Character Input/Output</title>
    <link href="/2020/11/29/Character-Input-Output/"/>
    <url>/2020/11/29/Character-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 8 Character Input/Output and Input Validation</p><a id="more"></a><h1 id="1-Single-Character-I-O-getchar-and-putchar"><a href="#1-Single-Character-I-O-getchar-and-putchar" class="headerlink" title="1. Single-Character I/O: getchar() and putchar()"></a>1. Single-Character I/O: getchar() and putchar()</h1><p><strong>getchar()</strong> and <strong>putchar()</strong> perform input and output one character at a time. </p><p>All it does is fetch characters from <strong>keyboard input</strong> and send them to the screen. This process is called <strong>echoing the input</strong>. </p><h1 id="2-Buffers"><a href="#2-Buffers" class="headerlink" title="2. Buffers"></a>2. Buffers</h1><h2 id="1-unbuffered-or-direct-input"><a href="#1-unbuffered-or-direct-input" class="headerlink" title="(1) unbuffered (or direct) input"></a>(1) unbuffered (or direct) input</h2><p>The characters you type are <strong>immediately made available</strong> to the waiting program. </p><h2 id="2-buffered-input"><a href="#2-buffered-input" class="headerlink" title="(2)  buffered input"></a>(2)  buffered input</h2><p>The characters you type are <strong>collected and stored in an area of temporary storage</strong> called a <strong>buffer</strong>.  Pressing <strong>Enter</strong> causes the block of characters you typed to be made available to your program. </p><h3 id="fully-buffered-I-O"><a href="#fully-buffered-I-O" class="headerlink" title="fully buffered I/O"></a>fully buffered I/O</h3><p>The <strong>buffer</strong> is flushed (the contents are sent to their destination) when it is <strong>full</strong>. This kind of buffering usually occurs with <strong>file input</strong>. </p><p>The buffer size depends on the system, but 512 bytes and 4096 bytes are common values. </p><h3 id="line-buffered-I-O"><a href="#line-buffered-I-O" class="headerlink" title="line-buffered I/O"></a>line-buffered I/O</h3><p>The <strong>buffer</strong> is flushed whenever a <strong>newline character shows up</strong>. <strong>Keyboard input</strong> is normally <strong>line buffered</strong>, so that pressing <strong>Enter</strong> flushes the buffer.</p><h1 id="3-Files-Streams-and-Keyboard-Input"><a href="#3-Files-Streams-and-Keyboard-Input" class="headerlink" title="3. Files, Streams, and Keyboard Input"></a>3. Files, Streams, and Keyboard Input</h1><h2 id="1-file"><a href="#1-file" class="headerlink" title="(1)  file"></a>(1)  file</h2><p>A <strong>file</strong> is an area of memory in which information is stored. </p><p>Conceptually, the C program deals with a <strong>stream</strong> instead of directly with a file. </p><h2 id="2-stream"><a href="#2-stream" class="headerlink" title="(2) stream"></a>(2) stream</h2><p>A <strong>stream</strong> is an idealized flow of data to which the actual input or output is mapped.</p><h1 id="4-The-End-of-File"><a href="#4-The-End-of-File" class="headerlink" title="4. The End of File"></a>4. The End of File</h1><p>A computer operating system needs some way to tell where each file begins and ends. </p><p>One method to detect the end of a file is to place a <strong>special character</strong> in the file to <strong>mark the end</strong>.</p><p>A second approach is for the operating system to store information on the size of the file.</p><p>C handles this variety of methods by having the  <strong>getchar()</strong>  function return a special value when the end of a file is reached, regardless of how the operating system actually detects the end of file. The name given to this value is <strong>EOF</strong> (end of file). </p><p>Therefore, the <strong>return value</strong> for <strong>getchar()</strong> when it detects an end of file is <strong>EOF</strong>. The <strong>scanf()</strong> function also returns <strong>EOF</strong> on detecting the end of a file. </p><p>Typically, <strong>EOF</strong> is defined in the <strong>stdio.h</strong> file as follows:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOF (-1)</span></code></pre><p>Normally, <strong>getchar()</strong> returns a value in the range <strong>0</strong> through <strong>127</strong>, because those are values corresponding to the standard character set, but it might return values from <strong>0</strong> through <strong>255</strong> if the system recognizes an extended character set. </p><p>In either case, the value <strong>-1</strong> does not correspond to any character, so it can be used to signal the end of a file.<br>&nbsp;</p><pre><code class="hljs c"><span class="hljs-comment">/* echo_eof.c -- repeats input to end of file */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ch;    <span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)        <span class="hljs-built_in">putchar</span>(ch);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>Note:</strong></p><ul><li>You don’t have to define <strong>EOF</strong> because <strong>stdio.h</strong> takes care of that.</li><li>You don’t have to worry about the actual value of <strong>EOF</strong>, because the <strong>#define</strong> statement in <strong>stdio.h</strong> enables you to use the symbolic representation <strong>EOF</strong>. You shouldn’t write code that assumes <strong>EOF</strong> has a particular value.</li><li><strong>getchar()</strong> is actually type int itself, so it can read the EOF character.</li><li>The fact that <strong>getchar()</strong> is type <strong>int</strong> is why some compilers warn of possible data loss if you assign the <strong>getchar()</strong> return value to a type <strong>char</strong> variable.</li><li>The fact that <strong>ch</strong> is an <strong>integer</strong> doesn’t faze <strong>putchar()</strong>. It still prints the character equivalent.</li><li>To use this program on <strong>keyboard input</strong>, you need a way to type the <strong>EOF</strong> character. On <strong>most Unix and Linux systems</strong>, for example, pressing <strong>Ctrl+D</strong> at the <strong>beginning of a line</strong> causes the <strong>end-of-file signal</strong> to be transmitted. Many <strong>microcomputing systems</strong> recognize <strong>Ctrl+Z</strong> at the beginning of a line as an end-of-file signal; some interpret a <strong>Ctrl+Z</strong> anywhere as an <strong>end-of-file signal</strong>.</li></ul><h1 id="5-Redirection"><a href="#5-Redirection" class="headerlink" title="5. Redirection"></a>5. Redirection</h1><p><strong>Redirecting</strong> input enables your program to use a <strong>file</strong> instead of the <strong>keyboard</strong> for input, and redirecting output enables it to use a <strong>file</strong> instead of the <strong>screen</strong> for output.</p><h2 id="1-Redirecting-Input"><a href="#1-Redirecting-Input" class="headerlink" title="(1) Redirecting Input"></a>(1) Redirecting Input</h2><p>The program runs as described earlier, taking its input from the keyboard. Now suppose you want to use the program on a <strong>text file</strong> called <code>words</code>. </p><p>A <strong>text file</strong> is one containing text—that is, data stored as <strong>human-readable characters</strong>. It could be an essay or a program in C, for example. A file containing machine language instructions, such as the file holding the executable version<br>of a program, is not a text file. </p><p>All you need to do is enter this command instead of the previous one:</p><pre><code class="hljs bash">echo_eof &lt; words</code></pre><p>The <code>&lt;</code> symbol is a <strong>Unix and Linux and DOS/Windows redirection operator</strong>. It causes the <code>words</code> file to be associated with the <strong>stdin stream</strong>, channeling the file contents into the <code>echo_eof</code> program. </p><p>The <code>echo_eof</code> program itself doesn’t know (or care) that the input is coming from a file instead of the keyboard. All it knows is that a stream of characters is being fed to it, so it reads them and prints them one character at a time until the end of file shows up. </p><p>Because C puts files and I/O devices on the same footing, the file is now the I/O device. </p><h2 id="2-Redirecting-Output"><a href="#2-Redirecting-Output" class="headerlink" title="(2) Redirecting Output"></a>(2) Redirecting Output</h2><p>Now suppose you want to have <code>echo_eof</code> send your keyboard input to a file called <code>mywords</code>.</p><p>Then you can enter the following and begin typing:</p><pre><code class="hljs bash">echo_eof &gt; mywords</code></pre><p>The <code>&gt;</code> is a second <strong>redirection operator</strong>. It causes a new file called <code>mywords</code> to be created for your use, and then it *<em>redirects the output *</em>of <code>echo_eof</code> (that is, a copy of the characters you type) to that file. </p><p>If you already have a file with the name <code>mywords</code>, normally it would be <strong>erased</strong> and then <strong>replaced</strong> by the new one. (Many operating systems, however, give you the option of protecting existing files by making them <strong>read-only</strong>.) </p><p>All that appears on your screen are the letters as you type them, and the copies go to the file instead. To end the program, press <strong>Ctrl+D</strong>.</p><h2 id="3-Combined-Redirection"><a href="#3-Combined-Redirection" class="headerlink" title="(3) Combined Redirection"></a>(3) Combined Redirection</h2><p>Now suppose you want to make a copy of the file mywords and call it savewords. Just issue this next command:</p><pre><code class="hljs bash">echo_eof &lt; mywords &gt; savewords</code></pre><p>or:</p><pre><code class="hljs bash">echo_eof &gt; savewords &lt; mywords</code></pre><p><strong>Beware: *<em>Don’t use the *</em>same file for both input and output</strong> to the same command.</p><pre><code class="hljs bash">echo_eof &lt; mywords &gt; mywords....&lt;--WRONG</code></pre><p>The reason is that <code>&gt;</code> mywords causes the original mywords to be <strong>truncated to zero length</strong> before it is ever used as input.</p><p><strong>Rules:</strong></p><ul><li>A <strong>redirection operator</strong> connects an <strong>executable program</strong> (including standard operating system commands) with a <strong>data file</strong>. It cannot be used to connect one data file to another, nor can it be used to connect one program to another program.</li><li>Input cannot be taken from <strong>more than one file</strong>, nor can output be directed to more than one file by using these operators.</li><li>Normally, <strong>spaces between the names and operators are optional</strong>, except occasionally when some characters with special meaning to the Unix shell or Linux shell or the Windows Command Prompt mode are used. We could, for example, have used <code>echo_ eof&lt;words</code>.</li></ul><p>Unix, Linux, and Windows/DOS also feature the <code>&gt;&gt;</code> operator, which enables you to <strong>add data</strong> to the end of an <strong>existing file</strong>, and the pipe operator (<code>|</code>), which enables you to connect the <strong>output of one program</strong> to the <strong>input of a second program</strong>. </p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Branching and Jumps</title>
    <link href="/2020/11/29/Branching-and-Jumps/"/>
    <url>/2020/11/29/Branching-and-Jumps/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 7 C Control Statements: Branching and Jumps</p><a id="more"></a><h1 id="1-getchar-and-putchar"><a href="#1-getchar-and-putchar" class="headerlink" title="1.  getchar() and putchar()"></a>1.  getchar() and putchar()</h1><p>The <strong>getchar()</strong> function takes no arguments, and it <strong>returns</strong> the next character from input.<br>&nbsp;<br>The <strong>putchar()</strong> function prints its argument.<br>&nbsp;<br>Because these functions deal only with characters, they are faster and more compact than the more general <strong>scanf()</strong> and <strong>printf()</strong> functions.<br>&nbsp;<br>Characters are really stored as <strong>integers</strong>. <strong>getchar( )</strong> is actually type <strong>int</strong> itself.</p><h1 id="2-The-ctype-h-Family-of-Character-Functions"><a href="#2-The-ctype-h-Family-of-Character-Functions" class="headerlink" title="2. The ctype.h Family of Character Functions"></a>2. The ctype.h Family of Character Functions</h1><p>C has a standard set of functions for analyzing characters; the <strong>ctype.h</strong> header file contains the prototypes.<br>&nbsp;<br>Note that the mapping functions don’t modify the original argument; instead, they return the modified value. </p><pre><code class="hljs c"><span class="hljs-built_in">tolower</span>(ch); <span class="hljs-comment">// no effect on ch</span>ch = <span class="hljs-built_in">tolower</span>(ch); <span class="hljs-comment">// convert ch to lowercase</span></code></pre><table><thead><tr><th align="left">Name</th><th align="left">True If the Argument Is</th></tr></thead><tbody><tr><td align="left">isalnum()</td><td align="left">Alphanumeric (alphabetic or numeric)</td></tr><tr><td align="left">isalpha()</td><td align="left">Alphabetic</td></tr><tr><td align="left">isblank()</td><td align="left">A standard blank character (space, horizontal tab, or newline) or any additional locale-specific character so specified</td></tr><tr><td align="left">iscntrl()</td><td align="left">A control character, such as Ctrl+B</td></tr><tr><td align="left">isdigit()</td><td align="left">A digit</td></tr><tr><td align="left">isgraph()</td><td align="left">Any printing character other than a space</td></tr><tr><td align="left">islower()</td><td align="left">A lowercase character</td></tr><tr><td align="left">isprint()</td><td align="left">A printing character</td></tr><tr><td align="left">ispunct()</td><td align="left">A punctuation character (any printing character other than a space or an alphanumeric character)</td></tr><tr><td align="left">isspace()</td><td align="left">A whitespace character (a space, newline, formfeed, carriage return, vertical tab, horizontal tab, or, possibly, other locale-defined character)</td></tr><tr><td align="left">isupper()</td><td align="left">An uppercase character</td></tr><tr><td align="left">isxdigit()</td><td align="left">A hexadecimal-digit character</td></tr></tbody></table><table><thead><tr><th align="left">Name</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">tolower()</td><td align="left">If the argument is an uppercase character, this function returns the lowercase version; otherwise, it just returns the original argument.</td></tr><tr><td align="left">toupper()</td><td align="left">If the argument is a lowercase character, this function returns the uppercase version; otherwise, it just returns the original argument.</td></tr></tbody></table><h1 id="3-Logical-Operators"><a href="#3-Logical-Operators" class="headerlink" title="3. Logical Operators"></a>3. Logical Operators</h1><table><thead><tr><th align="left">Operator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">and</td></tr><tr><td align="left">||</td><td align="left">or</td></tr><tr><td align="left">!</td><td align="left">not</td></tr></tbody></table><h2 id="1-Precedence"><a href="#1-Precedence" class="headerlink" title="(1) Precedence"></a>(1) Precedence</h2><p>The <strong>!</strong> operator has a very high precedence—higher than <strong>multiplication</strong>, the same as the <strong>increment operators</strong>, and just below that of <strong>parentheses</strong>. The <strong>&amp;&amp;</strong> operator has higher precedence than <strong>||</strong>.</p><h2 id="2-Order-of-Evaluation"><a href="#2-Order-of-Evaluation" class="headerlink" title="(2) Order of Evaluation"></a>(2) Order of Evaluation</h2><p>The <strong>&amp;&amp;</strong> and <strong>||</strong> operators are sequence points, so all side effects take place before a program moves from one operand to the next. </p><pre><code class="hljs c"><span class="hljs-keyword">while</span> ( x++ &lt; <span class="hljs-number">10</span> &amp;&amp; x + y &lt; <span class="hljs-number">20</span>)</code></pre><p>The fact that the <strong>&amp;&amp;</strong> operator is a sequence point guarantees that <code>x</code> is incremented before the expression on the right is evaluated.</p><h1 id="4-A-Word-Count-Program"><a href="#4-A-Word-Count-Program" class="headerlink" title="4. A Word-Count Program"></a>4. A Word-Count Program</h1><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STOP <span class="hljs-meta-string">'\x1b'</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> c;  <span class="hljs-comment">//read in character</span>    <span class="hljs-keyword">char</span> prev; <span class="hljs-comment">//previous character read</span>    <span class="hljs-keyword">long</span> n_chars = <span class="hljs-number">0L</span>; <span class="hljs-comment">//number of characters</span>    <span class="hljs-keyword">long</span> n_alphabets = <span class="hljs-number">0L</span>; <span class="hljs-comment">//alphabetic</span>    <span class="hljs-keyword">long</span> n_digits = <span class="hljs-number">0L</span>; <span class="hljs-comment">//digits</span>    <span class="hljs-keyword">long</span> n_spaces = <span class="hljs-number">0L</span>;    <span class="hljs-keyword">long</span> n_punctuations = <span class="hljs-number">0L</span>;    <span class="hljs-keyword">int</span> n_lines = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> n_words = <span class="hljs-number">0</span>;    <span class="hljs-keyword">bool</span> inword = <span class="hljs-literal">false</span>;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter text to be analyzed (Esc to terminate):\n"</span>);    prev = <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">while</span> ((c = getchar()) != STOP)    &#123;        n_chars++;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalpha</span>(c))           n_alphabets++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))            n_digits++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ispunct</span>(c))            n_punctuations++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c))            n_spaces++;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'\n'</span>)            n_lines++;        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isspace</span>(c) &amp;&amp; !inword)         &#123;            inword = <span class="hljs-literal">true</span>;            n_words++;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c) &amp;&amp; inword)         &#123;            inword = <span class="hljs-literal">false</span>; <span class="hljs-comment">//reached end of a word</span>        &#125;        prev = c;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Charaters = %ld, alphabets = %ld, digits = %ld,\</span><span class="hljs-string">    punctuations = %ld, spaces = %ld,  words = %d, lines = %d\n"</span>,    n_chars,n_alphabets,n_digits,n_punctuations,n_spaces,n_words,n_lines);    <span class="hljs-comment">/*return 0; */</span>&#125;</code></pre><p>Output:</p><pre><code class="hljs c"><span class="hljs-function">Enter <span class="hljs-built_in">text</span> to be <span class="hljs-title">analyzed</span> <span class="hljs-params">(Esc to <span class="hljs-built_in">terminate</span>)</span>:</span><span class="hljs-function">Reason is a</span><span class="hljs-function">powerful servant but</span>an inadequate master.<span class="hljs-number">2</span> - <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;*** :) ***^[Charaters = <span class="hljs-number">77</span>, alphabets = <span class="hljs-number">45</span>, digits = <span class="hljs-number">3</span>, punctuations = <span class="hljs-number">12</span>, spaces = <span class="hljs-number">17</span>,  words = <span class="hljs-number">17</span>, lines = <span class="hljs-number">5</span></code></pre><h1 id="5-The-Conditional-Operator"><a href="#5-The-Conditional-Operator" class="headerlink" title="5. The Conditional Operator: ?:"></a>5. The Conditional Operator: ?:</h1><p>C offers a shorthand way to express one form of the <strong>if else</strong> statement. It is called a conditional expression and uses the <strong>?:</strong> conditional operator. </p><pre><code class="hljs c">expression1 ? expression2 : expression3</code></pre><p>If expression1 is true (nonzero), the whole conditional expression has the same value as expression2. If expression1 is false (zero), the whole conditional expression has the same value as expression3.</p><h1 id="6-Loop-Aids-continue-and-break"><a href="#6-Loop-Aids-continue-and-break" class="headerlink" title="6. Loop Aids: continue and break"></a>6. Loop Aids: continue and break</h1><h2 id="1-The-continue-Statement"><a href="#1-The-continue-Statement" class="headerlink" title="(1) The continue Statement"></a>(1) The continue Statement</h2><p>The continue statement causes the program to <strong>skip over</strong> the rest of the loop, which is devoted to processing valid input. Instead, the program <strong>starts the next loop cycle</strong> by attempting to read the next input value. </p><p><strong>continue</strong> works for the while, do while, for, and not for the switch function.</p><p><strong>continue</strong> terminates the current loop, but not the entire loop.</p><pre><code class="hljs c"><span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">10</span>; count++)&#123;ch = getchar();<span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'\n'</span>)<span class="hljs-keyword">continue</span>;<span class="hljs-built_in">putchar</span>(ch);&#125;</code></pre><p>In this case, when the <strong>continue</strong> statement is executed, <strong>first count is incremented</strong> and then it’s compared to 10.</p><h2 id="2-The-break-Statement"><a href="#2-The-break-Statement" class="headerlink" title="(2) The break Statement"></a>(2) The break Statement</h2><p>A <strong>break</strong> statement in a loop causes the program to break free of the loop that encloses it and to proceed to the next stage of the program. </p><p>break works for while, do while, for and switch functions.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> i;  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  &#123;    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)    <span class="hljs-keyword">break</span>;  &#125;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %d\n"</span>,i);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>In this case, when the program executes the <strong>break</strong> statement, it breaks out of the for loop <strong>without adding i</strong>.  </p><h1 id="7-The-goto-Statement"><a href="#7-The-goto-Statement" class="headerlink" title="7. The goto Statement"></a>7. The goto Statement</h1><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &gt; <span class="hljs-number">12</span>)    <span class="hljs-keyword">goto</span> a;<span class="hljs-keyword">goto</span> b;a: cost = cost * <span class="hljs-number">1.05</span>;flag = <span class="hljs-number">2</span>;b: bill = cost * flag;</code></pre><p>It is the same as:</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &gt; <span class="hljs-number">12</span>)&#123;    cost = cost * <span class="hljs-number">1.05</span>;    flag = <span class="hljs-number">2</span>;&#125;bill = cost * flag;</code></pre><p>When a <strong>goto</strong> is encountered, it jumps unconditionally to the statement where the <strong>label</strong> is, and then <strong>executes sequentially from there</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operators, Expressions, and Statements</title>
    <link href="/2020/11/28/Operators-Expressions-and-Statements/"/>
    <url>/2020/11/28/Operators-Expressions-and-Statements/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 5 Operators, Expressions, and Statements</p><a id="more"></a><h1 id="1-Fundamental-Operators"><a href="#1-Fundamental-Operators" class="headerlink" title="1. Fundamental Operators"></a>1. Fundamental Operators</h1><h2 id="1-Assignment-Operator"><a href="#1-Assignment-Operator" class="headerlink" title="(1) Assignment Operator: ="></a>(1) Assignment Operator: =</h2><p>The <code>=</code> symbol is called the assignment operator.</p><h3 id="Some-Terminology-Data-Objects-Lvalues-Rvalues-and-Operands"><a href="#Some-Terminology-Data-Objects-Lvalues-Rvalues-and-Operands" class="headerlink" title="Some Terminology: Data Objects, Lvalues, Rvalues, and Operands"></a>Some Terminology: Data Objects, Lvalues, Rvalues, and Operands</h3><p>Consider an assignment statement. Its purpose is to store a value at a memory location.<br>&nbsp;<br><strong>Data object</strong> is a general term for a region of data storage that can be used to hold values.<br>&nbsp;<br>C uses the term <strong>lvalue</strong> to mean any such name or expression that identifies a particular data object. <strong>Object</strong> refers to the actual data storage, but an <strong>lvalue</strong> is a <strong>label</strong> used to identify, or locate, that storage.</p><p>The term <strong>rvalue</strong> refers to quantities that can be assigned to modifiable <strong>lvalues</strong> but which are not themselves lvalues. <strong>Rvalues</strong> can be constants, variables, or any other expression that yields a value. </p><h2 id="2-Division-Operator"><a href="#2-Division-Operator" class="headerlink" title="(2) Division Operator: /"></a>(2) Division Operator: /</h2><p>Division works differently for integer types than it does for floating types. Floating-type division gives a floating-point answer, but integer division yields an integer answer.</p><p>Integer division does not round to the nearest integer, but always truncates (that is, discards the entire fractional part).</p><pre><code class="hljs c"><span class="hljs-number">5</span>/<span class="hljs-number">2</span> = <span class="hljs-number">2</span><span class="hljs-number">-5</span>/<span class="hljs-number">2</span> = <span class="hljs-number">-2</span><span class="hljs-number">5</span>/(<span class="hljs-number">-2</span>) = <span class="hljs-number">-2</span></code></pre><h2 id="3-Modulus-Operator"><a href="#3-Modulus-Operator" class="headerlink" title="(3) Modulus Operator: %"></a>(3) Modulus Operator: %</h2><p>The modulus operator is used in <strong>integer arithmetic</strong>. It gives the remainder that results when the integer to its left is divided by the integer to its right. For example, 13 % 5 (read as “13 modulo 5”) has the value 3.</p><p>You get a negative modulus value if the first operand is negative, and you get a positive modulus otherwise.</p><pre><code class="hljs c"><span class="hljs-number">5</span>%<span class="hljs-number">2</span> = <span class="hljs-number">1</span><span class="hljs-number">-5</span>%<span class="hljs-number">2</span> = <span class="hljs-number">-1</span><span class="hljs-number">5</span>%(<span class="hljs-number">-2</span>) = <span class="hljs-number">1</span></code></pre><h2 id="4-Increment-and-Decrement-Operators-and-–"><a href="#4-Increment-and-Decrement-Operators-and-–" class="headerlink" title="(4) Increment and Decrement Operators: ++ and –"></a>(4) Increment and Decrement Operators: ++ and –</h2><p>The increment operator performs a simple task; it increments (increases) the value of its operand by 1. </p><pre><code class="hljs pgsql">a_post = a++; // postfix: a <span class="hljs-keyword">is</span> changed <span class="hljs-keyword">after</span> its <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> usedb_pre= ++b;// prefix: b <span class="hljs-keyword">is</span> changed <span class="hljs-keyword">before</span> its <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> used(a + b)++; //invalid</code></pre><p>You can get fooled if you try to do too much at once with the increment operators.</p><pre><code class="hljs c"><span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">21</span>)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%10d %10d\n"</span>, num, num*num++);&#125;</code></pre><p>In C, the compiler can choose which arguments in a function to evaluate first.</p><pre><code class="hljs c">ans = num/<span class="hljs-number">2</span> + <span class="hljs-number">5</span>*(<span class="hljs-number">1</span> + num++);</code></pre><p>You would think that it would find num/2 first and then move on, but it might do the last term first.</p><h2 id="5-The-Comma-Operator"><a href="#5-The-Comma-Operator" class="headerlink" title="(5) The Comma Operator"></a>(5) The Comma Operator</h2><p>First, it guarantees that the expressions it separates are evaluated in a <strong>left-to-right order</strong>.<br>Second, the <strong>value of the whole comma expression</strong> is the value of the <strong>right-hand member</strong>.</p><pre><code class="hljs c">x = (y = <span class="hljs-number">3</span>, (z = ++y + <span class="hljs-number">2</span>) + <span class="hljs-number">5</span>);<span class="hljs-comment">//x = (z = ++y + 2) + 5;</span></code></pre><h1 id="2-Operator-Precedence"><a href="#2-Operator-Precedence" class="headerlink" title="2. Operator Precedence"></a>2. Operator Precedence</h1><table><thead><tr><th align="center">Operators (decreasing precedence)</th><th align="center">Associativity</th></tr></thead><tbody><tr><td align="center">+ - (unary)</td><td align="center">Left to right</td></tr><tr><td align="center">* /</td><td align="center">Left to right</td></tr><tr><td align="center">+ - (binary)</td><td align="center">Left to right</td></tr><tr><td align="center">=</td><td align="center">Left to right</td></tr><tr><td align="center">,</td><td align="center">Left to right</td></tr></tbody></table><h1 id="3-Expressions-and-Statements"><a href="#3-Expressions-and-Statements" class="headerlink" title="3. Expressions and Statements"></a>3. Expressions and Statements</h1><h2 id="1-Expressions"><a href="#1-Expressions" class="headerlink" title="(1) Expressions"></a>(1) Expressions</h2><p>An expression consists of a combination of operators and operands.<br>&nbsp;<br>An important property of C is that every C expression has a value. </p><h2 id="2-Statements"><a href="#2-Statements" class="headerlink" title="(2) Statements"></a>(2) Statements</h2><p>Statements are the primary building blocks of a program. A program is a series of statements with some necessary punctuation. A statement is a complete instruction to the computer. In C, statements are indicated by a <strong>semicolon</strong> at the end. </p><h1 id="4-Type-Conversions"><a href="#4-Type-Conversions" class="headerlink" title="4. Type Conversions"></a>4. Type Conversions</h1><h2 id="1-Automatic-Type-Conversions"><a href="#1-Automatic-Type-Conversions" class="headerlink" title="(1) Automatic Type Conversions"></a>(1) Automatic Type Conversions</h2><ol><li>When appearing in an <strong>expression</strong>, <strong>char</strong> and <strong>short</strong>, both <strong>signed</strong> and <strong>unsigned</strong>, are <strong>automatically</strong> converted to <strong>int</strong> or, if necessary, to <strong>unsigned int</strong>. (If <strong>short</strong> is the same size as <strong>int</strong>, <strong>unsigned short</strong> is larger than <strong>int</strong>; in that case, <strong>unsigned short</strong> is converted to <strong>unsigned int</strong>.) Under <strong>K&amp;R</strong> C, but not under current C, <strong>float</strong> is automatically converted to <strong>double</strong>. Because they are conversions to larger types, they are called <strong>promotions</strong>.</li><li>In any <strong>operation</strong> involving <strong>two types</strong>, both values are converted to the <strong>higher ranking</strong> of the two types.</li><li>The <strong>ranking of types</strong>, from <strong>highest to lowest</strong>, is <strong>long double</strong>, <strong>double</strong>, <strong>float</strong>, <strong>unsigned long long</strong>, <strong>long long</strong>, <strong>unsigned long</strong>, <strong>long</strong>, <strong>unsigned int</strong>, and <strong>int</strong>. One possible <strong>exception</strong> is when <strong>long and int are the same size</strong>, in which case <strong>unsigned int</strong> outranks <strong>long</strong>. The <strong>short</strong> and <strong>char</strong> types don’t appear in this list because they would have been already promoted to int or perhaps <strong>unsigned int</strong>.</li><li>In an <strong>assignment statement</strong>, the final result of the calculations is converted to the type of <strong>the variable being assigned a value</strong>. This process can result in <strong>promotion</strong>, as described in rule 1, or <strong>demotion</strong>, in which a value is converted to a lower-ranking type.</li><li>When passed as <strong>function arguments</strong>, <strong>char</strong> and <strong>short</strong> are converted to <strong>int</strong>, and <strong>float</strong> is converted to <strong>double</strong>. This <strong>automatic promotion</strong> is overridden by function prototyping.</li></ol><h2 id="2-The-Cast-Operator"><a href="#2-The-Cast-Operator" class="headerlink" title="(2) The Cast Operator"></a>(2) The Cast Operator</h2><p>The parentheses and type name together constitute a cast operator.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>)<span class="hljs-number">1.6</span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Charater Strings and Formatted Input/Output</title>
    <link href="/2020/11/28/Charater-Strings-and-Formatted-Input-Output/"/>
    <url>/2020/11/28/Charater-Strings-and-Formatted-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 4 Charater Strings and Formatted Input/Output</p><a id="more"></a><h1 id="1-Character-Strings"><a href="#1-Character-Strings" class="headerlink" title="1. Character Strings"></a>1. Character Strings</h1><p> A character string is a series of one or more characters. </p><h2 id="1-Type-char-Arrays-and-the-Null-Character"><a href="#1-Type-char-Arrays-and-the-Null-Character" class="headerlink" title="(1) Type char Arrays and the Null Character"></a>(1) Type char Arrays and the Null Character</h2><p>C has no special variable type for strings. Instead, strings are stored in an array of type char. Characters in a string are stored in adjacent memory cells, one character per cell, and an array consists of adjacent memory locations.<br><img src="https://img-blog.csdnimg.cn/20190521222859479.png" srcset="/img/loading.gif" alt=""><br>The <strong>null character</strong> is not the digit zero; it is the nonprinting character whose <strong>ASCII</strong> code value (or equivalent) is <strong>0</strong>. Strings in C are always stored with this terminating null character. The presence of the null character means that the array must have <strong>at least one more cell</strong> than the number of characters to be stored. </p><h2 id="2-Using-Strings"><a href="#2-Using-Strings" class="headerlink" title="(2) Using Strings"></a>(2) Using Strings</h2><p>In general, <strong>scanf()</strong> is used with <strong>%s</strong> to read only a <strong>single word</strong>, not a whole phrase, as a string. C has other input-reading functions, such as <strong>fgets()</strong>, for handling general strings.</p><h2 id="3-Strings-Versus-Characters"><a href="#3-Strings-Versus-Characters" class="headerlink" title="(3) Strings Versus Characters"></a>(3) Strings Versus Characters</h2><p><img src="https://img-blog.csdnimg.cn/201905212249433.png" srcset="/img/loading.gif" alt="A word is the natural unit of memory for a given computer design.For 8-bit microcomputers,"></p><h1 id="2-The-strlen-Function"><a href="#2-The-strlen-Function" class="headerlink" title="2. The strlen() Function"></a>2. The strlen() Function</h1><p>The <strong>strlen()</strong> function gives the length of a string in characters.<br>The <strong>string.h</strong> file contains function prototypes for several string related functions, including <strong>strlen()</strong>.<br>&nbsp;<br>The <strong>strlen()</strong> gives you the exact number of characters (including spaces and punctuation) in the string. The <strong>sizeof</strong> operator gives you a number one <strong>larger</strong> because it also counts the <strong>invisible null character</strong> used to end the string.<br>&nbsp;<br>The <strong>C99</strong> and <strong>C11</strong> standards use a <strong>%zd</strong> specifier for the type used by the <strong>sizeof</strong> operator. This also applies for type returned by <strong>strlen()</strong>.<br>&nbsp;<br>The preceding chapter used <strong>sizeof</strong> with <strong>parentheses</strong>, but this example doesn’t. <strong>Parentheses</strong> are <strong>required for types</strong> but are <strong>optional for particular quantities</strong>. That is, you would use <strong>sizeof(char)</strong> or <strong>sizeof(float)</strong> but can use <strong>sizeof name</strong> or <strong>sizeof 6.28.</strong></p><h1 id="3-Constants-and-the-C-Preprocessor"><a href="#3-Constants-and-the-C-Preprocessor" class="headerlink" title="3. Constants and the C Preprocessor"></a>3. Constants and the C Preprocessor</h1><p>The <strong>preprocessor</strong> uses <strong>#include</strong> to incorporate information from another file, it also lets you define constants. Just add a line like the following at the top of the file containing your program:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TAXRATE 0.015</span></code></pre><p><strong>No semicolon</strong> is used because this is a substitution mechanism handled by the <strong>preprocessor</strong>, not a <strong>C</strong> statement.</p><h1 id="4-The-const-Modifier"><a href="#4-The-const-Modifier" class="headerlink" title="4. The const Modifier"></a>4. The const Modifier</h1><p><strong>C90</strong> added a second way to <strong>create symbolic constants</strong>—using the <strong>const</strong> keyword to convert a declaration for a <strong>variable</strong> into a declaration for a <strong>constant</strong>:</p><pre><code class="hljs c"><span class="hljs-comment">// MONTHS a symbolic constant for 12</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MONTHS = <span class="hljs-number">12</span>;</code></pre><p>This newer approach is more flexible than using <strong>#define</strong>; it lets you declare a type, and it allows better control over which parts of a program can use the constant.</p><h1 id="5-Manifest-Constants-on-the-Job"><a href="#5-Manifest-Constants-on-the-Job" class="headerlink" title="5. Manifest Constants on the Job"></a>5. Manifest Constants on the Job</h1><p>The C header files <strong>limits.h</strong> and <strong>float.h</strong> supply detailed information about the <strong>size limits</strong> of <strong>integer</strong> types and <strong>floating</strong> types, respectively. </p><h1 id="6-The-printf-Function"><a href="#6-The-printf-Function" class="headerlink" title="6. The printf() Function"></a>6. The printf() Function</h1><p>The instructions you give <strong>printf()</strong> when you ask it to print a variable depend on the variable type. </p><table><thead><tr><th align="left">Conversion</th><th align="left">Output Specification</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">Floating-point-number, hexadecimal digits and p-notation(C99/C11).</td></tr><tr><td align="left">%A</td><td align="left">Floating-point-number, hexadecimal digits and p-notation(C99/C11).</td></tr><tr><td align="left">%c</td><td align="left">Single character.</td></tr><tr><td align="left">%d</td><td align="left">Single decimal integer.</td></tr><tr><td align="left">%e</td><td align="left">Floating-point number, e-notation.</td></tr><tr><td align="left">%E</td><td align="left">Floating-point number, e-notation.</td></tr><tr><td align="left">%f</td><td align="left">Floating-point number, decimal notation.</td></tr><tr><td align="left">%g</td><td align="left">Using %f or %e, depending on the value. The %e style is used if the exponent is less than -4 or greater than or equal to the presion.</td></tr><tr><td align="left">%G</td><td align="left">Using %f or %E, depending on the value. The %E style is used if the exponent is less than -4 or greater than or equal to the presion.</td></tr><tr><td align="left">%i</td><td align="left">Single decimal integer(same as %d).</td></tr><tr><td align="left">%o</td><td align="left">Unsigned octal integer.</td></tr><tr><td align="left">%p</td><td align="left">A pointer.</td></tr><tr><td align="left">%s</td><td align="left">Character string.</td></tr><tr><td align="left">%u</td><td align="left">Unsigned decimal integer.</td></tr><tr><td align="left">%x</td><td align="left">Unsigned hexadecimal integer, using hex digits 0f.</td></tr><tr><td align="left">%X</td><td align="left">Unsigned hexadecimal integer, using hex digits 0F.</td></tr><tr><td align="left">%%</td><td align="left">Prints a percent sign.</td></tr></tbody></table><h2 id="1-Conversion-Specification-Modifiers-for-printf"><a href="#1-Conversion-Specification-Modifiers-for-printf" class="headerlink" title="(1) Conversion Specification Modifiers for printf()"></a>(1) Conversion Specification Modifiers for printf()</h2><table><thead><tr><th align="left">Modifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">flag</td><td align="left">Five flags:-,+,space,#, and 0.</td></tr><tr><td align="left">digit(s)</td><td align="left">The minimun field width. A wilder field will be used if the printed number or string won’t fit in the field.</td></tr><tr><td align="left">.digit(s)</td><td align="left">Presions. For %e, %E, and %f conversions, the maximun number of significant digits. For %g and %G conversions, the maximun number of significant digits. For %s conversion, the maximun number of characters to be printed. For integer conversions, the minimun number of digits to apper: leading zeros are used if necessary to meet this minimum. Using only . implies a following zero, so %.f is the same as %.0f.</td></tr><tr><td align="left">h</td><td align="left">Used with an integer conversion specifier to indicate a short int or unsigned short int value.</td></tr><tr><td align="left">hh</td><td align="left">Used with an integer conversion specifier to indicate a signed char or unsigned char value.</td></tr><tr><td align="left">j</td><td align="left">Used with an integer conversion specifier to indicate an intmax_t or uintmax_t value; these are types defined in stdint.h.</td></tr><tr><td align="left">l</td><td align="left">Used with an integer conversion specifier to indicate a long int or unsigned long int.</td></tr><tr><td align="left">ll</td><td align="left">Used with an integer conversion specifier to indicate a long long int or unsigned long long int.(C99).</td></tr><tr><td align="left">L</td><td align="left">Used with a floating-point conversion specifier to indicate a long double value.</td></tr><tr><td align="left">t</td><td align="left">Used with an integer conversion specifier to indicate a ptrdiff_t value. This is the type corresponding to the difference between two pointers. (C99).</td></tr><tr><td align="left">z</td><td align="left">Used with an integer conversion specifier to indicate a size_t value. This is the type returned by sizeof. (C99).</td></tr></tbody></table><h2 id="2-The-printf-Flags"><a href="#2-The-printf-Flags" class="headerlink" title="(2) The printf( ) Flags"></a>(2) The printf( ) Flags</h2><table><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">The item is left-justified; that is, it is printed begining at the left of the field.</td></tr><tr><td align="left">+</td><td align="left">Signed values are displayed with a plus sign, if positive, and with a minus sign, if negative.</td></tr><tr><td align="left">space</td><td align="left">Signed values are displayed with a  leading space (but no sign) if positive and with a minus sign if negative. A + flag overrides a space.</td></tr><tr><td align="left">#</td><td align="left">Used  an alternative form for the conversion specification. Produces an initial 0 for the %o form and initial 0x for the %x or %X form, respectively. For all floating-point forms, # gurantees that a decimal-point character is printed, even if no digits follow. For %g and %G forms, it prevents traing zeros form being removed.</td></tr><tr><td align="left">0</td><td align="left">For numeric forms, pad the field width with leading zeros indtead of with spaces. This flag is ignored if a - flag is present or if, for an integer form, a precision is specified.</td></tr></tbody></table><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">float</span> f = <span class="hljs-number">321454.321345</span>;   <span class="hljs-keyword">float</span> f1 = <span class="hljs-number">12.2345678</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %04f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %06.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %6.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %-6.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"321454.321345 = %7f\n"</span>,f);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"321454.321345 = %7.3f\n"</span>,f);    <span class="hljs-keyword">int</span> n1 = <span class="hljs-number">3456</span>;  <span class="hljs-keyword">int</span> n2  = <span class="hljs-number">1</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3456 = %3.2d\n"</span>,n1);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3456 = %6.2d\n\n"</span>,n1);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 = %.4d\n"</span>,n2);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 = %3.2d\n\n"</span>,n2);    <span class="hljs-comment">//测试字符串宽度精度</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %9.3s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %9s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %3s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Output：</p><pre><code class="hljs c"><span class="hljs-number">2.3</span> = <span class="hljs-number">2.300000</span> <span class="hljs-comment">//%04f：输出宽度至少4，精度不限制时用默认的，浮点数默认精度6位，这里宽度指总的宽度（包括小数点和小数点后面的数）</span><span class="hljs-number">2.3</span> = <span class="hljs-number">002.30</span> <span class="hljs-comment">//%06.2f： 总共宽度至少6位，精度2位，因此左边补0</span><span class="hljs-number">2.3</span> =   <span class="hljs-number">2.30</span> <span class="hljs-comment">//%6.2f：总共宽度至少6位，精度2位，左边空两格，默认右对齐</span><span class="hljs-number">2.3</span> = <span class="hljs-number">2.30</span> <span class="hljs-comment">// %-6.2f：总共宽度至少6位，精度2位，右边空两格，加-号左对齐</span><span class="hljs-number">321454.321345</span> = <span class="hljs-number">321454.312500</span><span class="hljs-number">321454.321345</span> = <span class="hljs-number">321454.312</span><span class="hljs-number">3456</span> = <span class="hljs-number">3456</span>  <span class="hljs-comment">//%3.2d ，总宽度至少3</span><span class="hljs-number">3456</span> =   <span class="hljs-number">3456</span>  <span class="hljs-comment">//%6.2d ，总宽度至少6</span><span class="hljs-number">1</span> = <span class="hljs-number">0001</span> <span class="hljs-comment">//%.4d 有效位4位，只有1位，其余补0</span><span class="hljs-number">1</span> =  <span class="hljs-number">01</span>  <span class="hljs-comment">//%3.2d 总宽度3，有效位2，因此左边空1格，补一个0</span><span class="hljs-string">"printf"</span> =        pri <span class="hljs-comment">// %9.3s 总宽度至少9，有效3位，因此只现实3个字符</span><span class="hljs-string">"printf"</span> =    <span class="hljs-built_in">printf</span>  <span class="hljs-comment">// %9s，总宽度至少9，宽度9</span><span class="hljs-string">"printf"</span> = <span class="hljs-built_in">printf</span>   <span class="hljs-comment">// %3s，总宽度至少3，因此宽度为6</span></code></pre><h2 id="3-The-Return-Value-of-printf"><a href="#3-The-Return-Value-of-printf" class="headerlink" title="(3) The Return Value of printf()"></a>(3) The Return Value of printf()</h2><p>The <strong>printf()</strong> function also has a return value; it returns the <strong>number of characters</strong> it printed. </p><h2 id="4-Printing-Long-Strings"><a href="#4-Printing-Long-Strings" class="headerlink" title="(4) Printing Long Strings"></a>(4) Printing Long Strings</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's one way to print a "</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"long string.\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's another way to print a \</span><span class="hljs-string">long string.\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's the newest way to print a "</span><span class="hljs-string">"long string.\n"</span>); <span class="hljs-comment">/* ANSI C */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Method 1 is to use more than one <strong>printf()</strong> statement.<br>Method 2 is to terminate the end of the first line with a backslash/return combination.<br>Method 3, which ANSI C introduced, is <strong>string concatenation</strong>. If you follow one <strong>quoted</strong> string constant with another, separated only by <strong>whitespace</strong>, C treats the combination as a <strong>single string</strong>. </p><h1 id="7-scanf"><a href="#7-scanf" class="headerlink" title="7. scanf()"></a>7. scanf()</h1><p>It converts string input into various forms: integers, floating-point numbers, characters, and C strings.<br>&nbsp;<br>Rules:</p><blockquote><ul><li>If you use <strong>scanf()</strong> to read a value for one of the basic variable types, precede the variable name with an <strong>&amp;</strong>.</li><li>If you use <strong>scanf()</strong> to read a string into a <strong>character array</strong>, don’t use an <strong>&amp;</strong>.</li></ul></blockquote><h2 id="1-Conversion-Specifiers-for-scanf"><a href="#1-Conversion-Specifiers-for-scanf" class="headerlink" title="(1) Conversion Specifiers for scanf()"></a>(1) Conversion Specifiers for scanf()</h2><p>The <strong>scanf()</strong> function uses pretty much the same set of conversion specification characters as <strong>printf()</strong> does. The main difference is that <strong>printf()</strong> uses %f, %e, %E, %g, and %G for both type float and type double, whereas <strong>scanf()</strong> uses them just for type float, requiring the <strong>l</strong> modifier for double. </p><table><thead><tr><th align="left">Conversion Specifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">%c</td><td align="left">Interpret input as a character.</td></tr><tr><td align="left">%d</td><td align="left">Interpret input as a signed decimal integer.</td></tr><tr><td align="left">%e, %f, %g, %a</td><td align="left">Interpret input as a floating-point number (%a is C99).</td></tr><tr><td align="left">%E, %F, %G, %A</td><td align="left">Interpret input as a floating-point number (%A is C99).</td></tr><tr><td align="left">%i</td><td align="left">Interpret input as a signed decimal integer.</td></tr><tr><td align="left">%o</td><td align="left">Interpret input as a signed Octal integer.</td></tr><tr><td align="left">%p</td><td align="left">Intepret input as a pointer (an address).</td></tr><tr><td align="left">%s</td><td align="left">Intepret input as a string. Input begins with the first non-whitespace character and includes evertything up to the next whitespace character.</td></tr><tr><td align="left">%u</td><td align="left">Interpret input as a unsigned decimal integer.</td></tr><tr><td align="left">%x, %X</td><td align="left">Interpret input as a signed hexadecimal integer.</td></tr></tbody></table><h2 id="2-Conversion-Modifiers-for-scanf"><a href="#2-Conversion-Modifiers-for-scanf" class="headerlink" title="(2) Conversion Modifiers for scanf()"></a>(2) Conversion Modifiers for scanf()</h2><table><thead><tr><th align="left">Modifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">Suppress assignment.</td></tr><tr><td align="left">digit(s)</td><td align="left">Maximum field width. Input stops when the maximum field width is reached or when the first whitespace character is encountered, whichever comes first.</td></tr><tr><td align="left">hh</td><td align="left">Read an integer as a signed char or unsigned char.</td></tr><tr><td align="left">ll</td><td align="left">Read an integer as a long long or unsigned long long (C99).</td></tr><tr><td align="left">h, l or L</td><td align="left">“%hd” and “%hi” indicate that the value will be stored in a <strong>short int</strong>. “%ho”, “%hx”, and “%hu” indicate that the value will be stored in an <strong>unsigned short int</strong>. “%ld” and “%li” indicate that the value will be stored in a <strong>long</strong>. “%lo”, “%lx”, and “%lu” indicate that the value will be stored in <strong>unsigned long</strong>. “%le”, “%lf”, and “%lg” indicate that the value will be stored in type <strong>double</strong>. Using L instead of l with e, f, and g indicates that the value will be stored in type <strong>long double</strong>. In the absence of these modifiers, d, i, o, and x indicate type <strong>int</strong>, and e, f, and g indicate type <strong>float</strong>.</td></tr><tr><td align="left">j</td><td align="left">When followed by an integer specifier, indicates using the intmax_t or uintmax_t type (C99).</td></tr><tr><td align="left">z</td><td align="left">When followed by an integer specifier, indicates using the type returned by sizeof (C99).</td></tr><tr><td align="left">t</td><td align="left">When followed by an integer specifier, indicates using the type used to represent the difference between two pointers (C99).</td></tr></tbody></table><h2 id="3-The-scanf-View-of-Input"><a href="#3-The-scanf-View-of-Input" class="headerlink" title="(3) The scanf() View of Input"></a>(3) The scanf() View of Input</h2><p>It skips over whitespace characters (spaces, tabs, and newlines) until it finds a non-whitespace character. scanf() continues reading and saving characters until it encounters a nondigit. </p><p>&nbsp;<br>If you use a <strong>%c</strong> specifier, all input characters are fair game. If the next input character is a space or a newline, a space or a newline is assigned to the indicated variable; <strong>whitespace is not skipped</strong>.</p><h2 id="4-The-scanf-Return-Value"><a href="#4-The-scanf-Return-Value" class="headerlink" title="(4) The scanf() Return Value"></a>(4) The scanf() Return Value</h2><p>The <strong>scanf()</strong> function returns <strong>the number of items</strong> that it successfully reads. If it reads no items, which happens if you type a nonnumeric string when it expects a number, <strong>scanf()</strong> returns the value 0. It returns <strong>EOF</strong> when it detects the condition known as “end of file.” </p><h1 id="8-The-Modifier-with-printf-and-scanf"><a href="#8-The-Modifier-with-printf-and-scanf" class="headerlink" title="8. The * Modifier with printf() and scanf()"></a>8. The * Modifier with printf() and scanf()</h1><h2 id="1-The-Modifier-with-printf"><a href="#1-The-Modifier-with-printf" class="headerlink" title="(1) The * Modifier with printf()"></a>(1) The * Modifier with printf()</h2><p>Suppose that you don’t want to commit yourself to a field width in advance but rather you want the program to specify it. You can do this by using <code>*</code> instead of a number for the field width, but you also have to add an argument to tell what the field width should be.<br>&nbsp;<br>That is, if you have the conversion specifier <code>%*d</code>, the argument list should include a value for <code>*</code> and a value for <code>d</code>. </p><h2 id="2-The-Modifier-with-scanf"><a href="#2-The-Modifier-with-scanf" class="headerlink" title="(2) The * Modifier with scanf()"></a>(2) The * Modifier with scanf()</h2><p>The <code>*</code> serves quite a different purpose for <strong>scanf()</strong>. When placed between the <code>%</code> and the specifier letter, it causes that function to <strong>skip over corresponding input</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data and C</title>
    <link href="/2020/11/24/Data-and-C/"/>
    <url>/2020/11/24/Data-and-C/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 3 Data and C</p><a id="more"></a><h1 id="1-Bits-Bytes-and-Words"><a href="#1-Bits-Bytes-and-Words" class="headerlink" title="1. Bits, Bytes, and Words"></a>1. Bits, Bytes, and Words</h1><h2 id="1-Bit"><a href="#1-Bit" class="headerlink" title="(1) Bit"></a>(1) Bit</h2><p>The smallest unit of memory is called a <strong>bit</strong>. It can hold one of two values: 0 or 1.</p><h2 id="2-Byte"><a href="#2-Byte" class="headerlink" title="(2) Byte"></a>(2) Byte</h2><p><strong>byte</strong> is the usual unit of computer memory. For nearly all machines, a byte is 8 bits, and that is the standard definition, at least when used to measure storage.<br>&nbsp;<br>Because each bit can be either 0 or 1, there are 256 (that’s 2 times itself 8 times) possible bit patterns of 0s and 1s that can fit in an 8-bit byte.</p><h2 id="3-Word"><a href="#3-Word" class="headerlink" title="(3) Word"></a>(3) Word</h2><p>A <strong>word</strong> is the natural unit of memory for a given computer design.<br>&nbsp;<br>For 8-bit microcomputers, such as the original Apples, a word is just 8 bits. Since then, personal computers moved up to 16-bit words, 32-bit words, and, at the present, 64-bit words. Larger word sizes enable faster transfer of data and allow more memory to be accessed.</p><h1 id="2-Integer-Versus-Floating-Point-Types"><a href="#2-Integer-Versus-Floating-Point-Types" class="headerlink" title="2. Integer Versus Floating-Point Types"></a>2. Integer Versus Floating-Point Types</h1><h2 id="1-The-Integer"><a href="#1-The-Integer" class="headerlink" title="(1) The Integer"></a>(1) The Integer</h2><p>An <strong>integer</strong> is a number with no fractional part.</p><h2 id="2-The-Floating-Point-Number"><a href="#2-The-Floating-Point-Number" class="headerlink" title="(2) The Floating-Point Number"></a>(2) The Floating-Point Number</h2><p>A <strong>floating-point</strong> number more or less corresponds to what mathematicians call a real number.<br>&nbsp;<br>The key point here is that the scheme used to store a floating-point number is different from the one used to store an integer. <strong>Floating-point representation involves breaking up a number into a fractional part and an exponent part and storing the parts separately</strong>.<br>&nbsp;<br>For some arithmetic operations, such as subtracting one large number from another, floating-point numbers are subject to greater <strong>loss of precision</strong>. Because there is an infinite number of real numbers in any range，For example, 7.0 might be stored as a 6.99999 float value.</p><h1 id="3-Basic-C-Data-Types"><a href="#3-Basic-C-Data-Types" class="headerlink" title="3. Basic C Data Types"></a>3. Basic C Data Types</h1><h2 id="1-The-int-Type"><a href="#1-The-int-Type" class="headerlink" title="(1) The int Type"></a>(1) The int Type</h2><p>The <strong>int</strong> type is a signed integer. That means it must be an integer and it can be positive, negative, or zero.</p><h3 id="Octal-and-Hexadecimal"><a href="#Octal-and-Hexadecimal" class="headerlink" title="Octal and Hexadecimal"></a>Octal and Hexadecimal</h3><p>A prefix of <strong>0x</strong> or <strong>0X</strong> (zero-ex) means that you are specifying a <strong>hexadecimal</strong> value, so 16 is written as 0x10, or 0X10.<br>&nbsp;<br>A <strong>0</strong> (zero) prefix means that you are writing in <strong>octal</strong>. For example, the decimal value 16 is written as 020 in <strong>octal</strong>.</p><h3 id="Other-Integer-Types"><a href="#Other-Integer-Types" class="headerlink" title="Other Integer Types"></a>Other Integer Types</h3><p>C offers three adjective keywords to modify the basic integer type: <strong>short</strong>, <strong>long</strong>, and <strong>unsigned</strong>.<br>&nbsp;<br>To cause a small constant to be treated as type long, you can append an <strong>l</strong> (lowercase <strong>L</strong>) or <strong>L</strong> as a <strong>suffix</strong>. </p><p>Add a <strong>u</strong> or <strong>U</strong> to the <strong>suffix</strong> for <strong>unsigned long long</strong>, as in <code>5ull</code> or <code>10LLU</code> .<br>&nbsp;<br>Note that the <strong>short</strong> variable end is displayed the same whether you tell <strong>printf()</strong> that end is a <strong>short</strong> (the <strong>%hd</strong> specifier) or an <strong>int</strong> (the <strong>%d</strong> specifier). </p><p><strong>That’s because C automatically expands a type short value to a type int value when it’s passed as an argument to a function</strong>.</p><p><strong>The int type is intended to be the integer size that the computer handles most efficiently</strong>.</p><h2 id="2-Using-Characters-Type-char"><a href="#2-Using-Characters-Type-char" class="headerlink" title="(2) Using Characters: Type char"></a>(2) Using Characters: Type char</h2><p>The <strong>char</strong> type is used for storing characters such as <strong>letters</strong> and <strong>punctuation marks</strong>, but technically it is an <strong>integer</strong> type.<br>&nbsp;<br>To handle characters, the computer uses a <strong>numerical code</strong> in which certain integers represent certain characters. </p><p>The most commonly used code in the U.S. is the <code>ASCII</code> code.<br>&nbsp;<br>The standard <code>ASCII</code> code runs numerically from 0 to 127. This range is small enough that 7 bits can hold it. The char type is typically defined as an 8-bit unit of memory.<br>&nbsp;<br><strong>Character Constants and Initialization</strong>：A single character contained between single quotes is a C character constant.<br>&nbsp;<br>Because characters are really stored as numeric values, you can also use the numerical code to assign values:</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> grade = <span class="hljs-number">65</span>; <span class="hljs-comment">/* ok for ASCII, but poor style */</span></code></pre><p>Because 65 is the <code>ASCII</code> code for the letter <code>A</code>, this example assigns the value <code>A</code> to grade.<br>&nbsp;<br>C treats character constants as type <code>int</code> rather than type <code>char</code>. For example, on an <code>ASCII</code> system with a 32-bit int and an 8-bit char, the code.</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> grade = <span class="hljs-string">'B'</span>;</code></pre><p><strong>represents ‘B’ as the numerical value 66 stored in a 32-bit unit, but grade winds up with 66 stored in an 8-bit unit.</strong> </p><p>This characteristic of character constants makes it possible to define a character constant such as <code>&#39;FATE&#39;</code>, with four separate 8-bit <code>ASCII</code> codes stored in a 32-bit unit.</p><p>However, attempting to assign such a character constant to a char variable results in only the <strong>last 8 bits</strong> being used, so the variable gets the value <code>&#39;E&#39;</code>.</p><p><strong>Nonprinting Characters</strong><br>The first way we have already mentioned—just use the <code>ASCII</code> code.<br>&nbsp;<br>The second way to represent certain awkward characters in C is to use special symbol sequences. These are called <strong>escape sequences</strong>. </p><table><thead><tr><th align="left">Sequence</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">\a</td><td align="left">Aleart(ANSI C)</td></tr><tr><td align="left">\b</td><td align="left">Backspace</td></tr><tr><td align="left">\f</td><td align="left">Form feed</td></tr><tr><td align="left">\n</td><td align="left">Newline</td></tr><tr><td align="left">\r</td><td align="left">Carrigae return</td></tr><tr><td align="left">\t</td><td align="left">Horizontal tab</td></tr><tr><td align="left">\v</td><td align="left">Vertical tab</td></tr><tr><td align="left">\</td><td align="left">Backslash()</td></tr><tr><td align="left">&#39;</td><td align="left">Single quote(‘)</td></tr><tr><td align="left">&quot;</td><td align="left">Double quote(“)</td></tr><tr><td align="left">?</td><td align="left">Question mark(?)</td></tr><tr><td align="left">\0oo</td><td align="left">Octal value (o represents an octal digit.)</td></tr><tr><td align="left">\0hh</td><td align="left">Hexadecimal value (h represents a hexadecimal digit.)</td></tr></tbody></table><p>To represent alert character (<code>\a</code>), you could use the <code>ASCII</code> code instead: <code>&#39;007&#39;</code>. You can omit the leading zeros, so <code>&#39;\07&#39;</code> or even <code>&#39;\7&#39;</code>will do. This notation causes numbers to be interpreted as octal, even if there is no initial 0.</p><p><strong>Note:</strong> When a character, be it an <strong>escape sequence or not</strong>, is part of a string of characters enclosed in double quotes, <strong>don’t enclose it in single quotes</strong>.</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello!\007\n"</span>);</code></pre><p>will print </p><pre><code class="hljs c">Hello! <span class="hljs-keyword">and</span> <span class="hljs-built_in">beep</span></code></pre><h2 id="3-The-Bool-Type"><a href="#3-The-Bool-Type" class="headerlink" title="(3) The _Bool Type"></a>(3) The _Bool Type</h2><p>C uses the value $1$ for <strong>true</strong> and $0$ for <strong>false</strong>, the <strong>_Bool</strong> type really is just an <strong>integer</strong> type, but one that, in principle, only requires 1 bit of memory, because that is enough to cover the full range from $0$ to $1$.</p><h2 id="4-Portable-Types-stdint-h-and-inttypes-h"><a href="#4-Portable-Types-stdint-h-and-inttypes-h" class="headerlink" title="(4) Portable Types: stdint.h and inttypes.h"></a>(4) Portable Types: stdint.h and inttypes.h</h2><p>The same type name doesn’t necessarily mean the same thing on different systems, What C has done is create more names for the existing types. The trick is to define these new names in a header file called <strong>stdint.h</strong>. </p><p>For example, <code>int32_t</code> represents the type for a <strong>32-bit signed integer</strong>. The header file on a system that uses a 32-bit int could define <code>int32_t</code> as an <strong>alias for int</strong>. A different system, one with a 16-bit int and a 32-bit long, could define the same name, <code>int32_t</code>, as an <strong>alias for int</strong>. </p><h2 id="5-Types-float-double-and-long-double"><a href="#5-Types-float-double-and-long-double" class="headerlink" title="(5) Types float, double, and long double"></a>(5) Types float, double, and long double</h2><p>Here are two <strong>valid floating-point constants</strong>:</p><pre><code class="hljs angelscript"><span class="hljs-number">-1.56E+12</span><span class="hljs-number">3.14159</span><span class="hljs-number">.2</span><span class="hljs-number">4e16</span><span class="hljs-number">.8E-5</span><span class="hljs-number">100.</span></code></pre><p><strong>Rules:</strong></p><ul><li>You can leave out positive signs. </li><li>You can do without a <strong>decimal point</strong> (2E5) or an <strong>exponential part</strong> (19.28), but <strong>not both simultaneously</strong>. </li><li>You can <strong>omit a fractional part</strong> (3.E16) or <strong>an integer<br>part</strong> (.45E–6), but <strong>not both</strong> (that wouldn’t leave much!). </li><li>Don’t use spaces in a floating-point constant.</li></ul><p>By default, the compiler assumes <strong>floating-point constants</strong> are <strong>double</strong> precision.</p><p>C enables you to <strong>override</strong> this default by using an <strong>f</strong> or <strong>F</strong> <strong>suffix</strong> to make the compiler treat a <strong>floating-point</strong> constant as type <strong>float</strong>; examples are <code>2.3f</code> and <code>9.11E9F</code>. </p><p>An <strong>l</strong> or <strong>L</strong> <strong>suffix</strong> makes a number type <strong>long double</strong>; examples are <code>54.3l</code> and <code>4.32e4L</code>. </p><p>If the floating-point number has <strong>no suffix</strong>, it is type <strong>double</strong>.</p><h1 id="4-Format-Specifier"><a href="#4-Format-Specifier" class="headerlink" title="4. Format Specifier"></a>4. Format Specifier</h1><p>It indicates the form that <strong>printf()</strong> uses to display a value.</p><h2 id="1-d"><a href="#1-d" class="headerlink" title="(1) %d"></a>(1) %d</h2><p><strong>%d</strong> notation is used to indicate just where in a line the <strong>integer</strong> is to be printed.  <strong>d means decimal</strong><br>&nbsp;<br>Each <strong>%d</strong> in the format string must be matched by a corresponding <strong>int</strong> value in the list of items to be printed. </p><h2 id="2-Printing-short-long-long-long-and-unsigned-Types"><a href="#2-Printing-short-long-long-long-and-unsigned-Types" class="headerlink" title="(2) Printing short, long, long long, and unsigned Types"></a>(2) Printing short, long, long long, and unsigned Types</h2><p>To print an <strong>unsigned int</strong> number, use the <strong>%u</strong> notation. To print a <strong>long</strong> value, use the <strong>%ld</strong> format specifier.<br>&nbsp;<br>Note that although C allows both <strong>uppercase</strong> and <strong>lowercase</strong> letters for <strong>constant suffixes</strong>, these format specifiers use just <strong>lowercase</strong>.<br>&nbsp;<br>C has several additional <strong>printf()</strong> formats. First, you can use an <strong>h</strong> <strong>prefix</strong> for <strong>short</strong> types. Therefore, <strong>%hd</strong> displays a <strong>short integer</strong> in <strong>decimal</strong> form, and <strong>%ho</strong> displays a <strong>short integer in octal form</strong>. Both the <strong>h</strong> and <strong>l</strong> <strong>prefixes</strong> can be used with <strong>u</strong> for <strong>unsigned</strong> types. </p><h2 id="3-c"><a href="#3-c" class="headerlink" title="(3) %c"></a>(3) %c</h2><p>The <strong>printf()</strong> function uses <strong>%c</strong> to indicate that a <strong>character</strong> should be printed. </p><h2 id="4-Printing-Floating-Point-Values"><a href="#4-Printing-Floating-Point-Values" class="headerlink" title="(4) Printing Floating-Point Values"></a>(4) Printing Floating-Point Values</h2><p>The <strong>printf()</strong> function uses the <strong>%f</strong> format specifier to print type <strong>float</strong> and <strong>double</strong> numbers using <strong>decimal</strong> notation, and it uses <strong>%e</strong> to print them in <strong>exponential</strong> notation. </p><table><thead><tr><th align="left">Format</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">%f</td><td align="left"><strong>decimal</strong> notation(float, double)</td></tr><tr><td align="left">%e</td><td align="left"><strong>exponential</strong> notation(float, double)</td></tr><tr><td align="left">%a, %A</td><td align="left"><strong>hexadecimal p</strong> notation(float,double)</td></tr><tr><td align="left">%Lf, %Le, %La</td><td align="left"><strong>decimal</strong>, <strong>exponential</strong>, <strong>hexadecimal p</strong> notation(long double)</td></tr></tbody></table><h1 id="5-Type-Sizes"><a href="#5-Type-Sizes" class="headerlink" title="5. Type Sizes"></a>5. Type Sizes</h1><p>What type sizes does your system use?</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type int has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type char has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type long has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>));&#125;<span class="hljs-comment">//C has a built-in operator called sizeof that gives sizes in bytes. C99 and C11 provide a %zd specifier for this type used by sizeof.</span></code></pre><p>answer</p><pre><code class="hljs routeros">Type int has a size of 4 bytes.Type char has a size of 1 bytes.Type long has a size of 8 bytes.</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
