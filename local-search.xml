<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>File Input/Output</title>
    <link href="/2020/12/06/File-Input-Output/"/>
    <url>/2020/12/06/File-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 13 File Input/Output</p><a id="more"></a><h1 id="1-Communicating-with-Files"><a href="#1-Communicating-with-Files" class="headerlink" title="1. Communicating with Files"></a>1. Communicating with Files</h1><h2 id="1-File"><a href="#1-File" class="headerlink" title="(1) File"></a>(1) File</h2><p>A <strong>file</strong> is a named section of storage, usually on a disk, or, more recently, on a solid-state device.</p><p>C views a <strong>file</strong> as a continuous sequence of bytes, each of which can be read individually. C provides two ways to view files: the <strong>text view</strong> and the <strong>binary view</strong>.</p><p>All file content is in <strong>binary form</strong> (zeros and ones). But if a file primarily uses the <strong>binary codes</strong> for <strong>characters</strong> (for instance, <strong>ASCII</strong> or <strong>Unicode</strong>) to represent <strong>text</strong>, much as a <strong>C string</strong> does, then it is a <strong>text file</strong>; it has text content. </p><p>If the <strong>binary values</strong> in the file represent <strong>machinelanguage code</strong> or <strong>numeric data</strong> (using the same internal representation as, say, used for long or double values) or image or music encoding, the content is <strong>binary</strong>.</p><p>To bring some regularity to the handling of text files, C provides two ways of accessing a file: <strong>binary mode</strong> and <strong>text mode</strong>. </p><p>In the <strong>binary mode</strong>, each and every byte of the file is accessible to a program. </p><p>In the <strong>text mode</strong>, however, what the program sees can differ from what is in the file. </p><p>For example, a C program compiled on an older Macintosh and using text mode would convert \r to \n when reading a file in text mode and convert \n to \r when writing to a file. </p><h2 id="2-Standard-Files"><a href="#2-Standard-Files" class="headerlink" title="(2) Standard Files"></a>(2) Standard Files</h2><p>C programs automatically open three files on your behalf. They are termed the <strong>standard input</strong>, the <strong>standard output</strong>, and the <strong>standard error output</strong>. </p><p>The <strong>standard input</strong>, by default, is the normal input device for your system, usually your keyboard. Both the <strong>standard output</strong> and the <strong>standard error output</strong>, by default, are the normal output device for your system, usually your display screen.</p><p>The purpose of the <strong>standard error output</strong> file is to provide a logically distinct place to send error messages. If, for example, you use redirection to send output to a file instead of to the screen, output sent to the standard error output still goes to the screen. </p><h1 id="2-Standard-I-O"><a href="#2-Standard-I-O" class="headerlink" title="2. Standard I/O"></a>2. Standard I/O</h1><p>The <strong>standard I/O package</strong> has two advantages, besides <strong>portability</strong>, over low-level I/O. </p><p>First, it has many specialized functions that simplify handling different I/O problems. For example,<br>printf() converts various forms of data to string output suitable for terminals. </p><p>Second, input and output are <strong>buffered</strong>. That is, information is transferred in large chunks (typically 512 bytes at a time or more) instead of a byte at a time. </p><h2 id="1-The-fopen-Function"><a href="#1-The-fopen-Function" class="headerlink" title="(1) The fopen() Function"></a>(1) The fopen() Function</h2><p>The program uses <strong>fopen()</strong> to open the file. This function is declared in <strong>stdio.h</strong>. </p><p>Its <strong>first argument</strong> is the name of the file to be opened; more exactly, it is the address of a string containing that name. The <strong>second argument</strong> is a string identifying the <strong>mode</strong> in which the file is to be opened.</p><table><thead><tr><th align="left">Mode String</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">“r”</td><td align="left"></td></tr><tr><td align="left">“w”</td><td align="left">Open a text file for writing, truncating an existing file to zero length, or creating the file if it does not exist.</td></tr><tr><td align="left">“a”</td><td align="left">Open a text file for writing, appending to the end of an existing file, or creating the file if it does not exist.</td></tr><tr><td align="left">“r+”</td><td align="left">Open a text file for update (that is, for both reading and writing).</td></tr><tr><td align="left">“w+</td><td align="left">Open a text file for update (reading and writing), first truncating the file to zero length if it exists or creating the file if it does not exist.</td></tr><tr><td align="left">“a+</td><td align="left">Open a text file for update (reading and writing), appending to the end of an existing file, or creating the file if it does not yet exist; the whole file can be read, but writing can only be appended.</td></tr><tr><td align="left">“rb”, “wb”, “ab”, “ab+”, “a+b”, “wb+”, “w+b”, “ab+”, “a+b”</td><td align="left">Like the preceding modes, except they use binary mode instead of text mode.</td></tr><tr><td align="left">“wx”, “wbx”, “w+x”, “wb+x” or “w+bx”</td><td align="left">(C11) Like the non-x modes, except they fail if the file already exists and they open a file in exclusive mode, if possible.</td></tr></tbody></table><p>After your program successfully opens a file, <strong>fopen()</strong> returns a <strong>file pointer</strong>, which the other I/O functions can then use to specify the file. The file pointer is of type <strong>pointer-to-FILE</strong>. The pointer points to a <strong>data object</strong> containing information about the file, including information about the buffer used for the file’s I/O. </p><p>The <strong>fopen()</strong> function returns the <strong>null pointer</strong> (also defined in stdio.h) if it cannot open the file. </p><h2 id="2-The-getc-and-putc-Functions"><a href="#2-The-getc-and-putc-Functions" class="headerlink" title="(2) The getc() and putc() Functions"></a>(2) The getc() and putc() Functions</h2><p>The two functions <strong>getc()</strong> and <strong>putc()</strong> work very much like <strong>getchar()</strong> and <strong>putchar()</strong>. The difference is that you must tell these newcomers <strong>which file to use</strong>. </p><pre><code class="hljs c">ch = getchar();<span class="hljs-comment">//get a character from the file identified by fp</span>ch = getc(fp);</code></pre><pre><code class="hljs c"><span class="hljs-comment">//put the character ch into the file identified by the FILE pointer fpout</span>putc(ch, fpout);</code></pre><p><code>putc(ch,stdout)</code> is the same as <code>putchar(ch)</code>. </p><h2 id="3-End-of-File"><a href="#3-End-of-File" class="headerlink" title="(3) End-of-File"></a>(3) End-of-File</h2><p>The <strong>getc()</strong> function returns the special value <strong>EOF</strong> if it tries to read a character and discovers it has reached the end of the file. So a C program discovers it has reached the end of a file only after it tries to read past the end of the file. </p><h2 id="4-The-fclose-Function"><a href="#4-The-fclose-Function" class="headerlink" title="(4) The fclose() Function"></a>(4) The fclose() Function</h2><p>The <strong>fclose(fp)</strong> function closes the file identified by <code>fp</code>, flushing buffers as needed. </p><p>The function <strong>fclose()</strong> returns a value of <strong>0</strong> if successful, and <strong>EOF</strong> if not:</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fclose(fp) != <span class="hljs-number">0</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error in closing file %s\n"</span>, argv[<span class="hljs-number">1</span>]);</code></pre><p>The <strong>fclose()</strong> function can fail if, for example, the disk is full, a removable storage device has been removed, or there has been an I/O error.</p><h2 id="5-Pointers-to-the-Standard-Files"><a href="#5-Pointers-to-the-Standard-Files" class="headerlink" title="(5) Pointers to the Standard Files"></a>(5) Pointers to the Standard Files</h2><p>The <strong>stdio.h</strong> file associates three file pointers with the three standard files automatically opened by C programs:</p><table><thead><tr><th align="left">Standard File</th><th align="left">File Pointer</th><th align="left">Normally</th></tr></thead><tbody><tr><td align="left">Standard input</td><td align="left">stdin</td><td align="left">Your keyboard</td></tr><tr><td align="left">Standard output</td><td align="left">stdout</td><td align="left"></td></tr><tr><td align="left">Standard error</td><td align="left">stderr</td><td align="left">Your screen</td></tr></tbody></table><p>These pointers are all type <strong>pointer-to-FILE</strong>, so they can be used as arguments to the <strong>standard I/O functions</strong>.</p><h1 id="3-File-I-O-fprintf-fscanf-fgets-and-fputs"><a href="#3-File-I-O-fprintf-fscanf-fgets-and-fputs" class="headerlink" title="3. File I/O: fprintf(), fscanf(), fgets(), and fputs()"></a>3. File I/O: fprintf(), fscanf(), fgets(), and fputs()</h1><h2 id="1-The-fprintf-and-fscanf-Functions"><a href="#1-The-fprintf-and-fscanf-Functions" class="headerlink" title="(1) The fprintf() and fscanf() Functions"></a>(1) The fprintf() and fscanf() Functions</h2><p>The file I/O functions <strong>fprintf()</strong> and <strong>fscanf()</strong> work just like <strong>printf()</strong> and <strong>scanf()</strong>, except that they require an additional first argument to identify the proper <strong>file</strong>.</p><pre><code class="hljs c"><span class="hljs-comment">/* addaword.c -- uses fprintf(), fscanf(), and rewind() */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 41</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    FILE *fp;    <span class="hljs-keyword">char</span> words[MAX];    <span class="hljs-keyword">if</span> ((fp = fopen(<span class="hljs-string">"wordy"</span>, <span class="hljs-string">"a+"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>,<span class="hljs-string">"Can't open \"wordy\" file.\n"</span>);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter words to add to the file; press the #"</span>);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"key at the beginning of a line to terminate."</span>);    <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">fscanf</span>(<span class="hljs-built_in">stdin</span>,<span class="hljs-string">"%40s"</span>, words) == <span class="hljs-number">1</span>) &amp;&amp; (words[<span class="hljs-number">0</span>] != <span class="hljs-string">'#'</span>))        <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">"%s\n"</span>, words);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"File contents:"</span>);    rewind(fp); <span class="hljs-comment">/* go back to beginning of file */</span>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">"%s"</span>,words) == <span class="hljs-number">1</span>)        <span class="hljs-built_in">puts</span>(words);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Done!"</span>);    <span class="hljs-keyword">if</span> (fclose(fp) != <span class="hljs-number">0</span>)        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Error closing file\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre><p>The <strong>rewind()</strong> command takes the program to the <strong>file beginning</strong> so that the final while loop can print the file contents.</p><h2 id="2-The-fgets-and-fputs-Functions"><a href="#2-The-fgets-and-fputs-Functions" class="headerlink" title="(2) The fgets() and fputs() Functions"></a>(2) The fgets() and fputs() Functions</h2><pre><code class="hljs c">fgets(buf, STLEN, fp);</code></pre><p><strong>The first argument</strong> of <strong>fgets()</strong>, as with the banished <strong>gets()</strong>, is the address (type <strong>char *</strong>) where input should be stored. </p><p><strong>The second argument</strong> is an integer representing the <strong>maximum size of the input string</strong>. </p><p><strong>The final argument</strong> is the <strong>file pointer</strong> identifying the file to be read. </p><p>The <strong>fgets()</strong> function reads input through the <strong>first newline character</strong>, until one fewer than the upper limit of characters is read, or until the end-of-file is found; <strong>fgets()</strong> then adds a <strong>terminating null character</strong> to form a string. </p><p>Therefore, the <strong>upper limit</strong> represents the <strong>maximum number of characters</strong> plus the <strong>null character</strong>. </p><p>If <strong>fgets()</strong> reads in a whole line before running into the character limit, it places the <strong>newline character</strong>, marking the end of the line into the string, just before the <strong>null character</strong>. </p><p>The <strong>fgets()</strong> function returns the value <strong>NULL</strong> when it encounters <strong>EOF</strong>. You can use this to check for the end of a file. Otherwise, it returns the address passed to it.</p><pre><code class="hljs c"><span class="hljs-built_in">fputs</span>(buf, fp);</code></pre><p>The <strong>fputs()</strong> function takes two arguments: first, an <strong>address of a string</strong> and then a <strong>file pointer</strong>.</p><p>It writes the string found at the pointed-to location into the indicated file. <strong>Unlike puts()</strong>, <strong>fputs()</strong> does not append a <strong>newline</strong> when it prints. </p><h1 id="4-fseek-and-ftell"><a href="#4-fseek-and-ftell" class="headerlink" title="4. fseek() and ftell()"></a>4. fseek() and ftell()</h1><p>The <strong>fseek()</strong> function enables you to treat a <strong>file</strong> like an <strong>array</strong> and move directly to any particular byte in a <strong>file</strong> opened by <strong>fopen()</strong>. </p><pre><code class="hljs c"><span class="hljs-comment">/* reverse.c -- displays a file in reverse order */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CNTL_Z <span class="hljs-meta-string">'\032'</span> <span class="hljs-comment">/* eof marker in DOS text files */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLEN 81</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> file[SLEN];    <span class="hljs-keyword">char</span> ch;    FILE *fp;    <span class="hljs-keyword">long</span> count, last;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter the name of the file to be processed:"</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%80s"</span>, file);    <span class="hljs-keyword">if</span> ((fp = fopen(file,<span class="hljs-string">"rb"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;   <span class="hljs-comment">/* read-only mode */</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"reverse can't open %s\n"</span>, file);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    fseek(fp, <span class="hljs-number">0L</span>, SEEK_END); <span class="hljs-comment">/* go to end of file */</span>    last = ftell(fp);    <span class="hljs-keyword">for</span> (count = <span class="hljs-number">1L</span>; count &lt;= last; count++)    &#123;        fseek(fp, -count, SEEK_END); <span class="hljs-comment">/* go backward */</span>        ch = getc(fp);        <span class="hljs-keyword">if</span> (ch != CNTL_Z &amp;&amp; ch != <span class="hljs-string">'\r'</span>) <span class="hljs-comment">/* MS-DOS files */</span>            <span class="hljs-built_in">putchar</span>(ch);    &#125;    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);    fclose(fp);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>The <strong>first of the three arguments</strong> to <strong>fseek()</strong> is a <strong>FILE pointer</strong> to the file being searched. The file should have been opened by using <strong>fopen()</strong>.</p><p>The <strong>second argument</strong> to <strong>fseek()</strong> is called the <strong>offset</strong>. This argument tells how far to move from the <strong>starting point</strong> (see the following list of mode starting points). The argument must be a <strong>long value</strong>. It can be <strong>positive</strong> (move forward), <strong>negative</strong> (move backward), or <strong>zero</strong> (stay put).</p><p><strong>The third argument</strong> is the <strong>mode</strong>, and it identifies the <strong>starting point</strong>. Since the <strong>ANSI standard</strong>, the <strong>stdio.h</strong> header file specifies the following manifest constants for the mode:</p><table><thead><tr><th align="left">Mode</th><th align="left">Measures Offset From</th></tr></thead><tbody><tr><td align="left">SEEK_SET</td><td align="left">Beginning of file</td></tr><tr><td align="left">SEEK_CUR</td><td align="left">Current position</td></tr><tr><td align="left">SEEK_END</td><td align="left">End of file</td></tr></tbody></table><p>Older implementations may lack these definitions and, instead, use the numeric values <code>0L</code>, <code>1L</code>, and <code>2L</code>, respectively, for these <strong>modes</strong>. The <code>L</code> suffix identifies type <strong>long values</strong>. </p><pre><code class="hljs c">fseek(fp, <span class="hljs-number">0L</span>, SEEK_SET); <span class="hljs-comment">// go to the beginning of the file</span>fseek(fp, <span class="hljs-number">10L</span>, SEEK_SET); <span class="hljs-comment">// go 10 bytes into the file</span>fseek(fp, <span class="hljs-number">2L</span>, SEEK_CUR); <span class="hljs-comment">// advance 2 bytes from the current position</span>fseek(fp, <span class="hljs-number">0L</span>, SEEK_END); <span class="hljs-comment">// go to the end of the file</span>fseek(fp, <span class="hljs-number">-10L</span>, SEEK_END); <span class="hljs-comment">// back up 10 bytes from the end of the file</span></code></pre><p>The value <strong>returned</strong> by <strong>fseek()</strong> is <strong>0</strong> if everything is okay, and <strong>-1</strong> if there is an error, such as attempting to move <strong>past the bounds</strong> of the <strong>file</strong>.</p><p>The <strong>ftell()</strong> function is type <strong>long</strong>, and it <strong>returns</strong> the <strong>current file location</strong>. Under <strong>ANSI C</strong>, it is declared in <strong>stdio.h</strong>. </p><p>As originally implemented in Unix, <strong>ftell()</strong> specifies the <strong>file position</strong> by returning the number of bytes from the <strong>beginning</strong>, with the <strong>first byte</strong> being byte <strong>0</strong>, and so on.</p><p>Under <strong>ANSI C</strong>, this definition applies to files opened in the <strong>binary mode</strong>, but not necessarily to files opened in the <strong>text mode</strong>. </p><p>The <strong>ftell()</strong> function may work <strong>differently</strong> in the <strong>text mode</strong> than in the <strong>binary mode</strong>. </p><h1 id="5-The-fgetpos-and-fsetpos-Functions"><a href="#5-The-fgetpos-and-fsetpos-Functions" class="headerlink" title="5. The fgetpos() and fsetpos() Functions"></a>5. The fgetpos() and fsetpos() Functions</h1><p>One potential problem with <strong>fseek()</strong> and ftell()<strong>** is that they **limit file sizes</strong> to values that can be represented by type <strong>long</strong>. </p><p><strong>ANSI C</strong> introduced two <strong>new positioning functions</strong> designed to work with <strong>larger file sizes</strong>. Instead of using a <strong>long</strong> value to represent a position, it uses a new type, called <strong>fpos_t</strong> (for file position type) for that purpose.</p><p>The <strong>fpos_t</strong> type is not a fundamental type; rather, it is defined in terms of other types. A variable or data object of <strong>fpos_t</strong> type can <strong>specify a location</strong> within a file, and it <strong>cannot be an array type</strong>, but its nature is not specified beyond that. </p><p><strong>ANSI C</strong> does define how <strong>fpos_t</strong> is used. The <strong>fgetpos()</strong> function has this prototype:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fgetpos</span><span class="hljs-params">(FILE * <span class="hljs-keyword">restrict</span> stream, <span class="hljs-keyword">fpos_t</span> * <span class="hljs-keyword">restrict</span> pos)</span></span>;</code></pre><p>When called, it places an <strong>fpos_t</strong> value in the location pointed to by <code>pos</code>; the value describes a location in the file. The function <strong>returns zero</strong> if successful and a <strong>nonzero</strong> value for failure.</p><p>The <strong>fsetpos()</strong> function has this prototype: </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fsetpos</span><span class="hljs-params">(FILE *stream, <span class="hljs-keyword">const</span> <span class="hljs-keyword">fpos_t</span> *pos)</span></span>;</code></pre><p>When called, it uses the <strong>fpos_t</strong> value in the location pointed to by <code>pos</code> to set the file pointer to the location indicated by that value. The function <strong>returns zero</strong> if successful and a <strong>nonzero</strong> value for failure. The <strong>fpos_t</strong> value should have been obtained by a previous call to <strong>fgetpos()</strong>.</p><h1 id="6-Other-Standard-I-O-Functions"><a href="#6-Other-Standard-I-O-Functions" class="headerlink" title="6. Other Standard I/O Functions"></a>6. Other Standard I/O Functions</h1><h2 id="1-The-int-ungetc-int-c-FILE-fp-Function"><a href="#1-The-int-ungetc-int-c-FILE-fp-Function" class="headerlink" title="(1) The int ungetc(int c, FILE *fp) Function"></a>(1) The int ungetc(int c, FILE *fp) Function</h2><p>The <strong>int ungetc()</strong> function pushes the character specified by <code>c</code> back onto the input stream.</p><p>If you push a character onto the input stream, the next call to a standard input function reads that character.</p><p>The <strong>ANSI C</strong> standard guarantees <strong>only one pushback</strong> at a time. If an implementation permits you to push back <strong>several characters in a row</strong>, the input functions read them in the <strong>reversed order of pushing</strong>.</p><p><img src="_v_images/20201206172345396_1469727691.png" srcset="/img/loading.gif" alt="The ungetc() Function"></p><h2 id="2-The-int-fflush-Function"><a href="#2-The-int-fflush-Function" class="headerlink" title="(2) The int fflush() Function"></a>(2) The int fflush() Function</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fflush</span><span class="hljs-params">(FILE *fp)</span></span>;</code></pre><p>Calling the <strong>fflush()</strong> function causes any <strong>unwritten data in the output buffer</strong> to be sent to the <strong>output file</strong> identified by <code>fp</code>. This process is called <strong>flushing a buffer</strong>. </p><p>If <code>fp</code> is the <strong>null pointer</strong>, all output buffers are flushed. </p><p>The effect of using <strong>fflush()</strong> on an <strong>input stream</strong> is <strong>undefined</strong>. </p><h2 id="3-The-int-setvbuf-Function"><a href="#3-The-int-setvbuf-Function" class="headerlink" title="(3) The int setvbuf() Function"></a>(3) The int setvbuf() Function</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setvbuf</span><span class="hljs-params">(FILE * <span class="hljs-keyword">restrict</span> fp, <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> buf, <span class="hljs-keyword">int</span> mode, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span></span>;</code></pre><p>The <strong>setvbuf()</strong> function sets up an <strong>alternative buffer</strong> to be used by the standard I/O functions. It is called <strong>after the file has been opened</strong> and <strong>before any other operations have been performed</strong> on the stream. </p><p>The pointer <code>fp</code> identifies the stream, and <code>buf</code> points to the storage to be used. If the value of <code>buf</code> is <strong>not NULL</strong>, you must create the <strong>buffer</strong>. </p><p>For instance, you could declare an array of 1,024 chars and pass the address of that array. However, if you use <strong>NULL</strong> for the value of <code>buf</code>, the function allocates a <strong>buffer</strong> itself. The size variable tells <strong>setvbuf()</strong> how big the array is.</p><p>The <strong>mode</strong> is selected from the following choices: <strong>_IOFBF</strong> means <strong>fully buffered</strong> (buffer flushed when full), <strong>_IOLBF</strong> means <strong>line-buffered</strong> (buffer flushed when full or when a <strong>newline</strong> is written), and <strong>_IONBF</strong> means <strong>nonbuffered</strong>. </p><p>The function returns <strong>zero</strong> if successful, <strong>nonzero</strong> otherwise.</p><p>Suppose you have a program that works with stored data objects having, say, a size of 3,000 bytes each. You could use <strong>setvbuf()</strong> to create a <strong>buffer</strong> whose size is a multiple of the data object’s size. </p><h2 id="4-Binary-I-O-fread-and-fwrite"><a href="#4-Binary-I-O-fread-and-fwrite" class="headerlink" title="(4) Binary I/O: fread() and fwrite()"></a>(4) Binary I/O: fread() and fwrite()</h2><p>In general, <strong>fprintf()</strong> converts <strong>numeric values</strong> to <strong>character data</strong>, possibly <strong>altering the value</strong>.</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> num = <span class="hljs-number">1.</span>/<span class="hljs-number">3.</span>;<span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">"%f"</span>, num);</code></pre><p>saves <code>num</code> as a sequence of eight characters: <code>0.333333</code>. Using a <code>%.2f</code> specifier saves it as four characters: <code>0.33</code>.</p><p>Changing the specifier alters the amount of space needed to store the value; it can also result in different values being stored. After the value of <code>num</code> is stored as <code>0.33</code>, there is <strong>no way to get back the full precision</strong> when the file is read. </p><p>The <strong>most accurate and consistent</strong> way to store a number is to use the <strong>same pattern of bits</strong> that the computer does. Therefore, a <strong>double</strong> value should be stored in a size <strong>double unit</strong>. </p><p>When data is stored in a file using the same representation that the program uses, we say that the data is stored in <strong>binary form</strong>. There is <strong>no conversion from</strong> numeric forms to character sequences. </p><p>For <strong>standard I/O</strong>, the <strong>fread()</strong> and <strong>fwrite()</strong> functions provide this <strong>binary service</strong>.</p><p><img src="_v_images/20201206174743443_124649534.png" srcset="/img/loading.gif" alt="Binary and text output"></p><h3 id="The-size-t-fwrite-Function"><a href="#The-size-t-fwrite-Function" class="headerlink" title="The size_t fwrite() Function"></a>The size_t fwrite() Function</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">restrict</span> ptr, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">size_t</span> nmemb, FILE * <span class="hljs-keyword">restrict</span> fp)</span></span>;</code></pre><p>The <strong>fwrite()</strong> function <strong>writes binary data</strong> to a file. </p><p>The <strong>size_t</strong> type is defined in terms of the standard C types. It is the type returned by the <strong>sizeof</strong> operator. Typically, it is <strong>unsigned int</strong>, but an implementation can choose another type. </p><p>The pointer <code>ptr</code> is the address of the chunk of data to be written. </p><p>Also, <code>size</code> represents the size, in <strong>bytes</strong>, of the chunks to be written, and<br><code>nmemb</code> represents the number of chunks to be written. As usual, <code>fp</code> identifies the file to be written to. </p><p>For instance, to save a data object (such as an array) that is 256 bytes in size, you<br>can do this:</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> <span class="hljs-built_in">buffer</span>[<span class="hljs-number">256</span>];fwrite(<span class="hljs-built_in">buffer</span>, <span class="hljs-number">256</span>, <span class="hljs-number">1</span>, fp);</code></pre><p>This call writes one chunk of 256 bytes from buffer to the file. </p><p>Or, to save an array of 10 double values, you can do this:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> earnings[<span class="hljs-number">10</span>];fwrite(earnings, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>), <span class="hljs-number">10</span>, fp);</code></pre><p>This call writes data from the <code>earnings</code> array to the file in 10 chunks, each of size double.</p><p>One problem with <strong>fwrite()</strong> is that its <strong>first argument</strong> is <strong>not a fixed type</strong>. Under ANSI C function prototyping, these actual arguments are converted to the <strong>pointer-to-void</strong> type, which acts as a sort of catchall type for pointers. </p><p>The <strong>fwrite()</strong> function <strong>returns</strong> the <strong>number of items</strong> successfully written. Normally, this equals <code>nmemb</code>, but it can be less if there is a write error.</p><h3 id="The-size-t-fread-Function"><a href="#The-size-t-fread-Function" class="headerlink" title="The size_t fread() Function"></a>The size_t fread() Function</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * <span class="hljs-keyword">restrict</span> ptr, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">size_t</span> nmemb, FILE * <span class="hljs-keyword">restrict</span> fp)</span></span>;</code></pre><p>The <strong>fread()</strong> function takes the same set of arguments that <strong>fwrite()</strong> does. </p><p>This time <code>ptr</code> is the address of the memory storage into which file data is read, and <code>fp</code> identifies the file to be read. </p><p>For example, to recover the array of 10 doubles saved in the previous example, use this call:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> earnings[<span class="hljs-number">10</span>];fread(earnings, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>), <span class="hljs-number">10</span>, fp);</code></pre><p>This call copies 10 size <strong>double</strong> values into the <code>earnings</code> array.</p><p>The <strong>fread()</strong> function returns the <strong>number of items</strong> successfully read. Normally, this equals <code>nmemb</code>, but it can be less if there is a read error or if the <strong>end-of-file</strong> is reached.</p><h2 id="5-The-int-feof-FILE-fp-and-int-ferror-FILE-fp-Functions"><a href="#5-The-int-feof-FILE-fp-and-int-ferror-FILE-fp-Functions" class="headerlink" title="(5) The int feof(FILE *fp) and int ferror(FILE *fp) Functions"></a>(5) The int feof(FILE *fp) and int ferror(FILE *fp) Functions</h2><p>When the standard input functions return <strong>EOF</strong>, this usually means they have reached the <strong>end of a file</strong>. However, it can also indicate that a <strong>read error</strong> has occurred. </p><p>The <strong>feof()</strong> and <strong>ferror()</strong> functions enable you to <strong>distinguish between the two possibilities</strong>. </p><p>The <strong>feof()</strong> function returns a <strong>nonzero</strong> value if the last input call detected the <strong>end-of-file</strong>, and it returns <strong>zero</strong> otherwise. </p><p>The <strong>ferror()</strong> function returns a <strong>nonzero</strong> value if a read or write <strong>error</strong> has occurred, and it returns <strong>zero</strong> otherwise.</p><h2 id="6-An-fread-and-fwrite-Example"><a href="#6-An-fread-and-fwrite-Example" class="headerlink" title="(6) An fread() and fwrite() Example"></a>(6) An fread() and fwrite() Example</h2><pre><code class="hljs c"><span class="hljs-comment">/* append.c -- appends files to a file */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFSIZE 4096</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLEN 81</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(FILE *source, FILE *dest)</span></span>;<span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * st, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    FILE *fa, *fs; <span class="hljs-comment">// fa for append file, fs for source file</span>    <span class="hljs-keyword">int</span> files = <span class="hljs-number">0</span>; <span class="hljs-comment">// number of files appended</span>    <span class="hljs-keyword">char</span> file_app[SLEN]; <span class="hljs-comment">// name of append file</span>    <span class="hljs-keyword">char</span> file_src[SLEN]; <span class="hljs-comment">// name of source file</span>    <span class="hljs-keyword">int</span> ch;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter name of destination file:"</span>);    s_gets(file_app, SLEN);    <span class="hljs-keyword">if</span> ((fa = fopen(file_app, <span class="hljs-string">"a+"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Can't open %s\n"</span>, file_app);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-keyword">if</span> (setvbuf(fa, <span class="hljs-literal">NULL</span>, _IOFBF, BUFSIZE) != <span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">"Can't create output buffer\n"</span>, <span class="hljs-built_in">stderr</span>);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter name of first source file (empty line to quit):"</span>);    <span class="hljs-keyword">while</span> (s_gets(file_src, SLEN) &amp;&amp; file_src[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span>)    &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(file_src, file_app) == <span class="hljs-number">0</span>)            <span class="hljs-built_in">fputs</span>(<span class="hljs-string">"Can't append file to itself\n"</span>,<span class="hljs-built_in">stderr</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fs = fopen(file_src, <span class="hljs-string">"r"</span>)) == <span class="hljs-literal">NULL</span>)            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Can't open %s\n"</span>, file_src);        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span> (setvbuf(fs, <span class="hljs-literal">NULL</span>, _IOFBF, BUFSIZE) != <span class="hljs-number">0</span>)            &#123;                <span class="hljs-built_in">fputs</span>(<span class="hljs-string">"Can't create input buffer\n"</span>,<span class="hljs-built_in">stderr</span>);                <span class="hljs-keyword">continue</span>;            &#125;            append(fs, fa);            <span class="hljs-keyword">if</span> (ferror(fs) != <span class="hljs-number">0</span>)            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Error in reading file %s.\n"</span>,            file_src);            <span class="hljs-keyword">if</span> (ferror(fa) != <span class="hljs-number">0</span>)            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Error in writing file %s.\n"</span>,            file_app);            fclose(fs);            files++;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"File %s appended.\n"</span>, file_src);            <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Next file (empty line to quit):"</span>);        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Done appending. %d files appended.\n"</span>, files);    rewind(fa);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s contents:\n"</span>, file_app);    <span class="hljs-keyword">while</span> ((ch = getc(fa)) != EOF)        <span class="hljs-built_in">putchar</span>(ch);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Done displaying."</span>);    fclose(fa);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(FILE *source, FILE *dest)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">size_t</span> bytes;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> temp[BUFSIZE]; <span class="hljs-comment">// allocate once</span>    <span class="hljs-keyword">while</span> ((bytes = fread(temp,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>),BUFSIZE,source)) &gt; <span class="hljs-number">0</span>)        fwrite(temp, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), bytes, dest);&#125;<span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * st, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> * ret_val;    <span class="hljs-keyword">char</span> * <span class="hljs-built_in">find</span>;    ret_val = fgets(st, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span> (ret_val)    &#123;        <span class="hljs-built_in">find</span> = <span class="hljs-built_in">strchr</span>(st, <span class="hljs-string">'\n'</span>); <span class="hljs-comment">// look for newline</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>) <span class="hljs-comment">// if the address is not NULL,</span>            *<span class="hljs-built_in">find</span> = <span class="hljs-string">'\0'</span>; <span class="hljs-comment">// place a null character there</span>        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">'\n'</span>)                <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret_val;&#125;</code></pre><h2 id="7-Random-Access-with-Binary-I-O"><a href="#7-Random-Access-with-Binary-I-O" class="headerlink" title="(7) Random Access with Binary I/O"></a>(7) Random Access with Binary I/O</h2><pre><code class="hljs c"><span class="hljs-comment">/* randbin.c -- random access, binary i/o */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARSIZE 1000</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> numbers[ARSIZE];    <span class="hljs-keyword">double</span> value;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file = <span class="hljs-string">"numbers.dat"</span>;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">long</span> pos;    FILE *iofile;    <span class="hljs-comment">// create a set of double values</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; ARSIZE; i++)        numbers[i] = <span class="hljs-number">100.0</span> * i + <span class="hljs-number">1.0</span> / (i + <span class="hljs-number">1</span>);    <span class="hljs-comment">// attempt to open file</span>    <span class="hljs-keyword">if</span> ((iofile = fopen(file, <span class="hljs-string">"wb"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not open %s for output.\n"</span>, file);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-comment">// write array in binary format to file</span>    fwrite(numbers, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>), ARSIZE, iofile);    fclose(iofile);    <span class="hljs-keyword">if</span> ((iofile = fopen(file, <span class="hljs-string">"rb"</span>)) == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,        <span class="hljs-string">"Could not open %s for random access.\n"</span>, file);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-comment">// read selected items from file</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter an index in the range 0-%d.\n"</span>, ARSIZE<span class="hljs-number">-1</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;i) == <span class="hljs-number">1</span> &amp;&amp; i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; ARSIZE)    &#123;        pos = (<span class="hljs-keyword">long</span>)i * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>);<span class="hljs-comment">// calculate offset</span>        fseek(iofile, pos, SEEK_SET); <span class="hljs-comment">// go there</span>        fread(&amp;value, <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">double</span>), <span class="hljs-number">1</span>, iofile);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The value there is %f.\n"</span>, value);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Next index (out of range to quit):\n"</span>);    &#125;    <span class="hljs-comment">// finish up</span>    fclose(iofile);    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Storage Classes, Linkage, and Memory Management</title>
    <link href="/2020/12/03/Storage-Classes-Linkage-and-Memory-Management/"/>
    <url>/2020/12/03/Storage-Classes-Linkage-and-Memory-Management/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 12 Storage Classes, Linkage, and Memory Management<a id="more"></a></p><h1 id="1-Storage-Classes"><a href="#1-Storage-Classes" class="headerlink" title="1. Storage Classes"></a>1. Storage Classes</h1><h2 id="1-Scope"><a href="#1-Scope" class="headerlink" title="(1) Scope"></a>(1) Scope</h2><p><strong>Scope</strong> describes the <strong>region or regions</strong> of a program that can access an identifier. </p><p>A C variable has one of the following scopes: <strong>block scope</strong>, <strong>function scope</strong>, <strong>function prototype scope</strong>, or <strong>file scope</strong>. </p><h3 id="Block-scope"><a href="#Block-scope" class="headerlink" title="Block scope"></a>Block scope</h3><p> A <strong>block</strong>  is a region of code contained within an <strong>opening brace and the matching closing brace</strong>. </p><p>A variable defined inside a block has <strong>block scope</strong>, and it is visible from the point it is defined until the end of the block containing the definition. </p><p>Also, <strong>formal function parameters</strong>, even though they occur before the opening brace of a function, have <strong>block scope</strong> and belong to the block containing the function body. </p><h3 id="Function-scope"><a href="#Function-scope" class="headerlink" title="Function scope"></a>Function scope</h3><p><strong>Function scope</strong> applies just to <strong>labels</strong> used with <strong>goto statements</strong>. This means that even if a <strong>label</strong> first appears inside an inner block in a function, its scope extends to the whole function. </p><h3 id="Function-prototype-scope"><a href="#Function-prototype-scope" class="headerlink" title="Function prototype scope"></a>Function prototype scope</h3><p><strong>Function prototype scope</strong> runs from the point the variable is defined to the end of the prototype declaration. </p><p>What this means is that all the compiler cares about when handling a function prototype argument is the <strong>types</strong>; the names you use, if any, normally don’t matter, and they needn’t match the names you use in the function definition. </p><h3 id="File-scope"><a href="#File-scope" class="headerlink" title="File scope"></a>File scope</h3><p>A variable with its definition placed outside of any function has <strong>file scope</strong>. A variable with file scope is visible from the point it is defined to the end of the file containing the definition. <strong>File scope</strong> variables are also called <strong>global variables</strong>.</p><p><strong>Translation Units and Files:</strong><br>What you view as <strong>several files</strong> may appear to the compiler as <strong>a single file</strong>. </p><p>For example, suppose that, as often is the case, you include one or more <strong>header files</strong> in a source code file. A header file, in turn, may include other header files. So several separate physical files may be involved. </p><p>However, C preprocessing essentially replaces an <code>#include</code> directive with the contents of the header file. Thus the compiler sees <strong>a single file</strong> containing information from your <strong>source code file and all the header files</strong>. </p><p>This single file is called a <strong>translation unit</strong>. When we describe a variable as having file scope, it’s actually visible to the whole <strong>translation unit</strong>. If your program consists of several source code files, then it will consist of several translation units, with each translation unit corresponding to a source code file and its included files.</p><h2 id="2-Linkage"><a href="#2-Linkage" class="headerlink" title="(2) Linkage"></a>(2) Linkage</h2><p>A C variable has one of the following <strong>linkages</strong>: <strong>external linkage</strong>, <strong>internal linkage</strong>, or <strong>no linkage</strong>. </p><p>Variables with <strong>block scope</strong>, <strong>function scope</strong>, or <strong>function prototype scope</strong> have <strong>no linkage</strong>. That means they are <strong>private</strong> to the block, function, or prototype in which they are defined. </p><p>A variable with <strong>file scope</strong> can have <strong>either internal or external linkage</strong>.</p><p>A variable with <strong>external linkage</strong> can be used anywhere in a <strong>multifile program</strong>. </p><p>A variable with <strong>internal linkage</strong> can be used anywhere in a <strong>single translation unit</strong>.</p><p>The C Standard uses “<strong>file scope with internal linkage</strong>“ to describe <strong>scope limited to one translation unit</strong> (a source code file plus its included header files) and “<strong>file scope with external linkage</strong>“ to describe scope that, at least potentially, extends to <strong>other translation units</strong>. </p><p>Some common <strong>short cuts</strong> are to use “<strong>file scop</strong>“ for “<strong>file scope with internal linkag</strong>“ and “<strong>global scope</strong>“ or “<strong>program scope</strong>“ for “<strong>file scope with external linkage</strong>“.</p><p>So how can you tell whether a file scope variable has internal or external linkage? You look to see if the <strong>storage class specifier</strong> *<em>static *</em>is used in the external definition:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> giants = <span class="hljs-number">5</span>; <span class="hljs-comment">// file scope, external linkage</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> dodgers = <span class="hljs-number">3</span>; <span class="hljs-comment">// file scope, internal linkage</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;...&#125;</code></pre><h2 id="3-Storage-Duration"><a href="#3-Storage-Duration" class="headerlink" title="(3) Storage Duration"></a>(3) Storage Duration</h2><p><strong>Scope</strong> and <strong>linkage</strong> describe the <strong>visibility of identifiers</strong>. </p><p><strong>Storage duration</strong> describes the <strong>persistence of the objects</strong> accessed by these identifiers. </p><p>A C object has one of the following <strong>four storage durations</strong>: <strong>static storage duration</strong>, <strong>thread storage duration</strong>, <strong>automatic storage duration</strong>, or <strong>allocated storage duration</strong>.</p><p>If an object has <strong>static storage duration</strong>, it <strong>exists throughout program execution</strong>. </p><p>Variables with <strong>file scope</strong> have <strong>static storage duration</strong>. Note that for <strong>file scope</strong> variables, the keyword <strong>static</strong> indicates the <strong>linkage type</strong>, <strong>not the storage duration</strong>. </p><p>A <strong>file scope</strong> variable declared using <strong>static</strong> has <strong>internal linkage</strong>, but all <strong>file scope</strong> variables, using <strong>internal linkage</strong> or <strong>external linkage</strong>, have <strong>static storage duration</strong>.</p><p><strong>Thread storage duration</strong> comes into play in concurrent programming, in which program execution can be divided into <strong>multiple threads</strong>. </p><p>An object with <strong>thread storage duration</strong> exists from when it’s declared until the <strong>thread terminates</strong>. Such an object is created when a declaration that would otherwise create a <strong>file scope</strong> object is modified with the keyword <code>_Thread_local</code>. When a variable is declared with this specifier, each thread gets its own private copy of that variable.</p><p>Variables with <strong>block scope</strong> normally have <strong>automatic storage duration</strong>. </p><p>These variables have memory allocated for them when the program enters the block in which they are defined, and the memory is freed when the block is exited. </p><p>The idea is that <strong>memory</strong> used for automatic variables is a workspace or scratch pad that can be reused.</p><p><strong>Variable-length arrays</strong> provide a slight <strong>exception</strong> in that they exist from the point of declaration to the end of the block rather than from the beginning of the block to the end.</p><h2 id="4-Automatic-Variables"><a href="#4-Automatic-Variables" class="headerlink" title="(4) Automatic Variables"></a>(4) Automatic Variables</h2><p>A variable belonging to the <strong>automatic storage class</strong> has <strong>automatic storage duration</strong>, <strong>block scope</strong>, and <strong>no linkage</strong>. </p><p>By default, any variable declared in a <strong>block</strong> or <strong>function header</strong> belongs to the <strong>automatic storage class</strong>.</p><p>You can use the keyword <strong>auto</strong>, as shown here:</p><p>The keyword <strong>auto</strong> is termed a <strong>storage-class specifier</strong>. </p><p>Statements that are part of a <strong>loop</strong> or <strong>if *<em>statement qualify as a *</em>block</strong> even if braces (that is, { }) aren’t used. </p><p>Automatic variables are not initialized unless you do so explicitly.</p><h2 id="5-Register-Variables"><a href="#5-Register-Variables" class="headerlink" title="(5) Register Variables"></a>(5) Register Variables</h2><p>Variables are normally stored in computer memory. With luck, <strong>register variables</strong> are stored in the <strong>CPU registers</strong> or, more generally, in the <strong>fastest memory available</strong>, where they can be accessed and manipulated more <strong>rapidly</strong> than regular variables. </p><p>Because a <strong>register variable</strong> may be in a <strong>register</strong> rather than in <strong>memory</strong>, you <strong>can’t take the address of a register variable</strong>. </p><p>In most other respects, <strong>register variables</strong> are the same as <strong>automatic variables</strong>. That is, they have <strong>block scope</strong>, <strong>no linkage</strong>, and <strong>automatic storage duration</strong>. </p><p>Declaring a variable as a <strong>register class</strong> is more a <strong>request</strong> than a direct order. The compiler has to weigh your demands against the number of registers or amount of fast memory available, or it can simply ignore the request. In that case, the variable becomes an ordinary <strong>automatic variable</strong>; however, you still <strong>can’t use the address operator</strong> with it.</p><p>You can request that formal parameters be register variables. Just use the keyword in the function heading:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">macho</span><span class="hljs-params">(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> n)</span></span></code></pre><h2 id="6-Static-Variables-with-Block-Scope"><a href="#6-Static-Variables-with-Block-Scope" class="headerlink" title="(6) Static Variables with Block Scope"></a>(6) Static Variables with Block Scope</h2><p><strong>Static</strong> means that the variable stays put in <strong>memory</strong>, not necessarily in value. </p><p>Variables with <strong>file scope</strong> automatically (and necessarily) have <strong>static storage duration</strong>. </p><p>You also can create <strong>local variables</strong> having <strong>block scope</strong> but <strong>static duration</strong>. These variables have the same <strong>scope</strong> as <strong>automatic variables</strong>, but they don’t vanish when the containing function ends its job.</p><p><strong>Static variables</strong> and <strong>external variables</strong> are already in place after a program is loaded into memory. </p><h2 id="7-Static-Variables-with-External-Linkage"><a href="#7-Static-Variables-with-External-Linkage" class="headerlink" title="(7) Static Variables with External Linkage"></a>(7) Static Variables with External Linkage</h2><p>A <strong>static variable</strong> with <strong>external linkage</strong> has <strong>file scope</strong>, <strong>external linkage</strong>, and <strong>static storage duration</strong>. </p><p>This class is sometimes termed the <strong>external storage class</strong>, and variables of this type are called <strong>external variables</strong>. </p><p>You create an <strong>external variable</strong> by placing a <strong>defining declaration outside of any function</strong>. As a matter of documentation, an <strong>external variable</strong> can additionally be declared inside a function that uses it by using the <code>extern</code> keyword. </p><p>If a particular <strong>external variable</strong> is <strong>defined in one source code file</strong> and is <strong>used in a second source code file</strong>, <strong>declaring</strong> the variable in the second file with <code>extern</code> is mandatory. <strong>Declarations</strong> look like this:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> Errupt; <span class="hljs-comment">/* externally defined variable */</span><span class="hljs-keyword">double</span> Up[<span class="hljs-number">100</span>]; <span class="hljs-comment">/* externally defined array */</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> Coal; <span class="hljs-comment">/* mandatory declaration if */</span><span class="hljs-comment">/* Coal defined in another file */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> Errupt; <span class="hljs-comment">/* optional declaration */</span>    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> Up[]; <span class="hljs-comment">/* optional declaration */</span>    ...&#125;</code></pre><p>Unlike <strong>automatic variables</strong>, <strong>external variables</strong> are <strong>initialized automatically to zero</strong> if you don’t <strong>initialize</strong> them. </p><p>This rule applies to elements of an <strong>externally defined array</strong>, too. Unlike the case for <strong>automatic variables</strong>, you can use <strong>only constant expressions</strong> to <strong>initialize file scope variables</strong>:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// ok, 10 is constant</span><span class="hljs-keyword">int</span> y = <span class="hljs-number">3</span> + <span class="hljs-number">20</span>; <span class="hljs-comment">// ok, a constant expression</span><span class="hljs-keyword">size_t</span> z = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>); <span class="hljs-comment">// ok, a constant expression</span><span class="hljs-keyword">int</span> x2 = <span class="hljs-number">2</span> * x; <span class="hljs-comment">// not ok, x is a variable</span></code></pre><p>(As long as the type is not a variable array, a sizeof expression is considered a constant<br>expression.)</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> tern = <span class="hljs-number">1</span>; <span class="hljs-comment">/* tern defined */</span>main()&#123;    external <span class="hljs-keyword">int</span> tern; <span class="hljs-comment">/* use a tern defined elsewhere */</span>    ...&#125;</code></pre><p>Here, <code>tern</code> is <strong>declared</strong> twice. The <strong>first declaration</strong> causes <strong>storage to be set aside</strong> for the variable. It constitutes a <strong>definition</strong> of the variable. </p><p>The <strong>second declaration</strong> merely tells the compiler to use the <code>tern</code> variable that <strong>has been created previously</strong>, so it is <strong>not a definition</strong>. </p><p>The first declaration is called a <strong>defining declaration</strong>, and the <strong>second</strong> is called a <strong>referencing declaration</strong>. </p><p>The keyword <code>extern</code> indicates that a <strong>declaration is not a definition</strong> because it instructs the compiler to look elsewhere.</p><p>Suppose you do this:</p><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> tern;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    ...&#125;</code></pre><p>The <strong>compiler</strong> will assume that the <strong>actual definition</strong> of <code>tern</code> is somewhere else in your program, perhaps in another file. This declaration <strong>does not cause space to be allocated</strong>. </p><p>Therefore, don’tuse the keyword <code>extern</code> to create an <strong>external definition</strong>; use it only to <strong>refer to an existing external definition</strong>.</p><p>An <strong>external variable</strong> can be <strong>initialized only once</strong>, and that must occur when the variable is defined. </p><pre><code class="hljs c"><span class="hljs-comment">// file one.c</span><span class="hljs-keyword">char</span> permis = <span class="hljs-string">'N'</span>;...<span class="hljs-comment">// file two.c</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> permis = <span class="hljs-string">'Y'</span>; <span class="hljs-comment">/* error */</span></code></pre><p>This is an <strong>error</strong> because the defining declaration in <code>file_one.c</code> already has created and i<strong>nitialized</strong> permis.</p><h2 id="8-Static-Variables-with-Internal-Linkage"><a href="#8-Static-Variables-with-Internal-Linkage" class="headerlink" title="(8) Static Variables with Internal Linkage"></a>(8) Static Variables with Internal Linkage</h2><p>Variables of this <strong>storage class</strong> have <strong>static storage duration</strong>, <strong>file scope</strong>, and <strong>internal linkage</strong>. </p><p>You create one by <strong>defining it outside of any function</strong> (just as with an external variable) with the storage class specifier <code>static</code>:</p><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> svil = <span class="hljs-number">1</span>; <span class="hljs-comment">// static variable, internal linkage</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    ...&#125;</code></pre><p><strong>Static variable with internal linkage</strong> can be used only by functions <strong>in the same file</strong>. </p><h1 id="2-A-Random-Number-Function-and-a-Static-Variable"><a href="#2-A-Random-Number-Function-and-a-Static-Variable" class="headerlink" title="2. A Random-Number Function and a Static Variable"></a>2. A Random-Number Function and a Static Variable</h1><p>The <strong>ANSI C library</strong> provides the <strong>rand()</strong> function to <strong>generate random numbers</strong>. There are a variety of algorithms for generating random numbers, and <strong>ANSI C</strong> enables implementations to use the best algorithm for a particular machine. </p><p>Actually, rand() is a “<strong>pseudorandom number generator</strong>“, meaning that the actual sequence of numbers is predictable.</p><p>The scheme starts with a number called the “<strong>seed</strong>“. The function uses the seed to produce a new number, which becomes the new seed. Then the new seed can be used to produce a newer seed, and so on. </p><p>For this scheme to work, the random-number function must remember the seed it used the <strong>last time it was called</strong>. </p><pre><code class="hljs c"><span class="hljs-comment">/* s_and_r.c -- file for rand1() and srand1() */</span><span class="hljs-comment">/* uses ANSI C portable algorithm */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> next = <span class="hljs-number">1</span>; <span class="hljs-comment">/* the seed */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">/* magic formula to generate pseudorandom number */</span>    next = next * <span class="hljs-number">1103515245</span> + <span class="hljs-number">12345</span>;    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) (next/<span class="hljs-number">65536</span>) % <span class="hljs-number">32768</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">srand1</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> seed)</span></span><span class="hljs-function"></span>&#123;    next = seed;&#125;</code></pre><pre><code class="hljs c"><span class="hljs-comment">/* r_drive1.c -- test rand1() and srand1() */</span><span class="hljs-comment">/* compile with s_and_r.c */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rand0</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">//外部函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> count;    <span class="hljs-keyword">unsigned</span> seed;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Please enter your choice for seed."</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%u"</span>,&amp;seed) == <span class="hljs-number">1</span>)    &#123;       srand1(seed);       <span class="hljs-keyword">for</span>(count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">5</span>; count++)       <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,rand1());       <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Please enter next seed (q to quit):"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="3-Allocated-Memory"><a href="#3-Allocated-Memory" class="headerlink" title="3. Allocated Memory"></a>3. Allocated Memory</h1><h2 id="1-malloc-and-free"><a href="#1-malloc-and-free" class="headerlink" title="(1) malloc() and free()"></a>(1) malloc() and free()</h2><p><strong>Static data</strong>, is <strong>allocated</strong> when the program is <strong>loaded into memory</strong>, and <strong>automatic data</strong> is <strong>allocated</strong> when program execution <strong>enters a block</strong> and <strong>deallocated</strong> when execution leaves the block.</p><p>C goes beyond this. You can allocate more memory as a program runs. The main tool is the <strong>malloc()</strong> function, which takes one argument: *<em>the number of bytes of memory *</em>you want.</p><p>Then <strong>malloc()</strong> finds a <strong>suitable block of free memory</strong>. The memory is <strong>anonymous</strong>; that is, <strong>malloc()</strong> allocates memory but it <strong>doesn’t assign a name</strong> to it. </p><p>It does <strong>return the address of the first byte of that block</strong>. </p><p>Therefore, you can assign that address to a pointer variable and use the pointer to access the memory. Because char represents a byte, <strong>malloc()</strong> has traditionally been defined as type <strong>pointer-to-char</strong>. </p><p>Since the ANSI C standard, however, C uses a new type: <strong>pointer-to-void</strong>. This type is intended to be a “<strong>generic pointer</strong>“. </p><p>The <strong>malloc()</strong> function can be used to return pointers to arrays, structures, and so forth, so normally the return value is <strong>typecast</strong> to the proper value. Under ANSI C, you should still <strong>typecast</strong> for clarity, but assigning a <strong>pointer-to-void</strong> value to a <strong>pointer of another type</strong> is not considered a <strong>type clash</strong>. </p><p>If <strong>malloc()</strong> fails to find the required space, it returns the <strong>null pointer</strong>.</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> * ptd;ptd = (<span class="hljs-keyword">double</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">30</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>));</code></pre><p>This code requests space for <strong>30 type double values</strong> and sets <code>ptd</code> to <strong>point to the location</strong>. </p><p>Note that <code>ptd</code> is declared as a <strong>pointer to a single double</strong> and <strong>not to a block of 30 double values</strong>.</p><p>You now have <strong>three ways to create an array</strong>:</p><ul><li>Declare an array using <strong>constant expressions</strong> for the array dimensions and use the array name to access elements. Such an array can be created using either <strong>static or automatic</strong> memory.</li><li>Declare a <strong>variable-length array</strong> using variable expressions for the array dimensions and use the array name to access elements. (Recall that this is a C99 feature.) This feature is available only for <strong>automatic memory</strong>.</li><li>Declare a <strong>pointer</strong>, call <strong>malloc()</strong>, assign the <strong>return value</strong> to the <strong>pointer</strong>, and use the <strong>pointer</strong> to access elements. The pointer can be <strong>either static or automatic</strong>.</li></ul><p>You can use the second and third methods to do something you can’t do with an ordinary declared array—create a <strong>dynamic array</strong>, one that’s allocated while the program runs and that you can choose a size for while the program runs. </p><p>Normally, you should balance each use of <strong>malloc()</strong> with a use of <strong>free()</strong>. The <strong>free()</strong> function takes as its argument an address returned earlier by <strong>malloc()</strong> and <strong>frees up the memory</strong> that had been allocated.</p><p>Thus, the <strong>duration of allocated memory</strong> is from when <strong>malloc()</strong> is called to allocate the memory until <strong>free()</strong> is called to free up the memory so that it can be reused. Think of <strong>malloc()</strong> and <strong>free()</strong> as managing a pool of memory. </p><p>The argument to <strong>free()</strong> should be a pointer to a block of memory allocated by <strong>malloc()</strong>.</p><p>Both <strong>malloc()</strong> and <strong>free()</strong> have prototypes in the <code>stdlib.h</code> header file.</p><p>The <strong>free()</strong> function frees only the block of memory to which its argument points. Some operating systems will free allocated memory automatically when a program finishes, but others may not.</p><h2 id="2-The-calloc-Function"><a href="#2-The-calloc-Function" class="headerlink" title="(2) The calloc() Function"></a>(2) The calloc() Function</h2><p>Another option for <strong>memory allotment</strong> is to use <strong>calloc()</strong>. A typical use looks like this:</p><pre><code class="hljs c"><span class="hljs-keyword">long</span> * newmem;newmem = (<span class="hljs-keyword">long</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">100</span>, <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">long</span>));</code></pre><p>Like <strong>malloc()</strong>, <strong>calloc()</strong> returns a <strong>pointer-to-char</strong> in its <strong>pre-ANSI</strong> version and a pointer-to void under <strong>ANSI</strong>. You should use the <strong>cast operator</strong> if you want to store a different type. </p><p>This new function takes two arguments, both of which should be <strong>unsigned integers</strong> (type <strong>size_t</strong> since ANSI). The first argument is the <strong>number of memory cells</strong> you want. The second argument<br>is the <strong>size of each cell</strong> in <strong>bytes</strong>. </p><p>The <strong>calloc()</strong> function sets all the bits in the block to <strong>zero</strong>. (Note, however, that on some hardware systems, a floating-point value of <strong>0</strong> is not represented by all bits set to <strong>0</strong>.)</p><p>The <strong>free()</strong> function can also be used to <strong>free memory</strong> allocated by <strong>calloc()</strong>.</p><h2 id="3-Dynamic-Memory-Allocation-and-Variable-Length-Arrays"><a href="#3-Dynamic-Memory-Allocation-and-Variable-Length-Arrays" class="headerlink" title="(3) Dynamic Memory Allocation and Variable-Length Arrays"></a>(3) Dynamic Memory Allocation and Variable-Length Arrays</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vlamal</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">int</span> * pi;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);    pi = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));    <span class="hljs-keyword">int</span> ar[n]; <span class="hljs-comment">// vla</span>    pi[<span class="hljs-number">2</span>] = ar[<span class="hljs-number">2</span>] = <span class="hljs-number">-5</span>;    ...&#125;</code></pre><pre><code class="hljs c"><span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> m = <span class="hljs-number">6</span>;<span class="hljs-keyword">int</span> ar2[n][m]; <span class="hljs-comment">// n x m VLA</span><span class="hljs-keyword">int</span> (* p2)[<span class="hljs-number">6</span>]; <span class="hljs-comment">// works pre-C99</span><span class="hljs-keyword">int</span> (* p3)[m]; <span class="hljs-comment">// requires VLA support</span>p2 = (<span class="hljs-keyword">int</span> (*)[<span class="hljs-number">6</span>]) <span class="hljs-built_in">malloc</span>(n * <span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)); <span class="hljs-comment">// n * 6 array</span>p3 = (<span class="hljs-keyword">int</span> (*)[m]) <span class="hljs-built_in">malloc</span>(n * m * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)); <span class="hljs-comment">// n * m array</span><span class="hljs-comment">// above expression also requires VLA support</span>ar2[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = p2[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">12</span>;</code></pre><h2 id="4-Storage-Classes-and-Dynamic-Memory-Allocation"><a href="#4-Storage-Classes-and-Dynamic-Memory-Allocation" class="headerlink" title="(4) Storage Classes and Dynamic Memory Allocation"></a>(4) Storage Classes and Dynamic Memory Allocation</h2><p>You can think of a program as dividing its available memory into <strong>three separate sections</strong>: one for static variables with external linkage, internal linkage, and no linkage; one for automatic variables; and one for dynamically allocated memory.</p><p>The <strong>amount of memory</strong> needed for the <strong>static duration storage classes</strong> is known <strong>at compile time</strong>, and the data stored in this section is available as long as the program runs. Each variable of these classes comes into being when the program starts and expires when the program ends.</p><p>An <strong>automatic variable</strong>, however, comes into existence when a program <strong>enters the block</strong> of code containing the <strong>variable’s definition</strong> and expires when its <strong>block of code is exited</strong>. Therefore, as a<br>program calls functions and as functions terminate, the amount of memory used by automatic variables grows and shrinks. This section of memory is typically <strong>handled as a stack</strong>. That means new variables are added sequentially in memory as they are created and then are removed in the <strong>opposite order as they pass away</strong>.</p><p><strong>Dynamically allocated memory</strong> comes into existence when <strong>malloc()</strong> or a related function is called, and it’s freed when <strong>free() is called</strong>. Memory persistence is controlled by the programmer, not by a set of rigid rules, so a memory block can be created in one function and disposed of in another function. Because of this, the section of memory used for dynamic memory allocation can end up fragmented—that is, <strong>unused chunks could be interspersed among active blocks of memory</strong>. Also, using dynamic memory tends to be a <strong>slower process than using stack memory</strong>.</p><p>Typically, a program uses <strong>different regions of memory</strong> for static objects, automatic objects, and<br>dynamically allocated objects. </p><h1 id="4-ANSI-C-Type-Qualifiers"><a href="#4-ANSI-C-Type-Qualifiers" class="headerlink" title="4. ANSI C Type Qualifiers"></a>4. ANSI C Type Qualifiers</h1><h2 id="1-The-const-Type-Qualifier"><a href="#1-The-const-Type-Qualifier" class="headerlink" title="(1) The const Type Qualifier"></a>(1) The const Type Qualifier</h2><p>The <strong>const</strong> keyword in a declaration establishes a variable whose value <strong>cannot be modified</strong> by assignment or by incrementing or decrementing. </p><h2 id="2-The-volatile-Type-Qualifier"><a href="#2-The-volatile-Type-Qualifier" class="headerlink" title="(2) The volatile Type Qualifier"></a>(2) The volatile Type Qualifier</h2><p>The <strong>volatile</strong> qualifier tells the compiler that a variable can have its value <strong>altered by agencies</strong> other than the program. </p><p>It is typically used for hardware addresses and for data shared with other programs or threads running simultaneously. </p><p>For example, an address might hold the current clock time. The value at that address changes as time changes, regardless of what your program is doing. Or an address could be used to receive information transmitted from, say, another computer.</p><p>The syntax is the same as for const:</p><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> loc1; <span class="hljs-comment">/* loc1 is a volatile location */</span><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> * ploc; <span class="hljs-comment">/* ploc points to a volatile location */</span></code></pre><p>These statements declare <code>loc1</code> to be a <strong>volatile</strong> value and <code>ploc</code> to <strong>point to a volatile</strong> value.</p><p><strong>volatile</strong> facilitates compiler optimization. </p><h2 id="3-The-restrict-Type-Qualifier"><a href="#3-The-restrict-Type-Qualifier" class="headerlink" title="(3) The restrict Type Qualifier"></a>(3) The restrict Type Qualifier</h2><p>The <strong>restrict</strong> keyword enhances computational support by giving the compiler permission to optimize certain kinds of code. </p><p>It can be applied only to <strong>pointers</strong>, and it indicates that a <strong>pointer</strong> is the <strong>sole initial means</strong> of accessing a data object. </p><pre><code class="hljs c"><span class="hljs-keyword">int</span> ar[<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> * <span class="hljs-keyword">restrict</span> restar = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-keyword">int</span> * par = ar;</code></pre><p>Here, the pointer <code>restar</code> is the sole initial means of access to the memory allocated by <strong>malloc()</strong>. Therefore, it can be qualified with the keyword <strong>restrict</strong>. The pointer <code>par</code>, however, is neither the initial nor the sole means of access to the data in the ar array, so it cannot be qualified as <strong>restrict</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Character Strings and String Functions</title>
    <link href="/2020/12/01/Character-Strings-and-String-Functions/"/>
    <url>/2020/12/01/Character-Strings-and-String-Functions/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 11 Character Strings and String Functions</p><a id="more"></a><h1 id="1-Representing-Strings-and-String-I-O"><a href="#1-Representing-Strings-and-String-I-O" class="headerlink" title="1. Representing Strings and String I/O"></a>1. Representing Strings and String I/O</h1><p>The <strong>puts()</strong> function, like <strong>printf()</strong>, belongs to the the <strong>stdio.h</strong> family of <strong>input/output</strong> functions. It only displays <strong>strings</strong>, and, unlike <strong>printf()</strong>, it automatically <strong>appends a newline</strong> to the string it displays. </p><p>There are many ways to define a string. The principal ways are using string constants, using char arrays, and using char pointers. </p><p>A program should make sure there is a place to store a string.</p><h2 id="1-Character-String-Literals-String-Constants"><a href="#1-Character-String-Literals-String-Constants" class="headerlink" title="(1) Character String Literals (String Constants)"></a>(1) Character String Literals (String Constants)</h2><p>A <strong>string literal</strong>, also termed a <strong>string constant</strong>, is anything enclosed in <strong>double quotation marks</strong>. The enclosed characters, plus a terminating <code>\0</code> character automatically provided by the compiler, are stored in memory as a character string. </p><p><strong>Character string constants</strong> are placed in the <strong>static storage class</strong>, which means that if you use a <strong>string constant</strong> in a function, the string is <strong>stored just once</strong> and <strong>lasts for the duration of the program</strong>, even if the function is called several times. </p><h2 id="2-Character-String-Arrays-and-Initialization"><a href="#2-Character-String-Arrays-and-Initialization" class="headerlink" title="(2) Character String Arrays and Initialization"></a>(2) Character String Arrays and Initialization</h2><p>When you define a <strong>character string array</strong>, you must let the compiler know <strong>how much space</strong> is needed. </p><h1 id="2-Array-Versus-Pointer"><a href="#2-Array-Versus-Pointer" class="headerlink" title="2. Array Versus Pointer"></a>2. Array Versus Pointer</h1><p>In short, initializing the <strong>array</strong> copies a <strong>string</strong> from <strong>static storage</strong> to the <strong>array</strong>, whereas initializing the <strong>pointer</strong> merely copies the <strong>address</strong> of the <strong>string</strong>.</p><h2 id="1-Array-and-Pointer-Differences"><a href="#1-Array-and-Pointer-Differences" class="headerlink" title="(1) Array and Pointer Differences"></a>(1) Array and Pointer Differences</h2><p>The chief <strong>difference</strong> is that the <strong>array name</strong> is a <strong>constant</strong>, but the <strong>pointer</strong> is a variable. </p><p>In short, don’t use a <strong>pointer to a string literal</strong> if you plan to alter the string.</p><h2 id="2-Arrays-of-Character-Strings"><a href="#2-Arrays-of-Character-Strings" class="headerlink" title="(2) Arrays of Character Strings"></a>(2) Arrays of Character Strings</h2><p><img src="https://img-blog.csdnimg.cn/20190615215441173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="3-String-Input"><a href="#3-String-Input" class="headerlink" title="3. String Input"></a>3. String Input</h1><p>If you want to read a <strong>string</strong> into a program, you must first <strong>set aside space</strong> to store the <strong>string</strong> and then use an <strong>input function</strong> to fetch the string.</p><h2 id="1-Creating-Space"><a href="#1-Creating-Space" class="headerlink" title="(1) Creating Space"></a>(1) Creating Space</h2><p>The first order of business is setting up a place to put the string after it is read. </p><h2 id="2-The-Unfortunate-gets-Function"><a href="#2-The-Unfortunate-gets-Function" class="headerlink" title="(2) The Unfortunate gets() Function"></a>(2) The Unfortunate gets() Function</h2><p> It reads an entire <strong>line up</strong> through the <strong>newline character</strong>, <strong>discards</strong> the <strong>newline character</strong>, stores the remaining characters, <strong>adding a null character</strong> to create a C <strong>string</strong>. </p><p>It’s often paired with <strong>puts()</strong>, which displays a <strong>string</strong>, <strong>adding a newline</strong>. </p><p>The problem is that <strong>gets()</strong> doesn’t check to see if the input line actually fits into the array. </p><h2 id="3-The-fgets-Function"><a href="#3-The-fgets-Function" class="headerlink" title="(3) The fgets() Function"></a>(3) The fgets() Function</h2><p>The <strong>fgets()</strong> function meets the possible <strong>overflow</strong> problem by taking a second argument that <strong>limits the number of characters</strong> to be read. </p><p>This function is designed for <strong>file input</strong>, which makes it a little more awkward to use. Here is how <strong>fgets()</strong> differs from <strong>gets()</strong>:</p><ul><li><p>It takes a <strong>second argument</strong> indicating the <strong>maximum number of characters to read</strong>. If this argument has the value <strong>n</strong>, <strong>fgets()</strong> reads up to <strong>n-1</strong> characters or through the <strong>newline character</strong>, whichever comes first.</p></li><li><p>If <strong>fgets()</strong> reads the <strong>newline</strong>, it <strong>stores it in the string</strong>, unlike <strong>gets()</strong>, which discards it.</p></li><li><p>It takes a <strong>third argument</strong> indicating <strong>which file to read</strong>. To read from the <strong>keyboard</strong>, use <strong>stdin</strong> (for standard input) as the argument; this identifier is defined in <code>stdio.h</code>.</p><h3 id="Null-and-NULL"><a href="#Null-and-NULL" class="headerlink" title="Null and NULL"></a>Null and NULL</h3><p>The <strong>null character</strong>, or <strong>‘\0’</strong>, is the character used to mark the end of a <strong>C string</strong>. It’s the character whose code is <strong>zero</strong>. Because that isn’t the code of any character, it won’t show up accidentally in some other part of the string.</p></li></ul><p>The <strong>null pointer</strong>, or <strong>NULL</strong>, <strong>has a value</strong> that doesn’t correspond to a <strong>valid address</strong> of data. It’s often used by functions that otherwise return valid addresses to indicate some special occurrence, such as encountering <strong>end-of-file</strong> or failing to perform as expected.</p><p>So the <strong>null character</strong> is an <strong>integer type</strong>, while the <strong>null pointer</strong> is a <strong>pointer type</strong>. </p><h2 id="4-The-s-gets-Function"><a href="#4-The-s-gets-Function" class="headerlink" title="(4) The s _ gets() Function"></a>(4) The s _ gets() Function</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* st, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> * ret_val;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    ret_val = fgets(st, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span> (ret_val) <span class="hljs-comment">// i.e., ret_val != NULL</span>    &#123;        <span class="hljs-keyword">while</span> (st[i] != <span class="hljs-string">'\n'</span> &amp;&amp; st[i] != <span class="hljs-string">'\0'</span>)            i++;        <span class="hljs-keyword">if</span> (st[i] == <span class="hljs-string">'\n'</span>)            st[i] = <span class="hljs-string">'\0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">// must have words[i] == '\0'</span>            <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">'\n'</span>)                <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret_val;&#125;</code></pre><h1 id="4-String-Output"><a href="#4-String-Output" class="headerlink" title="4. String Output"></a>4. String Output</h1><h2 id="1-The-puts-Function"><a href="#1-The-puts-Function" class="headerlink" title="(1) The puts() Function"></a>(1) The puts() Function</h2><p>The <strong>puts()</strong> function is very easy to use. Just give it the <strong>address of a string</strong> for an argument.</p><p><strong>puts()</strong> automatically <strong>appends a newline</strong> when it displays a string.</p><h2 id="2-The-fputs-Function"><a href="#2-The-fputs-Function" class="headerlink" title="(2) The fputs() Function"></a>(2) The fputs() Function</h2><p>The <strong>fputs()</strong> function is the <strong>file-oriented</strong> version of <strong>puts()</strong>. The main differences are these:</p><ul><li><p>The <strong>fputs()</strong> function takes a <strong>second argument</strong> indicating the <strong>file</strong> to which to <strong>write</strong>. You can use <strong>stdout</strong> (for standard output), which is defined in <code>stdio.h</code>, as an argument to output to your display.</p></li><li><p>Unlike <strong>puts()</strong>, <strong>fputs()</strong> does not automatically append a <strong>newline</strong> to the output.</p></li></ul><p>Note that <strong>gets()</strong> discards a <strong>newline</strong> on input, but <strong>puts()</strong> adds a <strong>newline</strong> on output. On the other hand, <strong>fgets()</strong> stores the <strong>newline</strong> on input, and <strong>fputs()</strong> doesn’t add a <strong>newline</strong> on output. </p><p><strong>gets()</strong> returns the <strong>null pointer</strong> if it encounters <strong>end-of-file</strong>. The <strong>null pointer *<em>evaluates as *</em>zero</strong>, or <strong>false</strong>, so that terminates the loop.</p><h1 id="5-String-Functions"><a href="#5-String-Functions" class="headerlink" title="5. String Functions"></a>5. String Functions</h1><h2 id="1-The-strlen-Function"><a href="#1-The-strlen-Function" class="headerlink" title="(1) The strlen() Function"></a>(1) The strlen() Function</h2><p>The <strong>strlen()</strong> function, finds the <strong>length</strong> of a string. </p><h2 id="2-The-strcat-Function"><a href="#2-The-strcat-Function" class="headerlink" title="(2) The strcat() Function"></a>(2) The strcat() Function</h2><p>The <strong>strcat()</strong> (for string concatenation) function takes <strong>two strings for arguments</strong>. A copy of the second string is tacked onto the end of the first, and this combined version becomes the new first string. </p><p>The second string is <strong>not altered</strong>. The <strong>strcat()</strong> function is type <code>char *</code> (that is, a pointer-to-char).</p><p>It <strong>returns</strong> the value of its <strong>first argument</strong>—the <strong>address</strong> of the first character of the string to which the second string is appended.</p><h2 id="3-The-strncat-Function"><a href="#3-The-strncat-Function" class="headerlink" title="(3) The strncat() Function"></a>(3) The strncat() Function</h2><p>Alternatively, you can use <strong>strncat()</strong>, which takes a second argument indicating the <strong>maximum number of characters</strong> to add. For example, <code>strncat(bugs, addon, 13)</code> will add the contents of the <code>addon</code> string to bugs, stopping when it reaches <code>13</code> additional characters or the <strong>null character</strong>, whichever comes first. </p><h2 id="4-The-strcmp-Function"><a href="#4-The-strcmp-Function" class="headerlink" title="(4) The strcmp() Function"></a>(4) The strcmp() Function</h2><p>These results suggest that <strong>strcmp()</strong> returns a <strong>negative number</strong> if the <strong>first string precedes the second</strong> alphabetically and that it <strong>returns a positive number</strong> if the order is the other way.  It returns <strong>0</strong> if they are the <strong>same</strong>.</p><p>The <strong>strcmp()</strong> function is for <strong>comparing strings</strong>, not <strong>characters</strong>.</p><h2 id="5-The-strncmp-Variation"><a href="#5-The-strncmp-Variation" class="headerlink" title="(5) The strncmp() Variation"></a>(5) The strncmp() Variation</h2><p>The <strong>strncmp()</strong> function compares the strings until they differ or until it has compared a number of characters specified by a third argument.</p><h2 id="6-The-sprintf-Function"><a href="#6-The-sprintf-Function" class="headerlink" title="(6) The sprintf() Function"></a>(6) The sprintf() Function</h2><p>The <strong>sprintf()</strong> function is declared in <code>stdio.h</code> instead of <code>string.h</code>. It works like <strong>printf()</strong>, but it <strong>writes</strong> to a string instead of writing to a display. </p><h2 id="7-Other-String-Functions"><a href="#7-Other-String-Functions" class="headerlink" title="(7) Other String Functions"></a>(7) Other String Functions</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2)</span></span>;</code></pre><p>This function <strong>copies *<em>the string (including the *</em>null character</strong>) pointed to by <code>s2</code> to the location pointed to by <code>s1</code>. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strncpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>This function <strong>copies</strong> to the location pointed to by <code>s1</code> no more than <code>n</code> characters from the string pointed to by <code>s2</code>. The return value is <code>s1</code>. No characters after a <strong>null character</strong> are copied and, if the source string is shorter than <code>n</code> characters, the <strong>target string</strong> is padded with <strong>null characters</strong>. If the source string has <code>n</code> or more characters, <strong>no null character is copied</strong>. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2)</span></span>;</code></pre><p>The string pointed to by <code>s2</code> is copied to the <strong>end of the string</strong> pointed to by <code>s1</code>. The first character of the <code>s2</code> string is copied <strong>over the null character</strong> of the <code>s1</code> string. The <strong>return value</strong> is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strncat</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>No more than the first <code>n</code> characters of the <code>s2</code> string are appended to the <code>s1</code> string, with the first character of the <code>s2</code> string being copied <strong>over the null character</strong> of the <code>s1</code> string. The <strong>null character</strong> and any characters following it in the <code>s2</code> string are <strong>not copied</strong>, and a <strong>null character</strong> is appended to the result. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>positive value</strong> if the <code>s1</code> string follows the <code>s2</code> string in the machine collating sequence, the value <strong>0</strong> if the two strings are <strong>identical</strong>, and a <strong>negative</strong> value if the <strong>first string</strong> precedes the <strong>second string</strong> in the machine collating sequence.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strncmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>This function works like <strong>strcmp()</strong>, except that the comparison stops after <code>n</code> characters or when the first <strong>null character</strong> is encountered, whichever comes first.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s, <span class="hljs-keyword">int</span> c)</span></span>;</code></pre><p>This function <strong>returns a pointer to the first location</strong> in the string <code>s</code> that holds the character <code>c</code>. (The terminating <strong>null character</strong> is part of the string, so it can be searched for.) The function returns the <strong>null pointer</strong> if the character is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strpbrk</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>pointer to the first location</strong> in the string <code>s1</code> that holds <strong>any character</strong> found in the <code>s2</code> string. The function returns the <strong>null pointer</strong> if no character is found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strrchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s, <span class="hljs-keyword">int</span> c)</span></span>;</code></pre><p>This function returns a <strong>pointer to the last occurrence of the character</strong> <code>c</code> in the strings. (The terminating <strong>null character</strong> is part of the string, so it can be searched for.) The function returns the <strong>null pointer</strong> if the character is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>pointer to the first occurrence</strong> of string <code>s2</code> in string <code>s1</code>. The function returns the <strong>null pointer</strong> if the string is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s)</span></span>;</code></pre><p>This function returns the <strong>number of characters</strong>, not including the terminating <strong>null character</strong>, found in the <strong>strings</strong>.</p><h1 id="6-Command-Line-Arguments"><a href="#6-Command-Line-Arguments" class="headerlink" title="6. Command-Line Arguments"></a>6. Command-Line Arguments</h1><p><img src="_v_images/20201201201425398_503175558.png" srcset="/img/loading.gif" alt=""><br>A C program reads these items by using arguments to <strong>main()</strong>.</p><pre><code class="hljs c"><span class="hljs-comment">/* 11.31 repeat.c -- main() with arguments */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> count;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"The command line has %d arguments:\n"</span>, argc - <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (count = <span class="hljs-number">1</span>; count &lt; argc; count++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: %s\n"</span>, count, argv[count]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs bash">$ repeat Resistance is futile</code></pre><p>repeat is the name of the program.</p><pre><code class="hljs vim"><span class="hljs-built_in">argv</span>[<span class="hljs-number">0</span>] points <span class="hljs-keyword">to</span> <span class="hljs-built_in">repeat</span> (<span class="hljs-keyword">for</span> most systems)<span class="hljs-built_in">argv</span>[<span class="hljs-number">1</span>] points <span class="hljs-keyword">to</span> Resistance<span class="hljs-built_in">argv</span>[<span class="hljs-number">2</span>] points <span class="hljs-keyword">to</span> <span class="hljs-keyword">is</span><span class="hljs-built_in">argv</span>[<span class="hljs-number">3</span>] points <span class="hljs-keyword">to</span> futile</code></pre><p>output:</p><pre><code class="hljs c">The command <span class="hljs-built_in">line</span> has <span class="hljs-number">3</span> arguments:<span class="hljs-number">1</span>: Resistance<span class="hljs-number">2</span>: is<span class="hljs-number">3</span>: futile</code></pre><p>C compilers allow <strong>main()</strong> to have <strong>no arguments</strong> or else to have <strong>two arguments</strong>. (Some implementations allow additional arguments, but that would be an extension of the standard.) </p><p>With two arguments, the <strong>first argument</strong> is the number of strings in the command line. </p><p>The system uses <strong>spaces</strong> to tell when one string ends and the next begins. Therefore, the repeat example has <strong>four strings</strong>, including the command <strong>name</strong>. </p><p>The program stores the command line strings in memory and stores the <strong>address of each string</strong> in an <strong>array of pointers</strong>. </p><p>The address of this array is stored in the <strong>second argument</strong>.</p><h1 id="7-String-to-Number-Conversions"><a href="#7-String-to-Number-Conversions" class="headerlink" title="7. String-to-Number Conversions"></a>7. String-to-Number Conversions</h1><h2 id="1-atoi"><a href="#1-atoi" class="headerlink" title="(1) atoi( )"></a>(1) atoi( )</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*str)</span></span>;</code></pre><p>It takes a <strong>string</strong> str as  an argument and returns the corresponding <strong>integer value</strong>.  The <code>stdlib.h</code> header contains the function declaration<br>for <strong>atoi()</strong>.</p><p>该函数会扫描字符串，跳过空白字符，直到遇到数字或者正负符号才开始转换，一直到遇到非数字或者字符串结束符 <strong>‘\0’</strong> 结束扫描，如果一开始扫描到是非数字，则结束扫描，未扫描到数字返回数字 <strong>0</strong>，否则返回转换后的数字，能识别<strong>正负号</strong>。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> i,j;  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)  &#123;    j = atoi(argv[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %-10scorresponding integer: %d\n"</span>,argv[i], j);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>output:</p><pre><code class="hljs c">./atoi1.o jds323sd <span class="hljs-number">898</span>dsj23 js<span class="hljs-number">-98</span>dk +<span class="hljs-number">23</span>sd33 <span class="hljs-number">-92</span>d89s i<span class="hljs-number">-988</span>sj<span class="hljs-built_in">string</span>: jds323sd  corresponding integer: <span class="hljs-number">0</span><span class="hljs-built_in">string</span>: <span class="hljs-number">898</span>dsj23  corresponding integer: <span class="hljs-number">898</span><span class="hljs-built_in">string</span>: js<span class="hljs-number">-98</span>dk   corresponding integer: <span class="hljs-number">0</span><span class="hljs-built_in">string</span>: +<span class="hljs-number">23</span>sd33   corresponding integer: <span class="hljs-number">23</span><span class="hljs-built_in">string</span>: <span class="hljs-number">-92</span>d89s   corresponding integer: <span class="hljs-number">-92</span><span class="hljs-built_in">string</span>: i<span class="hljs-number">-988</span>sj   corresponding integer: <span class="hljs-number">0</span></code></pre><p>Implementation of <strong>atoi()</strong>:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *st)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sign, ret;    ret = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(*st))        st++;    sign = (*st == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(*st == <span class="hljs-string">'+'</span> || *st == <span class="hljs-string">'-'</span>)        st++;    <span class="hljs-keyword">for</span>( ; *st; st++)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*st))            ret = *st - <span class="hljs-string">'0'</span> + ret * <span class="hljs-number">10</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">return</span> sign * ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)    &#123;        n = atoi(argv[i]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %10sint: %d;\n"</span>, argv[i], n);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>output:</p><pre><code class="hljs c">./atoi.o sdj87<span class="hljs-number">-08</span> <span class="hljs-number">98</span>sjd09 <span class="hljs-number">-98</span>sd88 <span class="hljs-number">-09</span>sdj88<span class="hljs-built_in">string</span>:   sdj87<span class="hljs-number">-08</span><span class="hljs-keyword">int</span>: <span class="hljs-number">0</span>;<span class="hljs-built_in">string</span>:    <span class="hljs-number">98</span>sjd09<span class="hljs-keyword">int</span>: <span class="hljs-number">98</span>;<span class="hljs-built_in">string</span>:    <span class="hljs-number">-98</span>sd88<span class="hljs-keyword">int</span>: <span class="hljs-number">-98</span>;<span class="hljs-built_in">string</span>:   <span class="hljs-number">-09</span>sdj88<span class="hljs-keyword">int</span>: <span class="hljs-number">-9</span>;```                                                                                                                                                                                ## (<span class="hljs-number">2</span>) atof() ```c<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">atof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;</code></pre><p>该函数将参数 <strong>str</strong> 所指向的字符串转换为一个<strong>double</strong> 型浮点数。</p><p>浮点数合法表示:</p><pre><code class="hljs angelscript"><span class="hljs-number">3.123</span><span class="hljs-number">.2</span><span class="hljs-number">-.32</span><span class="hljs-number">2e-2</span><span class="hljs-number">2.E-2</span><span class="hljs-number">.3e-2</span></code></pre><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *ret, *<span class="hljs-built_in">find</span>;    ret = fgets(s, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span>(ret)    &#123;        <span class="hljs-built_in">find</span> = <span class="hljs-built_in">strchr</span>(s, <span class="hljs-string">'\n'</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>)        &#123;            *<span class="hljs-built_in">find</span> = <span class="hljs-string">'\0'</span>;        &#125;        <span class="hljs-keyword">else</span>        <span class="hljs-keyword">while</span>(getchar() != <span class="hljs-string">'\n'</span>)            <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> n;    <span class="hljs-keyword">char</span> s[<span class="hljs-number">10</span>];    <span class="hljs-keyword">while</span>(s_gets(s, <span class="hljs-number">10</span>) &amp;&amp; s[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span>)    &#123;        n = atof(s);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %s, float: %f\n"</span>, s, n); <span class="hljs-comment">//printf()输出双精度也是%f,输出形式为小数点形式</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Answer:</p><pre><code class="hljs c"><span class="hljs-number">.023e-3</span><span class="hljs-number">.2</span>sj<span class="hljs-built_in">string</span>: <span class="hljs-number">.023e-3</span><span class="hljs-number">.2</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000023</span><span class="hljs-number">-.32</span><span class="hljs-number">.3e2</span><span class="hljs-built_in">string</span>: <span class="hljs-number">-.32</span><span class="hljs-number">.3e2</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">-0.320000</span>sj3<span class="hljs-built_in">string</span>: sj3, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span>.e3<span class="hljs-built_in">string</span>: .e3, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span><span class="hljs-number">0.e3</span><span class="hljs-built_in">string</span>: <span class="hljs-number">0.e3</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span><span class="hljs-number">2.e-3</span><span class="hljs-number">.32</span><span class="hljs-built_in">string</span>: <span class="hljs-number">2.e-3</span><span class="hljs-number">.32</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.002000</span><span class="hljs-number">.22e-3</span><span class="hljs-built_in">string</span>: <span class="hljs-number">.22e-3</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000220</span></code></pre><p>Implementation of <strong>atof()</strong>:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEN 10</span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myatof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> s[LEN];    <span class="hljs-keyword">double</span> num;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter strings, enter a newline to quit:"</span>);    <span class="hljs-keyword">while</span>(s_gets(s,LEN) &amp;&amp; s[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span>)    &#123;        num = myatof(s);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %s, corresponding number: %f;\n"</span>, s,num);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *ret, *<span class="hljs-built_in">find</span>;    ret = fgets(s, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span>(ret)    &#123;        <span class="hljs-built_in">find</span> = <span class="hljs-built_in">strchr</span>(s,<span class="hljs-string">'\n'</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>)            *<span class="hljs-built_in">find</span> = <span class="hljs-string">'\0'</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">while</span>(getchar() != <span class="hljs-string">'\n'</span>)                <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myatof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sign, sign_e;    <span class="hljs-keyword">int</span> hasdot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> hasE = <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span> intpart = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">double</span> decpart = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">int</span> decdigit = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span> ret;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(*str))<span class="hljs-comment">//跳过开始的空格</span>        str++;      <span class="hljs-comment">//判断符号</span>    sign = (*str == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;    <span class="hljs-comment">//跳过符号位</span>    <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'-'</span> || *str == <span class="hljs-string">'+'</span>)        str++;    <span class="hljs-keyword">for</span>(;*str;str++)     &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*str)) <span class="hljs-comment">//计算整数部分</span>            intpart = <span class="hljs-number">10</span> * intpart + *str - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'.'</span>) <span class="hljs-comment">//小数点</span>        &#123;          hasdot = <span class="hljs-number">1</span>;          str++;          <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'e'</span> || *str == <span class="hljs-string">'E'</span>)<span class="hljs-comment">//科学计数法</span>        &#123;            hasE = <span class="hljs-number">1</span>;            str++;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//不合要求字符，退出</span>            <span class="hljs-keyword">return</span> sign * intpart;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">425 退出上面函数有一下情况：</span><span class="hljs-comment">426  1. 数字加非法字符：2s 直接计算结果后退出</span><span class="hljs-comment">427  2. 数字加小数点：2.</span><span class="hljs-comment">428  3. 数字加e或E：2e</span><span class="hljs-comment">429  4. e或E：e</span><span class="hljs-comment">430  5. 小数点：.</span><span class="hljs-comment">431  6. 非法字符：s 直接退出</span><span class="hljs-comment">432 */</span>        <span class="hljs-keyword">for</span>( ; *str; str++)    &#123;        <span class="hljs-keyword">if</span>(hasdot &amp;&amp; <span class="hljs-built_in">isdigit</span>(*str)) <span class="hljs-comment">//两种表达：2.3 .3; </span>        <span class="hljs-comment">//2.34小数部分计算：3 / 10  + 4 / (10 *10)</span>        <span class="hljs-comment">//pow() 函数位于math.h头文件中，计算幂，pow(10,2) == 10 * 10，但编译时要加lm</span>            decpart += (*str - <span class="hljs-string">'0'</span>) / <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span> , decdigit++);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasdot &amp;&amp; (*str == <span class="hljs-string">'e'</span> || *str ==<span class="hljs-string">'E'</span>))        <span class="hljs-comment">//情况：2.3e，.3e，.e;最后一种 .e 不合法，但最终计算结果还是为0</span>        &#123;            hasE = <span class="hljs-number">1</span>;            str++;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hasE) <span class="hljs-comment">//用科学计数法，但是前面没有小数点，情况：3e3 e3 3e- 3e+ 3e. 3ek </span>            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//遇到不合要求字符 3k 3.k 3.3k .k; 不存在有科学计数法 e 或 E情况 </span>            <span class="hljs-keyword">return</span> sign * (intpart + decpart);    &#125;    <span class="hljs-comment">//退出有一下情况：</span>    <span class="hljs-comment">// 1. 扫描数字直到结束 1.23</span>    <span class="hljs-comment">// 2. 科学计数法，前面数字部分有小数点 或者没有</span>    <span class="hljs-comment">// 3. 扫描不合法字符退出函数</span>    sign_e = (*str == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>; <span class="hljs-comment">//指数部分符号</span>    <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'+'</span> || *str == <span class="hljs-string">'-'</span>)        str++;    <span class="hljs-keyword">for</span>( ; *str; str++)<span class="hljs-comment">//识别指数部分</span>    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*str))            <span class="hljs-built_in">exp</span> = <span class="hljs-built_in">exp</span> * <span class="hljs-number">10</span> + *str - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//非法字符</span>            <span class="hljs-keyword">break</span>;    &#125;    ret = sign * ( (intpart + decpart) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span> , sign_e * <span class="hljs-built_in">exp</span>) );    <span class="hljs-keyword">return</span> ret;&#125;</code></pre><h2 id="3-atol"><a href="#3-atol" class="headerlink" title="(3)  atol()"></a>(3)  atol()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">atol</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;</code></pre><p>该函数将参数 <strong>str</strong> 所指向的字符串转换为<strong>long int</strong>。</p><h2 id="4-strtol"><a href="#4-strtol" class="headerlink" title="(4) strtol()"></a>(4) strtol()</h2><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strtol</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr, <span class="hljs-keyword">int</span> <span class="hljs-keyword">base</span></span>)</span>;</code></pre><p><strong>string to long int</strong>，该函数把参数 <strong>str</strong> 所指向的字符串根据给定的 <strong>base</strong> 转换为<strong>long int</strong>，<strong>base</strong> 必须介于 <strong>2</strong> 和 <strong>36</strong>（包含）之间，或者是特殊值 <strong>0</strong>。<br>&nbsp;<br>参数说明:<br><strong>str</strong>: 要转换的字符串，起始扫描时会跳过开头的空白字符，直到遇到数字或者正负符号开始做转换，知道遇到不合条件字符或者字符串结束字符才结束。<br>&nbsp;<br><strong>endptr</strong>: 指向指针的指针，<strong>*endptr</strong> 为指向第一个非法字符。<br>&nbsp;<br><strong>base</strong>: 基数。代表将 <strong>str</strong> 进行转换采用的进制。范围为 <strong>2~36</strong>，或者 <strong>0</strong>；<br>如 <strong>base</strong> 是 <strong>0</strong>，默认采用 <strong>10</strong> 进制，但如果遇到 <strong>‘0x’</strong> 或者 <strong>‘0X’</strong> 前置的字符，采用 <strong>16</strong> 进制，遇到 <strong>‘0’</strong> 前置非第一种情况，则用 <strong>8</strong> 进制。<br>&nbsp;<br><strong>返回值</strong>: 函数返回转换后的长整型数字，若无有效数字，返回 <strong>0</strong>。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> *end1, *end2;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> n1, n2;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)    &#123;         n1 = strtol(argv[i], &amp;end1, <span class="hljs-number">10</span>);        n2 = strtol(argv[i], &amp;end2, <span class="hljs-number">16</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string%d: %15s, base 10 input, base 10 output: %ld, stopped at %s"</span>        <span class="hljs-string">" (%d);\n"</span>,i, argv[i], n1, end1, *end1);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string%d: %15s, base 16 input, base 10 output: %ld, stopped at %s"</span>         <span class="hljs-string">" (%d);\n"</span>,i, argv[i], n2, end2, *end2);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="5-strtod"><a href="#5-strtod" class="headerlink" title="(5) strtod()"></a>(5) strtod()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">strtod</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr)</span></span>;</code></pre><p><strong>string to double</strong>，将参数 <strong>str</strong> 所指向的字符串转换为<strong>double</strong>型浮点数。</p><p>该函数返回转换后的<strong>double</strong>浮点数，如果没有执行有效的转换，则返回零（<strong>0.0</strong>）。</p><h2 id="6-strtoul"><a href="#6-strtoul" class="headerlink" title="(6) strtoul()"></a>(6) strtoul()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strtoul</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr, <span class="hljs-keyword">int</span> base)</span></span>;</code></pre><p><strong>string to unsigned long int</strong>，参数<strong>str</strong>所指向的字符串根据给定的<strong>base</strong>转换为<strong>unsigned long int</strong>型，<strong>base</strong>必须介于 <strong>2</strong> 和 <strong>36</strong>（包含）之间，或者是特殊值<strong>0</strong>。</p><p>该函数返回转换后的<strong>unsigned long int</strong>长整数，如果没有执行有效的转换，则返回 <strong>0</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arrays and Pointers</title>
    <link href="/2020/11/30/Arrays-and-Pointers/"/>
    <url>/2020/11/30/Arrays-and-Pointers/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 10 Arrays and Pointers</p><a id="more"></a><h1 id="1-Arrays"><a href="#1-Arrays" class="headerlink" title="1. Arrays"></a>1. Arrays</h1><p>An array is composed of a series of elements of <strong>one data type</strong>.</p><h2 id="1-Initialization"><a href="#1-Initialization" class="headerlink" title="(1) Initialization"></a>(1) Initialization</h2><pre><code class="hljs c"><span class="hljs-keyword">int</span> powers[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>&#125;; <span class="hljs-comment">/* ANSI C and later */</span></code></pre><p>As you can see, you initialize an array by using a <strong>comma-separated</strong> list of values enclosed in braces. You can use spaces between the values and the commas, if you want.</p><p>Sometimes you might use an array that’s intended to be a <strong>read-only</strong> array. In such cases, you can, and should, use the <strong>const</strong> keyword when you declare and initialize the array.</p><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;</code></pre><p><strong>C99</strong> added a new capability: <strong>designated initializers</strong>. This feature allows you to pick and choose which elements are initialized.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>, [<span class="hljs-number">4</span>] = <span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>, [<span class="hljs-number">1</span>] = <span class="hljs-number">29</span>&#125;;</code></pre><p><strong>First</strong>, if the code follows a designated initializer with further values, as in the sequence [4] = 31,30,31, these further values are used to initialize the subsequent elements. That is, after initializing <code>days[4]</code> to <code>31</code>, the code initializes <code>days[5]</code> and <code>days[6]</code> to <code>30</code> and <code>31</code>, respectively. </p><p><strong>Second</strong>, if the code initializes a particular element to a value <strong>more than once</strong>, the <strong>last initialization</strong> is the one that takes effect.</p><h2 id="2-Assigning-Array-Values"><a href="#2-Assigning-Array-Values" class="headerlink" title="(2) Assigning Array Values"></a>(2) Assigning Array Values</h2><p><strong>C doesn’t let you assign one array to another as a unit. Nor can you use the list-in-braces form except when initializing.</strong></p><pre><code class="hljs c"><span class="hljs-keyword">int</span> oxen[SIZE] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>&#125;; <span class="hljs-comment">/* ok here */</span><span class="hljs-keyword">int</span> yaks[SIZE];yaks = oxen; <span class="hljs-comment">/* not allowed */</span>yaks[SIZE] = oxen[SIZE]; <span class="hljs-comment">/* out of range */</span> oxen[SIZE<span class="hljs-number">-1</span>] is the last element of <span class="hljs-built_in">array</span> oxenyaks[SIZE] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>&#125;; <span class="hljs-comment">/* doesn't work */</span></code></pre><p><strong>Why can’t assign one array to another as a unit</strong><br>From <code>The C Programming Language</code></p><blockquote><p>There is one difference between an <strong>array name</strong> and a <strong>pointer</strong> that must be kept in mind. A <strong>pointer</strong> is a variable. But an <strong>array name</strong> is not a variable;</p></blockquote><blockquote><p>The <strong>array name</strong> is the <strong>address</strong> of the zeroth element.</p></blockquote><p>理解：<br>数组名为第一个元素的地址，是常量，不能被赋值。</p><h2 id="3-Array-Bounds"><a href="#3-Array-Bounds" class="headerlink" title="(3) Array Bounds"></a>(3) Array Bounds</h2><p>The compiler doesn’t check to see <strong>whether the indices are valid</strong>. The result of using a bad index is, in the language of the C standard, undefined. That means when you run the program, it might seem to work, it might work oddly, or it might abort.</p><h2 id="4-Multidimensional-Arrays"><a href="#4-Multidimensional-Arrays" class="headerlink" title="(4) Multidimensional Arrays"></a>(4) Multidimensional Arrays</h2><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> rain[YEARS][MONTHS] =&#123;&#123;<span class="hljs-number">4.3</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">2.4</span>,<span class="hljs-number">3.5</span>,<span class="hljs-number">6.6</span>&#125;,&#123;<span class="hljs-number">8.5</span>,<span class="hljs-number">8.2</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">1.6</span>,<span class="hljs-number">2.4</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">5.2</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">1.4</span>,<span class="hljs-number">7.3</span>&#125;,&#123;<span class="hljs-number">9.1</span>,<span class="hljs-number">8.5</span>,<span class="hljs-number">6.7</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">2.1</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">1.1</span>,<span class="hljs-number">2.3</span>,<span class="hljs-number">6.1</span>,<span class="hljs-number">8.4</span>&#125;,&#123;<span class="hljs-number">7.2</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">8.4</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">1.7</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">6.2</span>&#125;,&#123;<span class="hljs-number">7.6</span>,<span class="hljs-number">5.6</span>,<span class="hljs-number">3.8</span>,<span class="hljs-number">2.8</span>,<span class="hljs-number">3.8</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.3</span>,<span class="hljs-number">2.6</span>,<span class="hljs-number">5.2</span>&#125;&#125;;</code></pre><h1 id="2-Pointers-and-Arrays"><a href="#2-Pointers-and-Arrays" class="headerlink" title="2. Pointers and Arrays"></a>2. Pointers and Arrays</h1><p>An <strong>array name</strong> is also the address of the first element of the array. </p><p>That is, if <code>flizny</code> is an <strong>array</strong>, the following is true:</p><pre><code class="hljs c">flizny == &amp;flizny[<span class="hljs-number">0</span>]; <span class="hljs-comment">// name of array is the address of the first element</span></code></pre><p>Both are <strong>constants</strong> because they <strong>remain fixed</strong> for the duration of the program. </p><pre><code class="hljs c">dates + <span class="hljs-number">2</span> == &amp;date[<span class="hljs-number">2</span>] <span class="hljs-comment">// same address</span>*(dates + <span class="hljs-number">2</span>) == dates[<span class="hljs-number">2</span>] <span class="hljs-comment">// same value</span></code></pre><pre><code class="hljs c"><span class="hljs-comment">/* day_mon3.c -- uses pointer notation */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MONTHS 12</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<span class="hljs-keyword">int</span> index;<span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; MONTHS; index++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Month %2d has %d days.\n"</span>, index +<span class="hljs-number">1</span>,*(days + index)); <span class="hljs-comment">// same as days[index]</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Here, <code>days</code> is the address of the first element of the array, <code>days + index</code> is the address of element <code>days[index]</code>, and <code>*(days + index)</code> is the value of that element, just as <code>days[index]</code> is. </p><h1 id="3-Functions-Arrays-and-Pointers"><a href="#3-Functions-Arrays-and-Pointers" class="headerlink" title="3. Functions, Arrays, and Pointers"></a>3. Functions, Arrays, and Pointers</h1><pre><code class="hljs c"><span class="hljs-keyword">int</span>* ar:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;</code></pre><p>The form <code>int* ar</code> always means that ar is type <strong>pointer-to-int</strong>. The form <code>int ar[]</code> also means that <code>ar</code> is type <strong>pointer-to-int</strong>, but only when used to declare <strong>formal parameters</strong>. </p><p>The idea is that the second form reminds the reader that not only does <code>ar</code> point to an int, it points to an int that’s an element of an array.</p><p>In this context, and only in this context, C interprets <code>int ar[]</code> to mean the same as <code>int* ar</code>; that is, <code>ar</code> is type <strong>pointer-to-int</strong>.</p><p>Because <strong>prototypes</strong> allow you to omit a name, all four of the following prototypes are equivalent:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *, <span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [], <span class="hljs-keyword">int</span>)</span></span>;</code></pre><p>You <strong>can’t omit names</strong> in function definitions, so, for definitions, the following two forms are equivalent:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// code goes here</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;&#123;<span class="hljs-comment">// code goes here</span>&#125;</code></pre><p><strong>Dereferencing an Uninitialized Pointer:</strong> Do not dereference an uninitialized pointer. For example, consider the following:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt; <span class="hljs-comment">// an uninitialized pointer</span>*pt = <span class="hljs-number">5</span>; <span class="hljs-comment">// a terrible error</span></code></pre><p>The second line means store the value <code>5</code> in the location to which <code>pt</code> points. But <code>pt</code>, being <strong>uninitialized</strong>, has a random value, so there is no knowing where the <code>5</code> will be placed. It might go somewhere harmless, it might overwrite data or code, or it might cause the program to crash. </p><h1 id="4-Using-Pointer-Parameters"><a href="#4-Using-Pointer-Parameters" class="headerlink" title="4. Using Pointer Parameters"></a>4. Using Pointer Parameters</h1><p>A function working on an array needs to know where to start and stop. </p><p>The two expressions <code>ar[i]</code> and <code>*(ar+i)</code> are equivalent in meaning. Both work if ar is the name of an <strong>array</strong>, and both work if ar is a <strong>pointer</strong> variable.<br>However, using an expression such as <code>ar++</code> only works if <code>ar</code> is a <strong>pointer</strong> variable.</p><p>You must use <strong>pointers</strong> if you want a function to affect variables in the calling function. The second use is in functions designed to manipulate arrays.</p><h1 id="5-Protecting-Array-Contents"><a href="#5-Protecting-Array-Contents" class="headerlink" title="5. Protecting Array Contents"></a>5. Protecting Array Contents</h1><p>The usual rule is to pass quantities by value unless the program needs to alter the value, in which case you pass a pointer. </p><p>Arrays don’t give you that choice; you must pass a pointer. The reason is efficiency. </p><p>If a function passed an array by value, it would have to allocate enough space to hold a copy of the original array and then copy all the data from the original array to the new array. </p><p>It is much quicker to pass the address of the array and have the function work with the original data.</p><h1 id="6-Using-const-with-Formal-Parameters"><a href="#6-Using-const-with-Formal-Parameters" class="headerlink" title="6. Using const with Formal Parameters"></a>6. Using const with Formal Parameters</h1><p>If a function’s intent is that it not change the contents of the array, use the keyword <strong>const</strong> when declaring the formal parameter in the prototype and in the <strong>function definition</strong>. </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>; <span class="hljs-comment">/* prototype */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">/* definition */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; n; i++)        total += ar[i];    <span class="hljs-keyword">return</span> total;&#125;</code></pre><p>It’s important to understand that using <strong>const</strong> this way <strong>does not require that the original array be constant</strong>; it just says that the function has to treat the array as though it were constant. </p><p>It prevents a function from modifying data in the calling function. </p><p><strong>There are some rules you should know about pointer assignments and const.</strong></p><p><strong>First</strong>, it’s valid to <strong>assign</strong> the <strong>address</strong> of either <strong>constant data</strong> or <strong>non-constant</strong> data to a <strong>pointer-to-constant</strong>:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> locked[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0.08</span>, <span class="hljs-number">0.075</span>, <span class="hljs-number">0.0725</span>, <span class="hljs-number">0.07</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *pc = rates; <span class="hljs-comment">// valid</span>pc = locked; <span class="hljs-comment">// valid</span>pc = &amp;rates[<span class="hljs-number">3</span>]; <span class="hljs-comment">// valid</span></code></pre><p><strong>However</strong>, only the addresses of <strong>non-constant data</strong> can be assigned to <strong>regular pointers</strong>:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> locked[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0.08</span>, <span class="hljs-number">0.075</span>, <span class="hljs-number">0.0725</span>, <span class="hljs-number">0.07</span>&#125;;<span class="hljs-keyword">double</span> *pnc = rates; <span class="hljs-comment">// valid</span>pnc = locked; <span class="hljs-comment">// not valid</span>pnc = &amp;rates[<span class="hljs-number">3</span>]; <span class="hljs-comment">// valid</span></code></pre><p>This is a reasonable rule. Otherwise, you could use the pointer to change data that was supposed to be constant.</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">double</span>* <span class="hljs-keyword">const</span> pc = rates; <span class="hljs-comment">// pc points to beginning of the array</span>pc = &amp;rates[<span class="hljs-number">2</span>]; <span class="hljs-comment">// not allowed to point elsewhere</span>*pc = <span class="hljs-number">92.99</span>; <span class="hljs-comment">// ok -- changes rates[0]</span></code></pre><h1 id="7-Pointers-and-Multidimensional-Arrays"><a href="#7-Pointers-and-Multidimensional-Arrays" class="headerlink" title="7. Pointers and Multidimensional Arrays"></a>7. Pointers and Multidimensional Arrays</h1><p><img src="https://img-blog.csdnimg.cn/20190604210825828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1-Pointers-to-Multidimensional-Arrays"><a href="#1-Pointers-to-Multidimensional-Arrays" class="headerlink" title="(1) Pointers to Multidimensional Arrays"></a>(1) Pointers to Multidimensional Arrays</h2><pre><code class="hljs c"><span class="hljs-keyword">int</span> (*pz)[<span class="hljs-number">2</span>]; <span class="hljs-comment">// pz points to an array of 2 ints</span></code></pre><p>This statement says that <code>pz</code> is a pointer to an array of two ints. </p><p><code>[ ]</code> has a higher precedence than <code>*</code>. Therefore, with a declaration such as:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span>* pax[<span class="hljs-number">2</span>]; <span class="hljs-comment">// pax is an array of two pointers-to-int</span></code></pre><p>You can use notation such as <code>pz[2][1]</code>, even though <code>pz</code> is a <strong>pointer</strong>, not an <strong>array</strong> name. </p><p>More generally, you can represent individual elements by using <strong>array notation</strong> or <strong>pointer notation</strong> with either an <strong>array</strong> name or a <strong>pointer</strong>:</p><pre><code class="hljs c">zippo[m][n] == *(*(zippo + m) + n)pz[m][n] == *(*(pz + m) + n)</code></pre><h2 id="2-Pointer-Compatibility"><a href="#2-Pointer-Compatibility" class="headerlink" title="(2) Pointer Compatibility"></a>(2) Pointer Compatibility</h2><p>The rules for assigning one <strong>pointer</strong> to another are tighter than the rules for <strong>numeric types</strong>. </p><p>For example, you can assign an <strong>int</strong> value to a <strong>double</strong> variable without using a <strong>type conversion</strong>, but you can’t do the same for <strong>pointers</strong> to these two types:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;<span class="hljs-keyword">double</span> x;<span class="hljs-keyword">int</span> * p1 = &amp;n;<span class="hljs-keyword">double</span>* pd = &amp;x;x = n; <span class="hljs-comment">// implicit type conversion</span>pd = p1; <span class="hljs-comment">// compile-time error</span></code></pre><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt;<span class="hljs-keyword">int</span> (*pa)[<span class="hljs-number">3</span>];<span class="hljs-keyword">int</span> ar1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<span class="hljs-keyword">int</span> ar2[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> **p2; <span class="hljs-comment">// a pointer to a pointer</span>Then we have the following:pt = &amp;ar1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>pt = ar1[<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>pt = ar1; <span class="hljs-comment">// not valid</span>pa = ar1; <span class="hljs-comment">// both pointer-to-int[3]</span>pa = ar2; <span class="hljs-comment">// not valid</span>p2 = &amp;pt; <span class="hljs-comment">// both pointer-to-int *</span>*p2 = ar2[<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>p2 = ar2; <span class="hljs-comment">// not valid</span></code></pre><h2 id="3-Functions-and-Multidimensional-Arrays"><a href="#3-Functions-and-Multidimensional-Arrays" class="headerlink" title="(3) Functions and Multidimensional Arrays"></a>(3) Functions and Multidimensional Arrays</h2><p>You can declare a function parameter of this type like this:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">somefunction</span><span class="hljs-params">( <span class="hljs-keyword">int</span> (*pt)[<span class="hljs-number">4</span>])</span></span>; <span class="hljs-comment">// pt is a pointer to an array of four ints.</span></code></pre><p>Alternatively, if (and only if) <code>pt</code> is a <strong>formal parameter</strong> to a function, you can declare it as follows:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">somefunction</span><span class="hljs-params">( <span class="hljs-keyword">int</span> pt[][<span class="hljs-number">4</span>] )</span></span>;</code></pre><p><strong>Note that the first set of brackets is empty. The empty brackets identify pt as being a pointer.</strong></p><p>Recall that the compiler converts <strong>array</strong> notation to <strong>pointer</strong> notation. This means, for example, that <code>ar[1]</code> will become <code>ar+1</code>. For the compiler to evaluate this, it needs to know the size object to which ar points. </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[][<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// valid declaration</span></code></pre><p>says that <code>ar</code> points to an array of four ints.</p><p>You can also include a size in the other bracket pair, as shown here, but the compiler ignores it: </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// valid declaration, 3 ignored</span></code></pre><p>In general, to declare a <strong>pointer</strong> corresponding to an <strong>N-dimensional array</strong>, <strong>you must supply values for all but the leftmost set of brackets</strong>:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum4d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[][<span class="hljs-number">12</span>][<span class="hljs-number">20</span>][<span class="hljs-number">30</span>], <span class="hljs-keyword">int</span> rows)</span></span>;</code></pre><p>That’s because the <strong>first set of brackets</strong> indicates a <strong>pointer</strong>, whereas the rest of the brackets describe the type of data object <strong>being pointed to</strong>, as the following equivalent prototype illustrates:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum4d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*ar)[<span class="hljs-number">12</span>][<span class="hljs-number">20</span>][<span class="hljs-number">30</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// ar a pointer</span></code></pre><p>Here, ar points to a <code>12×20×30</code> array of ints.</p><h2 id="4-Variable-Length-Arrays-VLAs"><a href="#4-Variable-Length-Arrays-VLAs" class="headerlink" title="(4) Variable-Length Arrays (VLAs)"></a>(4) Variable-Length Arrays (VLAs)</h2><p><strong>VLAs Do Not Change Size</strong>:<br>The term <strong>variable in variable-length array</strong> does not mean that you can modify the length of the array after you create it. Once created, a <strong>VLA</strong> keeps the <strong>same size</strong>. What the term variable does mean is that you can use a variable when specifying the array dimensions when <strong>first creating the array</strong>.</p><p>First, here’s how to declare a function with a <strong>two-dimensional VLA</strong> argument:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">int</span> ar[rows][cols])</span></span>; <span class="hljs-comment">// ar a VLA</span></code></pre><p>One point to note is that a <strong>VLA</strong> declaration in a function definition parameter list doesn’t actually create an array. Just as with the old syntax, the <strong>VLA</strong> name really is a <strong>pointer</strong>. This means a function with a <strong>VLA</strong> parameter actually works with the data in the <strong>original array</strong>, and therefore has the ability to <strong>modify the array</strong> passed as an argument. </p><pre><code class="hljs c"><span class="hljs-keyword">int</span> thing[<span class="hljs-number">10</span>][<span class="hljs-number">6</span>];twoset(<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,thing);...<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">twoset</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> ar[n][m])</span> <span class="hljs-comment">// ar a pointer to</span></span><span class="hljs-function"><span class="hljs-comment">// an array of m ints</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp[n][m]; <span class="hljs-comment">// temp an n x m array of int</span>    temp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// set an element of temp to 2</span>    ar[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// set thing[0][0] to 2</span>&#125;</code></pre><p>When <code>twoset()</code> is called as shown, <code>ar</code> becomes a pointer to <code>thing[0]</code>, and <code>temp</code> is created as a <code>10×6</code>array. Because both <code>ar</code> and <code>thing</code> are pointers to <code>thing[0]</code>, <code>ar[0][0]</code> accesses the same data location as <code>thing[0][0]</code>.</p><p><strong>Variable-length</strong> arrays also allow for <strong>dynamic memory allocation</strong>. This means you can specify the size of the array while the program is running. </p><h1 id="8-Compound-Literals"><a href="#8-Compound-Literals" class="headerlink" title="8. Compound Literals"></a>8. Compound Literals</h1><p>Suppose you want to pass a value to a function with an <strong>int</strong> parameter; you can pass an <strong>int</strong> variable, but you also can pass an <strong>int constant</strong>, such as <strong>5</strong>. Before <strong>C99</strong>, the situation for a function with an <strong>array argument</strong> was different; you could pass an <strong>array</strong>, but there was no equivalent to an <strong>array constant</strong>. <strong>C99</strong> changed that with the addition of compound literals. </p><p><strong>Literals</strong> are <strong>constants</strong> that aren’t symbolic. For example, <strong>5</strong> is a type <strong>int literal</strong>, <strong>81.3</strong> is a <strong>type double literal</strong>, <strong>‘Y’</strong> is a type <strong>char literal</strong>, and <strong>“elephant”</strong> is a <strong>string literal</strong>. </p><p>For <strong>arrays</strong>, a <strong>compound literal</strong> looks like an <strong>array initialization list</strong> preceded by a type name that is enclosed in parentheses. For example, here’s an ordinary array declaration:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> diva[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;</code></pre><p>And here’s a compound literal that creates a nameless array containing the same two int values:</p><pre><code class="hljs c">(<span class="hljs-keyword">int</span> [<span class="hljs-number">2</span>])&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125; <span class="hljs-comment">// a compound literal</span></code></pre><p>Because these <strong>compound literals</strong> are nameless, you can’t just create them in one statement and then use them later. Instead, you have to use them somehow when you make them.<br>One way is to use a *<em>pointer *</em>to keep track of the location. That is, you can do something like this:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt1;pt1 = (<span class="hljs-keyword">int</span> [<span class="hljs-number">2</span>]) &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;</code></pre><p>Another thing you could do with a <strong>compound literal</strong> is pass it as an actual argument to a function with a matching formal parameter:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;...<span class="hljs-keyword">int</span> total3;total3 = sum((<span class="hljs-keyword">int</span> [])&#123;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>&#125;, <span class="hljs-number">6</span>);</code></pre><p>Keep in mind that a <strong>compound literal</strong> is a means for providing values that are needed only <strong>temporarily</strong>. It has block scope. That means its existence is not guaranteed once program execution leaves the block in which the compound literal is defined, that is, the innermost pair of braces containing the definition.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Functions</title>
    <link href="/2020/11/30/Functions/"/>
    <url>/2020/11/30/Functions/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 9 Functions</p><a id="more"></a><h1 id="1-Function-Arguments"><a href="#1-Function-Arguments" class="headerlink" title="1. Function Arguments"></a>1. Function Arguments</h1><h2 id="1-Defining-a-Function-with-an-Argument-Formal-Parameters"><a href="#1-Defining-a-Function-with-an-Argument-Formal-Parameters" class="headerlink" title="(1) Defining a Function with an Argument: Formal Parameters"></a>(1) Defining a Function with an Argument: Formal Parameters</h2><p>Formal parameters are local variables, private to the function.  </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dubs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span></span>;</code></pre><h2 id="2-Calling-a-Function-with-an-Argument-Actual-Arguments"><a href="#2-Calling-a-Function-with-an-Argument-Actual-Arguments" class="headerlink" title="(2) Calling a Function with an Argument: Actual Arguments"></a>(2) Calling a Function with an Argument: Actual Arguments</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_n_char</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> num)</span></span>;show_n_char(SPACE, <span class="hljs-number">12</span>);</code></pre><p>The <strong>actual arguments</strong> are the <code>space</code> character and <code>12</code>. These values are assigned to the corresponding <strong>formal parameters</strong> in <strong>show_n_char()</strong>—the variables <code>ch</code> and <code>num</code>. </p><p>In short, the <strong>formal parameter</strong> is a variable in the <strong>called function</strong>, and the <strong>actual argument</strong> is the particular value assigned to the function variable by the <strong>calling function</strong>. </p><p>The <strong>actual argument</strong> can be a constant, a variable, or an even more elaborate expression. Regardless of which it is, the <strong>actual argument</strong> is evaluated, and <strong>its value is copied to the corresponding formal parameter for the function</strong>.</p><p><strong>Because the called function works with data copied from the calling function, the original data in the calling function is protected from whatever manipulations the called function applies to the copies.</strong></p><h1 id="2-Returning-a-Value-from-a-Function-with-return"><a href="#2-Returning-a-Value-from-a-Function-with-return" class="headerlink" title="2. Returning a Value from a Function with return"></a>2. Returning a Value from a Function with return</h1><p>Using <strong>return</strong> has one other effect. It terminates the function and returns control to the next statement in the calling function. <strong>This occurs even if the return statement is not the last in the function.</strong></p><h1 id="3-Finding-Addresses-The-amp-Operator"><a href="#3-Finding-Addresses-The-amp-Operator" class="headerlink" title="3. Finding Addresses: The &amp; Operator"></a>3. Finding Addresses: The &amp; Operator</h1><p>One of the most important C concepts (and sometimes one of the most perplexing) is the <strong>pointer</strong>, which is a variable used to store an address.  </p><p>The unary <strong>&amp;</strong> operator gives you the address where a variable is stored. </p><h1 id="4-Pointers-A-First-Look"><a href="#4-Pointers-A-First-Look" class="headerlink" title="4. Pointers: A First Look"></a>4. Pointers: A First Look</h1><p>Basically, a <strong>pointer</strong> is a variable (or, more generally, a data object) whose value is a memory address. </p><pre><code class="hljs c">ptr = &amp;pooh; <span class="hljs-comment">// assigns pooh's address to ptr</span></code></pre><p>We say that ptr  “points to” pooh. The difference between ptr and &amp;pooh is that <strong>ptr</strong> is a variable, and <strong>&amp;pooh</strong> is a constant. </p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pi; <span class="hljs-comment">// pi is a pointer to an integer variable</span><span class="hljs-keyword">char</span> * pc; <span class="hljs-comment">// pc is a pointer to a character variable</span><span class="hljs-keyword">float</span> * pf, * pg; <span class="hljs-comment">// pf, pg are pointers to float variables</span></code></pre><p>A <strong>pointer</strong> really is a new type, not an <strong>integer</strong> type. Therefore, as mentioned before, ANSI C provides the <strong>%p</strong> form specifically for pointers.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Character Input/Output</title>
    <link href="/2020/11/29/Character-Input-Output/"/>
    <url>/2020/11/29/Character-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 8 Character Input/Output and Input Validation</p><a id="more"></a><h1 id="1-Single-Character-I-O-getchar-and-putchar"><a href="#1-Single-Character-I-O-getchar-and-putchar" class="headerlink" title="1. Single-Character I/O: getchar() and putchar()"></a>1. Single-Character I/O: getchar() and putchar()</h1><p><strong>getchar()</strong> and <strong>putchar()</strong> perform input and output one character at a time. </p><p>All it does is fetch characters from <strong>keyboard input</strong> and send them to the screen. This process is called <strong>echoing the input</strong>. </p><h1 id="2-Buffers"><a href="#2-Buffers" class="headerlink" title="2. Buffers"></a>2. Buffers</h1><h2 id="1-unbuffered-or-direct-input"><a href="#1-unbuffered-or-direct-input" class="headerlink" title="(1) unbuffered (or direct) input"></a>(1) unbuffered (or direct) input</h2><p>The characters you type are <strong>immediately made available</strong> to the waiting program. </p><h2 id="2-buffered-input"><a href="#2-buffered-input" class="headerlink" title="(2)  buffered input"></a>(2)  buffered input</h2><p>The characters you type are <strong>collected and stored in an area of temporary storage</strong> called a <strong>buffer</strong>.  Pressing <strong>Enter</strong> causes the block of characters you typed to be made available to your program. </p><h3 id="fully-buffered-I-O"><a href="#fully-buffered-I-O" class="headerlink" title="fully buffered I/O"></a>fully buffered I/O</h3><p>The <strong>buffer</strong> is flushed (the contents are sent to their destination) when it is <strong>full</strong>. This kind of buffering usually occurs with <strong>file input</strong>. </p><p>The buffer size depends on the system, but 512 bytes and 4096 bytes are common values. </p><h3 id="line-buffered-I-O"><a href="#line-buffered-I-O" class="headerlink" title="line-buffered I/O"></a>line-buffered I/O</h3><p>The <strong>buffer</strong> is flushed whenever a <strong>newline character shows up</strong>. <strong>Keyboard input</strong> is normally <strong>line buffered</strong>, so that pressing <strong>Enter</strong> flushes the buffer.</p><h1 id="3-Files-Streams-and-Keyboard-Input"><a href="#3-Files-Streams-and-Keyboard-Input" class="headerlink" title="3. Files, Streams, and Keyboard Input"></a>3. Files, Streams, and Keyboard Input</h1><h2 id="1-file"><a href="#1-file" class="headerlink" title="(1)  file"></a>(1)  file</h2><p>A <strong>file</strong> is an area of memory in which information is stored. </p><p>Conceptually, the C program deals with a <strong>stream</strong> instead of directly with a file. </p><h2 id="2-stream"><a href="#2-stream" class="headerlink" title="(2) stream"></a>(2) stream</h2><p>A <strong>stream</strong> is an idealized flow of data to which the actual input or output is mapped.</p><h1 id="4-The-End-of-File"><a href="#4-The-End-of-File" class="headerlink" title="4. The End of File"></a>4. The End of File</h1><p>A computer operating system needs some way to tell where each file begins and ends. </p><p>One method to detect the end of a file is to place a <strong>special character</strong> in the file to <strong>mark the end</strong>.</p><p>A second approach is for the operating system to store information on the size of the file.</p><p>C handles this variety of methods by having the  <strong>getchar()</strong>  function return a special value when the end of a file is reached, regardless of how the operating system actually detects the end of file. The name given to this value is <strong>EOF</strong> (end of file). </p><p>Therefore, the <strong>return value</strong> for <strong>getchar()</strong> when it detects an end of file is <strong>EOF</strong>. The <strong>scanf()</strong> function also returns <strong>EOF</strong> on detecting the end of a file. </p><p>Typically, <strong>EOF</strong> is defined in the <strong>stdio.h</strong> file as follows:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOF (-1)</span></code></pre><p>Normally, <strong>getchar()</strong> returns a value in the range <strong>0</strong> through <strong>127</strong>, because those are values corresponding to the standard character set, but it might return values from <strong>0</strong> through <strong>255</strong> if the system recognizes an extended character set. </p><p>In either case, the value <strong>-1</strong> does not correspond to any character, so it can be used to signal the end of a file.<br>&nbsp;</p><pre><code class="hljs c"><span class="hljs-comment">/* echo_eof.c -- repeats input to end of file */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ch;    <span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)        <span class="hljs-built_in">putchar</span>(ch);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>Note:</strong></p><ul><li>You don’t have to define <strong>EOF</strong> because <strong>stdio.h</strong> takes care of that.</li><li>You don’t have to worry about the actual value of <strong>EOF</strong>, because the <strong>#define</strong> statement in <strong>stdio.h</strong> enables you to use the symbolic representation <strong>EOF</strong>. You shouldn’t write code that assumes <strong>EOF</strong> has a particular value.</li><li><strong>getchar()</strong> is actually type int itself, so it can read the EOF character.</li><li>The fact that <strong>getchar()</strong> is type <strong>int</strong> is why some compilers warn of possible data loss if you assign the <strong>getchar()</strong> return value to a type <strong>char</strong> variable.</li><li>The fact that <strong>ch</strong> is an <strong>integer</strong> doesn’t faze <strong>putchar()</strong>. It still prints the character equivalent.</li><li>To use this program on <strong>keyboard input</strong>, you need a way to type the <strong>EOF</strong> character. On <strong>most Unix and Linux systems</strong>, for example, pressing <strong>Ctrl+D</strong> at the <strong>beginning of a line</strong> causes the <strong>end-of-file signal</strong> to be transmitted. Many <strong>microcomputing systems</strong> recognize <strong>Ctrl+Z</strong> at the beginning of a line as an end-of-file signal; some interpret a <strong>Ctrl+Z</strong> anywhere as an <strong>end-of-file signal</strong>.</li></ul><h1 id="5-Redirection"><a href="#5-Redirection" class="headerlink" title="5. Redirection"></a>5. Redirection</h1><p><strong>Redirecting</strong> input enables your program to use a <strong>file</strong> instead of the <strong>keyboard</strong> for input, and redirecting output enables it to use a <strong>file</strong> instead of the <strong>screen</strong> for output.</p><h2 id="1-Redirecting-Input"><a href="#1-Redirecting-Input" class="headerlink" title="(1) Redirecting Input"></a>(1) Redirecting Input</h2><p>The program runs as described earlier, taking its input from the keyboard. Now suppose you want to use the program on a <strong>text file</strong> called <code>words</code>. </p><p>A <strong>text file</strong> is one containing text—that is, data stored as <strong>human-readable characters</strong>. It could be an essay or a program in C, for example. A file containing machine language instructions, such as the file holding the executable version<br>of a program, is not a text file. </p><p>All you need to do is enter this command instead of the previous one:</p><pre><code class="hljs bash">echo_eof &lt; words</code></pre><p>The <code>&lt;</code> symbol is a <strong>Unix and Linux and DOS/Windows redirection operator</strong>. It causes the <code>words</code> file to be associated with the <strong>stdin stream</strong>, channeling the file contents into the <code>echo_eof</code> program. </p><p>The <code>echo_eof</code> program itself doesn’t know (or care) that the input is coming from a file instead of the keyboard. All it knows is that a stream of characters is being fed to it, so it reads them and prints them one character at a time until the end of file shows up. </p><p>Because C puts files and I/O devices on the same footing, the file is now the I/O device. </p><h2 id="2-Redirecting-Output"><a href="#2-Redirecting-Output" class="headerlink" title="(2) Redirecting Output"></a>(2) Redirecting Output</h2><p>Now suppose you want to have <code>echo_eof</code> send your keyboard input to a file called <code>mywords</code>.</p><p>Then you can enter the following and begin typing:</p><pre><code class="hljs bash">echo_eof &gt; mywords</code></pre><p>The <code>&gt;</code> is a second <strong>redirection operator</strong>. It causes a new file called <code>mywords</code> to be created for your use, and then it *<em>redirects the output *</em>of <code>echo_eof</code> (that is, a copy of the characters you type) to that file. </p><p>If you already have a file with the name <code>mywords</code>, normally it would be <strong>erased</strong> and then <strong>replaced</strong> by the new one. (Many operating systems, however, give you the option of protecting existing files by making them <strong>read-only</strong>.) </p><p>All that appears on your screen are the letters as you type them, and the copies go to the file instead. To end the program, press <strong>Ctrl+D</strong>.</p><h2 id="3-Combined-Redirection"><a href="#3-Combined-Redirection" class="headerlink" title="(3) Combined Redirection"></a>(3) Combined Redirection</h2><p>Now suppose you want to make a copy of the file mywords and call it savewords. Just issue this next command:</p><pre><code class="hljs bash">echo_eof &lt; mywords &gt; savewords</code></pre><p>or:</p><pre><code class="hljs bash">echo_eof &gt; savewords &lt; mywords</code></pre><p><strong>Beware: *<em>Don’t use the *</em>same file for both input and output</strong> to the same command.</p><pre><code class="hljs bash">echo_eof &lt; mywords &gt; mywords....&lt;--WRONG</code></pre><p>The reason is that <code>&gt;</code> mywords causes the original mywords to be <strong>truncated to zero length</strong> before it is ever used as input.</p><p><strong>Rules:</strong></p><ul><li>A <strong>redirection operator</strong> connects an <strong>executable program</strong> (including standard operating system commands) with a <strong>data file</strong>. It cannot be used to connect one data file to another, nor can it be used to connect one program to another program.</li><li>Input cannot be taken from <strong>more than one file</strong>, nor can output be directed to more than one file by using these operators.</li><li>Normally, <strong>spaces between the names and operators are optional</strong>, except occasionally when some characters with special meaning to the Unix shell or Linux shell or the Windows Command Prompt mode are used. We could, for example, have used <code>echo_ eof&lt;words</code>.</li></ul><p>Unix, Linux, and Windows/DOS also feature the <code>&gt;&gt;</code> operator, which enables you to <strong>add data</strong> to the end of an <strong>existing file</strong>, and the pipe operator (<code>|</code>), which enables you to connect the <strong>output of one program</strong> to the <strong>input of a second program</strong>. </p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Branching and Jumps</title>
    <link href="/2020/11/29/Branching-and-Jumps/"/>
    <url>/2020/11/29/Branching-and-Jumps/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 7 C Control Statements: Branching and Jumps</p><a id="more"></a><h1 id="1-getchar-and-putchar"><a href="#1-getchar-and-putchar" class="headerlink" title="1.  getchar() and putchar()"></a>1.  getchar() and putchar()</h1><p>The <strong>getchar()</strong> function takes no arguments, and it <strong>returns</strong> the next character from input.<br>&nbsp;<br>The <strong>putchar()</strong> function prints its argument.<br>&nbsp;<br>Because these functions deal only with characters, they are faster and more compact than the more general <strong>scanf()</strong> and <strong>printf()</strong> functions.<br>&nbsp;<br>Characters are really stored as <strong>integers</strong>. <strong>getchar( )</strong> is actually type <strong>int</strong> itself.</p><h1 id="2-The-ctype-h-Family-of-Character-Functions"><a href="#2-The-ctype-h-Family-of-Character-Functions" class="headerlink" title="2. The ctype.h Family of Character Functions"></a>2. The ctype.h Family of Character Functions</h1><p>C has a standard set of functions for analyzing characters; the <strong>ctype.h</strong> header file contains the prototypes.<br>&nbsp;<br>Note that the mapping functions don’t modify the original argument; instead, they return the modified value. </p><pre><code class="hljs c"><span class="hljs-built_in">tolower</span>(ch); <span class="hljs-comment">// no effect on ch</span>ch = <span class="hljs-built_in">tolower</span>(ch); <span class="hljs-comment">// convert ch to lowercase</span></code></pre><table><thead><tr><th align="left">Name</th><th align="left">True If the Argument Is</th></tr></thead><tbody><tr><td align="left">isalnum()</td><td align="left">Alphanumeric (alphabetic or numeric)</td></tr><tr><td align="left">isalpha()</td><td align="left">Alphabetic</td></tr><tr><td align="left">isblank()</td><td align="left">A standard blank character (space, horizontal tab, or newline) or any additional locale-specific character so specified</td></tr><tr><td align="left">iscntrl()</td><td align="left">A control character, such as Ctrl+B</td></tr><tr><td align="left">isdigit()</td><td align="left">A digit</td></tr><tr><td align="left">isgraph()</td><td align="left">Any printing character other than a space</td></tr><tr><td align="left">islower()</td><td align="left">A lowercase character</td></tr><tr><td align="left">isprint()</td><td align="left">A printing character</td></tr><tr><td align="left">ispunct()</td><td align="left">A punctuation character (any printing character other than a space or an alphanumeric character)</td></tr><tr><td align="left">isspace()</td><td align="left">A whitespace character (a space, newline, formfeed, carriage return, vertical tab, horizontal tab, or, possibly, other locale-defined character)</td></tr><tr><td align="left">isupper()</td><td align="left">An uppercase character</td></tr><tr><td align="left">isxdigit()</td><td align="left">A hexadecimal-digit character</td></tr></tbody></table><table><thead><tr><th align="left">Name</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">tolower()</td><td align="left">If the argument is an uppercase character, this function returns the lowercase version; otherwise, it just returns the original argument.</td></tr><tr><td align="left">toupper()</td><td align="left">If the argument is a lowercase character, this function returns the uppercase version; otherwise, it just returns the original argument.</td></tr></tbody></table><h1 id="3-Logical-Operators"><a href="#3-Logical-Operators" class="headerlink" title="3. Logical Operators"></a>3. Logical Operators</h1><table><thead><tr><th align="left">Operator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">and</td></tr><tr><td align="left">||</td><td align="left">or</td></tr><tr><td align="left">!</td><td align="left">not</td></tr></tbody></table><h2 id="1-Precedence"><a href="#1-Precedence" class="headerlink" title="(1) Precedence"></a>(1) Precedence</h2><p>The <strong>!</strong> operator has a very high precedence—higher than <strong>multiplication</strong>, the same as the <strong>increment operators</strong>, and just below that of <strong>parentheses</strong>. The <strong>&amp;&amp;</strong> operator has higher precedence than <strong>||</strong>.</p><h2 id="2-Order-of-Evaluation"><a href="#2-Order-of-Evaluation" class="headerlink" title="(2) Order of Evaluation"></a>(2) Order of Evaluation</h2><p>The <strong>&amp;&amp;</strong> and <strong>||</strong> operators are sequence points, so all side effects take place before a program moves from one operand to the next. </p><pre><code class="hljs c"><span class="hljs-keyword">while</span> ( x++ &lt; <span class="hljs-number">10</span> &amp;&amp; x + y &lt; <span class="hljs-number">20</span>)</code></pre><p>The fact that the <strong>&amp;&amp;</strong> operator is a sequence point guarantees that <code>x</code> is incremented before the expression on the right is evaluated.</p><h1 id="4-A-Word-Count-Program"><a href="#4-A-Word-Count-Program" class="headerlink" title="4. A Word-Count Program"></a>4. A Word-Count Program</h1><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STOP <span class="hljs-meta-string">'\x1b'</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> c;  <span class="hljs-comment">//read in character</span>    <span class="hljs-keyword">char</span> prev; <span class="hljs-comment">//previous character read</span>    <span class="hljs-keyword">long</span> n_chars = <span class="hljs-number">0L</span>; <span class="hljs-comment">//number of characters</span>    <span class="hljs-keyword">long</span> n_alphabets = <span class="hljs-number">0L</span>; <span class="hljs-comment">//alphabetic</span>    <span class="hljs-keyword">long</span> n_digits = <span class="hljs-number">0L</span>; <span class="hljs-comment">//digits</span>    <span class="hljs-keyword">long</span> n_spaces = <span class="hljs-number">0L</span>;    <span class="hljs-keyword">long</span> n_punctuations = <span class="hljs-number">0L</span>;    <span class="hljs-keyword">int</span> n_lines = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> n_words = <span class="hljs-number">0</span>;    <span class="hljs-keyword">bool</span> inword = <span class="hljs-literal">false</span>;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter text to be analyzed (Esc to terminate):\n"</span>);    prev = <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">while</span> ((c = getchar()) != STOP)    &#123;        n_chars++;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalpha</span>(c))           n_alphabets++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))            n_digits++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ispunct</span>(c))            n_punctuations++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c))            n_spaces++;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'\n'</span>)            n_lines++;        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isspace</span>(c) &amp;&amp; !inword)         &#123;            inword = <span class="hljs-literal">true</span>;            n_words++;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c) &amp;&amp; inword)         &#123;            inword = <span class="hljs-literal">false</span>; <span class="hljs-comment">//reached end of a word</span>        &#125;        prev = c;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Charaters = %ld, alphabets = %ld, digits = %ld,\</span><span class="hljs-string">    punctuations = %ld, spaces = %ld,  words = %d, lines = %d\n"</span>,    n_chars,n_alphabets,n_digits,n_punctuations,n_spaces,n_words,n_lines);    <span class="hljs-comment">/*return 0; */</span>&#125;</code></pre><p>Output:</p><pre><code class="hljs c"><span class="hljs-function">Enter <span class="hljs-built_in">text</span> to be <span class="hljs-title">analyzed</span> <span class="hljs-params">(Esc to <span class="hljs-built_in">terminate</span>)</span>:</span><span class="hljs-function">Reason is a</span><span class="hljs-function">powerful servant but</span>an inadequate master.<span class="hljs-number">2</span> - <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;*** :) ***^[Charaters = <span class="hljs-number">77</span>, alphabets = <span class="hljs-number">45</span>, digits = <span class="hljs-number">3</span>, punctuations = <span class="hljs-number">12</span>, spaces = <span class="hljs-number">17</span>,  words = <span class="hljs-number">17</span>, lines = <span class="hljs-number">5</span></code></pre><h1 id="5-The-Conditional-Operator"><a href="#5-The-Conditional-Operator" class="headerlink" title="5. The Conditional Operator: ?:"></a>5. The Conditional Operator: ?:</h1><p>C offers a shorthand way to express one form of the <strong>if else</strong> statement. It is called a conditional expression and uses the <strong>?:</strong> conditional operator. </p><pre><code class="hljs c">expression1 ? expression2 : expression3</code></pre><p>If expression1 is true (nonzero), the whole conditional expression has the same value as expression2. If expression1 is false (zero), the whole conditional expression has the same value as expression3.</p><h1 id="6-Loop-Aids-continue-and-break"><a href="#6-Loop-Aids-continue-and-break" class="headerlink" title="6. Loop Aids: continue and break"></a>6. Loop Aids: continue and break</h1><h2 id="1-The-continue-Statement"><a href="#1-The-continue-Statement" class="headerlink" title="(1) The continue Statement"></a>(1) The continue Statement</h2><p>The continue statement causes the program to <strong>skip over</strong> the rest of the loop, which is devoted to processing valid input. Instead, the program <strong>starts the next loop cycle</strong> by attempting to read the next input value. </p><p><strong>continue</strong> works for the while, do while, for, and not for the switch function.</p><p><strong>continue</strong> terminates the current loop, but not the entire loop.</p><pre><code class="hljs c"><span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">10</span>; count++)&#123;ch = getchar();<span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'\n'</span>)<span class="hljs-keyword">continue</span>;<span class="hljs-built_in">putchar</span>(ch);&#125;</code></pre><p>In this case, when the <strong>continue</strong> statement is executed, <strong>first count is incremented</strong> and then it’s compared to 10.</p><h2 id="2-The-break-Statement"><a href="#2-The-break-Statement" class="headerlink" title="(2) The break Statement"></a>(2) The break Statement</h2><p>A <strong>break</strong> statement in a loop causes the program to break free of the loop that encloses it and to proceed to the next stage of the program. </p><p>break works for while, do while, for and switch functions.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> i;  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  &#123;    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)    <span class="hljs-keyword">break</span>;  &#125;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %d\n"</span>,i);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>In this case, when the program executes the <strong>break</strong> statement, it breaks out of the for loop <strong>without adding i</strong>.  </p><h1 id="7-The-goto-Statement"><a href="#7-The-goto-Statement" class="headerlink" title="7. The goto Statement"></a>7. The goto Statement</h1><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &gt; <span class="hljs-number">12</span>)    <span class="hljs-keyword">goto</span> a;<span class="hljs-keyword">goto</span> b;a: cost = cost * <span class="hljs-number">1.05</span>;flag = <span class="hljs-number">2</span>;b: bill = cost * flag;</code></pre><p>It is the same as:</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &gt; <span class="hljs-number">12</span>)&#123;    cost = cost * <span class="hljs-number">1.05</span>;    flag = <span class="hljs-number">2</span>;&#125;bill = cost * flag;</code></pre><p>When a <strong>goto</strong> is encountered, it jumps unconditionally to the statement where the <strong>label</strong> is, and then <strong>executes sequentially from there</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operators, Expressions, and Statements</title>
    <link href="/2020/11/28/Operators-Expressions-and-Statements/"/>
    <url>/2020/11/28/Operators-Expressions-and-Statements/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 5 Operators, Expressions, and Statements</p><a id="more"></a><h1 id="1-Fundamental-Operators"><a href="#1-Fundamental-Operators" class="headerlink" title="1. Fundamental Operators"></a>1. Fundamental Operators</h1><h2 id="1-Assignment-Operator"><a href="#1-Assignment-Operator" class="headerlink" title="(1) Assignment Operator: ="></a>(1) Assignment Operator: =</h2><p>The <code>=</code> symbol is called the assignment operator.</p><h3 id="Some-Terminology-Data-Objects-Lvalues-Rvalues-and-Operands"><a href="#Some-Terminology-Data-Objects-Lvalues-Rvalues-and-Operands" class="headerlink" title="Some Terminology: Data Objects, Lvalues, Rvalues, and Operands"></a>Some Terminology: Data Objects, Lvalues, Rvalues, and Operands</h3><p>Consider an assignment statement. Its purpose is to store a value at a memory location.<br>&nbsp;<br><strong>Data object</strong> is a general term for a region of data storage that can be used to hold values.<br>&nbsp;<br>C uses the term <strong>lvalue</strong> to mean any such name or expression that identifies a particular data object. <strong>Object</strong> refers to the actual data storage, but an <strong>lvalue</strong> is a <strong>label</strong> used to identify, or locate, that storage.</p><p>The term <strong>rvalue</strong> refers to quantities that can be assigned to modifiable <strong>lvalues</strong> but which are not themselves lvalues. <strong>Rvalues</strong> can be constants, variables, or any other expression that yields a value. </p><h2 id="2-Division-Operator"><a href="#2-Division-Operator" class="headerlink" title="(2) Division Operator: /"></a>(2) Division Operator: /</h2><p>Division works differently for integer types than it does for floating types. Floating-type division gives a floating-point answer, but integer division yields an integer answer.</p><p>Integer division does not round to the nearest integer, but always truncates (that is, discards the entire fractional part).</p><pre><code class="hljs c"><span class="hljs-number">5</span>/<span class="hljs-number">2</span> = <span class="hljs-number">2</span><span class="hljs-number">-5</span>/<span class="hljs-number">2</span> = <span class="hljs-number">-2</span><span class="hljs-number">5</span>/(<span class="hljs-number">-2</span>) = <span class="hljs-number">-2</span></code></pre><h2 id="3-Modulus-Operator"><a href="#3-Modulus-Operator" class="headerlink" title="(3) Modulus Operator: %"></a>(3) Modulus Operator: %</h2><p>The modulus operator is used in <strong>integer arithmetic</strong>. It gives the remainder that results when the integer to its left is divided by the integer to its right. For example, 13 % 5 (read as “13 modulo 5”) has the value 3.</p><p>You get a negative modulus value if the first operand is negative, and you get a positive modulus otherwise.</p><pre><code class="hljs c"><span class="hljs-number">5</span>%<span class="hljs-number">2</span> = <span class="hljs-number">1</span><span class="hljs-number">-5</span>%<span class="hljs-number">2</span> = <span class="hljs-number">-1</span><span class="hljs-number">5</span>%(<span class="hljs-number">-2</span>) = <span class="hljs-number">1</span></code></pre><h2 id="4-Increment-and-Decrement-Operators-and-–"><a href="#4-Increment-and-Decrement-Operators-and-–" class="headerlink" title="(4) Increment and Decrement Operators: ++ and –"></a>(4) Increment and Decrement Operators: ++ and –</h2><p>The increment operator performs a simple task; it increments (increases) the value of its operand by 1. </p><pre><code class="hljs pgsql">a_post = a++; // postfix: a <span class="hljs-keyword">is</span> changed <span class="hljs-keyword">after</span> its <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> usedb_pre= ++b;// prefix: b <span class="hljs-keyword">is</span> changed <span class="hljs-keyword">before</span> its <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> used(a + b)++; //invalid</code></pre><p>You can get fooled if you try to do too much at once with the increment operators.</p><pre><code class="hljs c"><span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">21</span>)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%10d %10d\n"</span>, num, num*num++);&#125;</code></pre><p>In C, the compiler can choose which arguments in a function to evaluate first.</p><pre><code class="hljs c">ans = num/<span class="hljs-number">2</span> + <span class="hljs-number">5</span>*(<span class="hljs-number">1</span> + num++);</code></pre><p>You would think that it would find num/2 first and then move on, but it might do the last term first.</p><h2 id="5-The-Comma-Operator"><a href="#5-The-Comma-Operator" class="headerlink" title="(5) The Comma Operator"></a>(5) The Comma Operator</h2><p>First, it guarantees that the expressions it separates are evaluated in a <strong>left-to-right order</strong>.<br>Second, the <strong>value of the whole comma expression</strong> is the value of the <strong>right-hand member</strong>.</p><pre><code class="hljs c">x = (y = <span class="hljs-number">3</span>, (z = ++y + <span class="hljs-number">2</span>) + <span class="hljs-number">5</span>);<span class="hljs-comment">//x = (z = ++y + 2) + 5;</span></code></pre><h1 id="2-Operator-Precedence"><a href="#2-Operator-Precedence" class="headerlink" title="2. Operator Precedence"></a>2. Operator Precedence</h1><table><thead><tr><th align="center">Operators (decreasing precedence)</th><th align="center">Associativity</th></tr></thead><tbody><tr><td align="center">+ - (unary)</td><td align="center">Left to right</td></tr><tr><td align="center">* /</td><td align="center">Left to right</td></tr><tr><td align="center">+ - (binary)</td><td align="center">Left to right</td></tr><tr><td align="center">=</td><td align="center">Left to right</td></tr><tr><td align="center">,</td><td align="center">Left to right</td></tr></tbody></table><h1 id="3-Expressions-and-Statements"><a href="#3-Expressions-and-Statements" class="headerlink" title="3. Expressions and Statements"></a>3. Expressions and Statements</h1><h2 id="1-Expressions"><a href="#1-Expressions" class="headerlink" title="(1) Expressions"></a>(1) Expressions</h2><p>An expression consists of a combination of operators and operands.<br>&nbsp;<br>An important property of C is that every C expression has a value. </p><h2 id="2-Statements"><a href="#2-Statements" class="headerlink" title="(2) Statements"></a>(2) Statements</h2><p>Statements are the primary building blocks of a program. A program is a series of statements with some necessary punctuation. A statement is a complete instruction to the computer. In C, statements are indicated by a <strong>semicolon</strong> at the end. </p><h1 id="4-Type-Conversions"><a href="#4-Type-Conversions" class="headerlink" title="4. Type Conversions"></a>4. Type Conversions</h1><h2 id="1-Automatic-Type-Conversions"><a href="#1-Automatic-Type-Conversions" class="headerlink" title="(1) Automatic Type Conversions"></a>(1) Automatic Type Conversions</h2><ol><li>When appearing in an <strong>expression</strong>, <strong>char</strong> and <strong>short</strong>, both <strong>signed</strong> and <strong>unsigned</strong>, are <strong>automatically</strong> converted to <strong>int</strong> or, if necessary, to <strong>unsigned int</strong>. (If <strong>short</strong> is the same size as <strong>int</strong>, <strong>unsigned short</strong> is larger than <strong>int</strong>; in that case, <strong>unsigned short</strong> is converted to <strong>unsigned int</strong>.) Under <strong>K&amp;R</strong> C, but not under current C, <strong>float</strong> is automatically converted to <strong>double</strong>. Because they are conversions to larger types, they are called <strong>promotions</strong>.</li><li>In any <strong>operation</strong> involving <strong>two types</strong>, both values are converted to the <strong>higher ranking</strong> of the two types.</li><li>The <strong>ranking of types</strong>, from <strong>highest to lowest</strong>, is <strong>long double</strong>, <strong>double</strong>, <strong>float</strong>, <strong>unsigned long long</strong>, <strong>long long</strong>, <strong>unsigned long</strong>, <strong>long</strong>, <strong>unsigned int</strong>, and <strong>int</strong>. One possible <strong>exception</strong> is when <strong>long and int are the same size</strong>, in which case <strong>unsigned int</strong> outranks <strong>long</strong>. The <strong>short</strong> and <strong>char</strong> types don’t appear in this list because they would have been already promoted to int or perhaps <strong>unsigned int</strong>.</li><li>In an <strong>assignment statement</strong>, the final result of the calculations is converted to the type of <strong>the variable being assigned a value</strong>. This process can result in <strong>promotion</strong>, as described in rule 1, or <strong>demotion</strong>, in which a value is converted to a lower-ranking type.</li><li>When passed as <strong>function arguments</strong>, <strong>char</strong> and <strong>short</strong> are converted to <strong>int</strong>, and <strong>float</strong> is converted to <strong>double</strong>. This <strong>automatic promotion</strong> is overridden by function prototyping.</li></ol><h2 id="2-The-Cast-Operator"><a href="#2-The-Cast-Operator" class="headerlink" title="(2) The Cast Operator"></a>(2) The Cast Operator</h2><p>The parentheses and type name together constitute a cast operator.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>)<span class="hljs-number">1.6</span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Charater Strings and Formatted Input/Output</title>
    <link href="/2020/11/28/Charater-Strings-and-Formatted-Input-Output/"/>
    <url>/2020/11/28/Charater-Strings-and-Formatted-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 4 Charater Strings and Formatted Input/Output</p><a id="more"></a><h1 id="1-Character-Strings"><a href="#1-Character-Strings" class="headerlink" title="1. Character Strings"></a>1. Character Strings</h1><p> A character string is a series of one or more characters. </p><h2 id="1-Type-char-Arrays-and-the-Null-Character"><a href="#1-Type-char-Arrays-and-the-Null-Character" class="headerlink" title="(1) Type char Arrays and the Null Character"></a>(1) Type char Arrays and the Null Character</h2><p>C has no special variable type for strings. Instead, strings are stored in an array of type char. Characters in a string are stored in adjacent memory cells, one character per cell, and an array consists of adjacent memory locations.<br><img src="https://img-blog.csdnimg.cn/20190521222859479.png" srcset="/img/loading.gif" alt=""><br>The <strong>null character</strong> is not the digit zero; it is the nonprinting character whose <strong>ASCII</strong> code value (or equivalent) is <strong>0</strong>. Strings in C are always stored with this terminating null character. The presence of the null character means that the array must have <strong>at least one more cell</strong> than the number of characters to be stored. </p><h2 id="2-Using-Strings"><a href="#2-Using-Strings" class="headerlink" title="(2) Using Strings"></a>(2) Using Strings</h2><p>In general, <strong>scanf()</strong> is used with <strong>%s</strong> to read only a <strong>single word</strong>, not a whole phrase, as a string. C has other input-reading functions, such as <strong>fgets()</strong>, for handling general strings.</p><h2 id="3-Strings-Versus-Characters"><a href="#3-Strings-Versus-Characters" class="headerlink" title="(3) Strings Versus Characters"></a>(3) Strings Versus Characters</h2><p><img src="https://img-blog.csdnimg.cn/201905212249433.png" srcset="/img/loading.gif" alt="A word is the natural unit of memory for a given computer design.For 8-bit microcomputers,"></p><h1 id="2-The-strlen-Function"><a href="#2-The-strlen-Function" class="headerlink" title="2. The strlen() Function"></a>2. The strlen() Function</h1><p>The <strong>strlen()</strong> function gives the length of a string in characters.<br>The <strong>string.h</strong> file contains function prototypes for several string related functions, including <strong>strlen()</strong>.<br>&nbsp;<br>The <strong>strlen()</strong> gives you the exact number of characters (including spaces and punctuation) in the string. The <strong>sizeof</strong> operator gives you a number one <strong>larger</strong> because it also counts the <strong>invisible null character</strong> used to end the string.<br>&nbsp;<br>The <strong>C99</strong> and <strong>C11</strong> standards use a <strong>%zd</strong> specifier for the type used by the <strong>sizeof</strong> operator. This also applies for type returned by <strong>strlen()</strong>.<br>&nbsp;<br>The preceding chapter used <strong>sizeof</strong> with <strong>parentheses</strong>, but this example doesn’t. <strong>Parentheses</strong> are <strong>required for types</strong> but are <strong>optional for particular quantities</strong>. That is, you would use <strong>sizeof(char)</strong> or <strong>sizeof(float)</strong> but can use <strong>sizeof name</strong> or <strong>sizeof 6.28.</strong></p><h1 id="3-Constants-and-the-C-Preprocessor"><a href="#3-Constants-and-the-C-Preprocessor" class="headerlink" title="3. Constants and the C Preprocessor"></a>3. Constants and the C Preprocessor</h1><p>The <strong>preprocessor</strong> uses <strong>#include</strong> to incorporate information from another file, it also lets you define constants. Just add a line like the following at the top of the file containing your program:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TAXRATE 0.015</span></code></pre><p><strong>No semicolon</strong> is used because this is a substitution mechanism handled by the <strong>preprocessor</strong>, not a <strong>C</strong> statement.</p><h1 id="4-The-const-Modifier"><a href="#4-The-const-Modifier" class="headerlink" title="4. The const Modifier"></a>4. The const Modifier</h1><p><strong>C90</strong> added a second way to <strong>create symbolic constants</strong>—using the <strong>const</strong> keyword to convert a declaration for a <strong>variable</strong> into a declaration for a <strong>constant</strong>:</p><pre><code class="hljs c"><span class="hljs-comment">// MONTHS a symbolic constant for 12</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MONTHS = <span class="hljs-number">12</span>;</code></pre><p>This newer approach is more flexible than using <strong>#define</strong>; it lets you declare a type, and it allows better control over which parts of a program can use the constant.</p><h1 id="5-Manifest-Constants-on-the-Job"><a href="#5-Manifest-Constants-on-the-Job" class="headerlink" title="5. Manifest Constants on the Job"></a>5. Manifest Constants on the Job</h1><p>The C header files <strong>limits.h</strong> and <strong>float.h</strong> supply detailed information about the <strong>size limits</strong> of <strong>integer</strong> types and <strong>floating</strong> types, respectively. </p><h1 id="6-The-printf-Function"><a href="#6-The-printf-Function" class="headerlink" title="6. The printf() Function"></a>6. The printf() Function</h1><p>The instructions you give <strong>printf()</strong> when you ask it to print a variable depend on the variable type. </p><table><thead><tr><th align="left">Conversion</th><th align="left">Output Specification</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">Floating-point-number, hexadecimal digits and p-notation(C99/C11).</td></tr><tr><td align="left">%A</td><td align="left">Floating-point-number, hexadecimal digits and p-notation(C99/C11).</td></tr><tr><td align="left">%c</td><td align="left">Single character.</td></tr><tr><td align="left">%d</td><td align="left">Single decimal integer.</td></tr><tr><td align="left">%e</td><td align="left">Floating-point number, e-notation.</td></tr><tr><td align="left">%E</td><td align="left">Floating-point number, e-notation.</td></tr><tr><td align="left">%f</td><td align="left">Floating-point number, decimal notation.</td></tr><tr><td align="left">%g</td><td align="left">Using %f or %e, depending on the value. The %e style is used if the exponent is less than -4 or greater than or equal to the presion.</td></tr><tr><td align="left">%G</td><td align="left">Using %f or %E, depending on the value. The %E style is used if the exponent is less than -4 or greater than or equal to the presion.</td></tr><tr><td align="left">%i</td><td align="left">Single decimal integer(same as %d).</td></tr><tr><td align="left">%o</td><td align="left">Unsigned octal integer.</td></tr><tr><td align="left">%p</td><td align="left">A pointer.</td></tr><tr><td align="left">%s</td><td align="left">Character string.</td></tr><tr><td align="left">%u</td><td align="left">Unsigned decimal integer.</td></tr><tr><td align="left">%x</td><td align="left">Unsigned hexadecimal integer, using hex digits 0f.</td></tr><tr><td align="left">%X</td><td align="left">Unsigned hexadecimal integer, using hex digits 0F.</td></tr><tr><td align="left">%%</td><td align="left">Prints a percent sign.</td></tr></tbody></table><h2 id="1-Conversion-Specification-Modifiers-for-printf"><a href="#1-Conversion-Specification-Modifiers-for-printf" class="headerlink" title="(1) Conversion Specification Modifiers for printf()"></a>(1) Conversion Specification Modifiers for printf()</h2><table><thead><tr><th align="left">Modifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">flag</td><td align="left">Five flags:-,+,space,#, and 0.</td></tr><tr><td align="left">digit(s)</td><td align="left">The minimun field width. A wilder field will be used if the printed number or string won’t fit in the field.</td></tr><tr><td align="left">.digit(s)</td><td align="left">Presions. For %e, %E, and %f conversions, the maximun number of significant digits. For %g and %G conversions, the maximun number of significant digits. For %s conversion, the maximun number of characters to be printed. For integer conversions, the minimun number of digits to apper: leading zeros are used if necessary to meet this minimum. Using only . implies a following zero, so %.f is the same as %.0f.</td></tr><tr><td align="left">h</td><td align="left">Used with an integer conversion specifier to indicate a short int or unsigned short int value.</td></tr><tr><td align="left">hh</td><td align="left">Used with an integer conversion specifier to indicate a signed char or unsigned char value.</td></tr><tr><td align="left">j</td><td align="left">Used with an integer conversion specifier to indicate an intmax_t or uintmax_t value; these are types defined in stdint.h.</td></tr><tr><td align="left">l</td><td align="left">Used with an integer conversion specifier to indicate a long int or unsigned long int.</td></tr><tr><td align="left">ll</td><td align="left">Used with an integer conversion specifier to indicate a long long int or unsigned long long int.(C99).</td></tr><tr><td align="left">L</td><td align="left">Used with a floating-point conversion specifier to indicate a long double value.</td></tr><tr><td align="left">t</td><td align="left">Used with an integer conversion specifier to indicate a ptrdiff_t value. This is the type corresponding to the difference between two pointers. (C99).</td></tr><tr><td align="left">z</td><td align="left">Used with an integer conversion specifier to indicate a size_t value. This is the type returned by sizeof. (C99).</td></tr></tbody></table><h2 id="2-The-printf-Flags"><a href="#2-The-printf-Flags" class="headerlink" title="(2) The printf( ) Flags"></a>(2) The printf( ) Flags</h2><table><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">The item is left-justified; that is, it is printed begining at the left of the field.</td></tr><tr><td align="left">+</td><td align="left">Signed values are displayed with a plus sign, if positive, and with a minus sign, if negative.</td></tr><tr><td align="left">space</td><td align="left">Signed values are displayed with a  leading space (but no sign) if positive and with a minus sign if negative. A + flag overrides a space.</td></tr><tr><td align="left">#</td><td align="left">Used  an alternative form for the conversion specification. Produces an initial 0 for the %o form and initial 0x for the %x or %X form, respectively. For all floating-point forms, # gurantees that a decimal-point character is printed, even if no digits follow. For %g and %G forms, it prevents traing zeros form being removed.</td></tr><tr><td align="left">0</td><td align="left">For numeric forms, pad the field width with leading zeros indtead of with spaces. This flag is ignored if a - flag is present or if, for an integer form, a precision is specified.</td></tr></tbody></table><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">float</span> f = <span class="hljs-number">321454.321345</span>;   <span class="hljs-keyword">float</span> f1 = <span class="hljs-number">12.2345678</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %04f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %06.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %6.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %-6.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"321454.321345 = %7f\n"</span>,f);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"321454.321345 = %7.3f\n"</span>,f);    <span class="hljs-keyword">int</span> n1 = <span class="hljs-number">3456</span>;  <span class="hljs-keyword">int</span> n2  = <span class="hljs-number">1</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3456 = %3.2d\n"</span>,n1);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3456 = %6.2d\n\n"</span>,n1);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 = %.4d\n"</span>,n2);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 = %3.2d\n\n"</span>,n2);    <span class="hljs-comment">//测试字符串宽度精度</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %9.3s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %9s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %3s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Output：</p><pre><code class="hljs c"><span class="hljs-number">2.3</span> = <span class="hljs-number">2.300000</span> <span class="hljs-comment">//%04f：输出宽度至少4，精度不限制时用默认的，浮点数默认精度6位，这里宽度指总的宽度（包括小数点和小数点后面的数）</span><span class="hljs-number">2.3</span> = <span class="hljs-number">002.30</span> <span class="hljs-comment">//%06.2f： 总共宽度至少6位，精度2位，因此左边补0</span><span class="hljs-number">2.3</span> =   <span class="hljs-number">2.30</span> <span class="hljs-comment">//%6.2f：总共宽度至少6位，精度2位，左边空两格，默认右对齐</span><span class="hljs-number">2.3</span> = <span class="hljs-number">2.30</span> <span class="hljs-comment">// %-6.2f：总共宽度至少6位，精度2位，右边空两格，加-号左对齐</span><span class="hljs-number">321454.321345</span> = <span class="hljs-number">321454.312500</span><span class="hljs-number">321454.321345</span> = <span class="hljs-number">321454.312</span><span class="hljs-number">3456</span> = <span class="hljs-number">3456</span>  <span class="hljs-comment">//%3.2d ，总宽度至少3</span><span class="hljs-number">3456</span> =   <span class="hljs-number">3456</span>  <span class="hljs-comment">//%6.2d ，总宽度至少6</span><span class="hljs-number">1</span> = <span class="hljs-number">0001</span> <span class="hljs-comment">//%.4d 有效位4位，只有1位，其余补0</span><span class="hljs-number">1</span> =  <span class="hljs-number">01</span>  <span class="hljs-comment">//%3.2d 总宽度3，有效位2，因此左边空1格，补一个0</span><span class="hljs-string">"printf"</span> =        pri <span class="hljs-comment">// %9.3s 总宽度至少9，有效3位，因此只现实3个字符</span><span class="hljs-string">"printf"</span> =    <span class="hljs-built_in">printf</span>  <span class="hljs-comment">// %9s，总宽度至少9，宽度9</span><span class="hljs-string">"printf"</span> = <span class="hljs-built_in">printf</span>   <span class="hljs-comment">// %3s，总宽度至少3，因此宽度为6</span></code></pre><h2 id="3-The-Return-Value-of-printf"><a href="#3-The-Return-Value-of-printf" class="headerlink" title="(3) The Return Value of printf()"></a>(3) The Return Value of printf()</h2><p>The <strong>printf()</strong> function also has a return value; it returns the <strong>number of characters</strong> it printed. </p><h2 id="4-Printing-Long-Strings"><a href="#4-Printing-Long-Strings" class="headerlink" title="(4) Printing Long Strings"></a>(4) Printing Long Strings</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's one way to print a "</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"long string.\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's another way to print a \</span><span class="hljs-string">long string.\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's the newest way to print a "</span><span class="hljs-string">"long string.\n"</span>); <span class="hljs-comment">/* ANSI C */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Method 1 is to use more than one <strong>printf()</strong> statement.<br>Method 2 is to terminate the end of the first line with a backslash/return combination.<br>Method 3, which ANSI C introduced, is <strong>string concatenation</strong>. If you follow one <strong>quoted</strong> string constant with another, separated only by <strong>whitespace</strong>, C treats the combination as a <strong>single string</strong>. </p><h1 id="7-scanf"><a href="#7-scanf" class="headerlink" title="7. scanf()"></a>7. scanf()</h1><p>It converts string input into various forms: integers, floating-point numbers, characters, and C strings.<br>&nbsp;<br>Rules:</p><blockquote><ul><li>If you use <strong>scanf()</strong> to read a value for one of the basic variable types, precede the variable name with an <strong>&amp;</strong>.</li><li>If you use <strong>scanf()</strong> to read a string into a <strong>character array</strong>, don’t use an <strong>&amp;</strong>.</li></ul></blockquote><h2 id="1-Conversion-Specifiers-for-scanf"><a href="#1-Conversion-Specifiers-for-scanf" class="headerlink" title="(1) Conversion Specifiers for scanf()"></a>(1) Conversion Specifiers for scanf()</h2><p>The <strong>scanf()</strong> function uses pretty much the same set of conversion specification characters as <strong>printf()</strong> does. The main difference is that <strong>printf()</strong> uses %f, %e, %E, %g, and %G for both type float and type double, whereas <strong>scanf()</strong> uses them just for type float, requiring the <strong>l</strong> modifier for double. </p><table><thead><tr><th align="left">Conversion Specifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">%c</td><td align="left">Interpret input as a character.</td></tr><tr><td align="left">%d</td><td align="left">Interpret input as a signed decimal integer.</td></tr><tr><td align="left">%e, %f, %g, %a</td><td align="left">Interpret input as a floating-point number (%a is C99).</td></tr><tr><td align="left">%E, %F, %G, %A</td><td align="left">Interpret input as a floating-point number (%A is C99).</td></tr><tr><td align="left">%i</td><td align="left">Interpret input as a signed decimal integer.</td></tr><tr><td align="left">%o</td><td align="left">Interpret input as a signed Octal integer.</td></tr><tr><td align="left">%p</td><td align="left">Intepret input as a pointer (an address).</td></tr><tr><td align="left">%s</td><td align="left">Intepret input as a string. Input begins with the first non-whitespace character and includes evertything up to the next whitespace character.</td></tr><tr><td align="left">%u</td><td align="left">Interpret input as a unsigned decimal integer.</td></tr><tr><td align="left">%x, %X</td><td align="left">Interpret input as a signed hexadecimal integer.</td></tr></tbody></table><h2 id="2-Conversion-Modifiers-for-scanf"><a href="#2-Conversion-Modifiers-for-scanf" class="headerlink" title="(2) Conversion Modifiers for scanf()"></a>(2) Conversion Modifiers for scanf()</h2><table><thead><tr><th align="left">Modifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">Suppress assignment.</td></tr><tr><td align="left">digit(s)</td><td align="left">Maximum field width. Input stops when the maximum field width is reached or when the first whitespace character is encountered, whichever comes first.</td></tr><tr><td align="left">hh</td><td align="left">Read an integer as a signed char or unsigned char.</td></tr><tr><td align="left">ll</td><td align="left">Read an integer as a long long or unsigned long long (C99).</td></tr><tr><td align="left">h, l or L</td><td align="left">“%hd” and “%hi” indicate that the value will be stored in a <strong>short int</strong>. “%ho”, “%hx”, and “%hu” indicate that the value will be stored in an <strong>unsigned short int</strong>. “%ld” and “%li” indicate that the value will be stored in a <strong>long</strong>. “%lo”, “%lx”, and “%lu” indicate that the value will be stored in <strong>unsigned long</strong>. “%le”, “%lf”, and “%lg” indicate that the value will be stored in type <strong>double</strong>. Using L instead of l with e, f, and g indicates that the value will be stored in type <strong>long double</strong>. In the absence of these modifiers, d, i, o, and x indicate type <strong>int</strong>, and e, f, and g indicate type <strong>float</strong>.</td></tr><tr><td align="left">j</td><td align="left">When followed by an integer specifier, indicates using the intmax_t or uintmax_t type (C99).</td></tr><tr><td align="left">z</td><td align="left">When followed by an integer specifier, indicates using the type returned by sizeof (C99).</td></tr><tr><td align="left">t</td><td align="left">When followed by an integer specifier, indicates using the type used to represent the difference between two pointers (C99).</td></tr></tbody></table><h2 id="3-The-scanf-View-of-Input"><a href="#3-The-scanf-View-of-Input" class="headerlink" title="(3) The scanf() View of Input"></a>(3) The scanf() View of Input</h2><p>It skips over whitespace characters (spaces, tabs, and newlines) until it finds a non-whitespace character. scanf() continues reading and saving characters until it encounters a nondigit. </p><p>&nbsp;<br>If you use a <strong>%c</strong> specifier, all input characters are fair game. If the next input character is a space or a newline, a space or a newline is assigned to the indicated variable; <strong>whitespace is not skipped</strong>.</p><h2 id="4-The-scanf-Return-Value"><a href="#4-The-scanf-Return-Value" class="headerlink" title="(4) The scanf() Return Value"></a>(4) The scanf() Return Value</h2><p>The <strong>scanf()</strong> function returns <strong>the number of items</strong> that it successfully reads. If it reads no items, which happens if you type a nonnumeric string when it expects a number, <strong>scanf()</strong> returns the value 0. It returns <strong>EOF</strong> when it detects the condition known as “end of file.” </p><h1 id="8-The-Modifier-with-printf-and-scanf"><a href="#8-The-Modifier-with-printf-and-scanf" class="headerlink" title="8. The * Modifier with printf() and scanf()"></a>8. The * Modifier with printf() and scanf()</h1><h2 id="1-The-Modifier-with-printf"><a href="#1-The-Modifier-with-printf" class="headerlink" title="(1) The * Modifier with printf()"></a>(1) The * Modifier with printf()</h2><p>Suppose that you don’t want to commit yourself to a field width in advance but rather you want the program to specify it. You can do this by using <code>*</code> instead of a number for the field width, but you also have to add an argument to tell what the field width should be.<br>&nbsp;<br>That is, if you have the conversion specifier <code>%*d</code>, the argument list should include a value for <code>*</code> and a value for <code>d</code>. </p><h2 id="2-The-Modifier-with-scanf"><a href="#2-The-Modifier-with-scanf" class="headerlink" title="(2) The * Modifier with scanf()"></a>(2) The * Modifier with scanf()</h2><p>The <code>*</code> serves quite a different purpose for <strong>scanf()</strong>. When placed between the <code>%</code> and the specifier letter, it causes that function to <strong>skip over corresponding input</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data and C</title>
    <link href="/2020/11/24/Data-and-C/"/>
    <url>/2020/11/24/Data-and-C/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 3 Data and C</p><a id="more"></a><h1 id="1-Bits-Bytes-and-Words"><a href="#1-Bits-Bytes-and-Words" class="headerlink" title="1. Bits, Bytes, and Words"></a>1. Bits, Bytes, and Words</h1><h2 id="1-Bit"><a href="#1-Bit" class="headerlink" title="(1) Bit"></a>(1) Bit</h2><p>The smallest unit of memory is called a <strong>bit</strong>. It can hold one of two values: 0 or 1.</p><h2 id="2-Byte"><a href="#2-Byte" class="headerlink" title="(2) Byte"></a>(2) Byte</h2><p><strong>byte</strong> is the usual unit of computer memory. For nearly all machines, a byte is 8 bits, and that is the standard definition, at least when used to measure storage.<br>&nbsp;<br>Because each bit can be either 0 or 1, there are 256 (that’s 2 times itself 8 times) possible bit patterns of 0s and 1s that can fit in an 8-bit byte.</p><h2 id="3-Word"><a href="#3-Word" class="headerlink" title="(3) Word"></a>(3) Word</h2><p>A <strong>word</strong> is the natural unit of memory for a given computer design.<br>&nbsp;<br>For 8-bit microcomputers, such as the original Apples, a word is just 8 bits. Since then, personal computers moved up to 16-bit words, 32-bit words, and, at the present, 64-bit words. Larger word sizes enable faster transfer of data and allow more memory to be accessed.</p><h1 id="2-Integer-Versus-Floating-Point-Types"><a href="#2-Integer-Versus-Floating-Point-Types" class="headerlink" title="2. Integer Versus Floating-Point Types"></a>2. Integer Versus Floating-Point Types</h1><h2 id="1-The-Integer"><a href="#1-The-Integer" class="headerlink" title="(1) The Integer"></a>(1) The Integer</h2><p>An <strong>integer</strong> is a number with no fractional part.</p><h2 id="2-The-Floating-Point-Number"><a href="#2-The-Floating-Point-Number" class="headerlink" title="(2) The Floating-Point Number"></a>(2) The Floating-Point Number</h2><p>A <strong>floating-point</strong> number more or less corresponds to what mathematicians call a real number.<br>&nbsp;<br>The key point here is that the scheme used to store a floating-point number is different from the one used to store an integer. <strong>Floating-point representation involves breaking up a number into a fractional part and an exponent part and storing the parts separately</strong>.<br>&nbsp;<br>For some arithmetic operations, such as subtracting one large number from another, floating-point numbers are subject to greater <strong>loss of precision</strong>. Because there is an infinite number of real numbers in any range，For example, 7.0 might be stored as a 6.99999 float value.</p><h1 id="3-Basic-C-Data-Types"><a href="#3-Basic-C-Data-Types" class="headerlink" title="3. Basic C Data Types"></a>3. Basic C Data Types</h1><h2 id="1-The-int-Type"><a href="#1-The-int-Type" class="headerlink" title="(1) The int Type"></a>(1) The int Type</h2><p>The <strong>int</strong> type is a signed integer. That means it must be an integer and it can be positive, negative, or zero.</p><h3 id="Octal-and-Hexadecimal"><a href="#Octal-and-Hexadecimal" class="headerlink" title="Octal and Hexadecimal"></a>Octal and Hexadecimal</h3><p>A prefix of <strong>0x</strong> or <strong>0X</strong> (zero-ex) means that you are specifying a <strong>hexadecimal</strong> value, so 16 is written as 0x10, or 0X10.<br>&nbsp;<br>A <strong>0</strong> (zero) prefix means that you are writing in <strong>octal</strong>. For example, the decimal value 16 is written as 020 in <strong>octal</strong>.</p><h3 id="Other-Integer-Types"><a href="#Other-Integer-Types" class="headerlink" title="Other Integer Types"></a>Other Integer Types</h3><p>C offers three adjective keywords to modify the basic integer type: <strong>short</strong>, <strong>long</strong>, and <strong>unsigned</strong>.<br>&nbsp;<br>To cause a small constant to be treated as type long, you can append an <strong>l</strong> (lowercase <strong>L</strong>) or <strong>L</strong> as a <strong>suffix</strong>. </p><p>Add a <strong>u</strong> or <strong>U</strong> to the <strong>suffix</strong> for <strong>unsigned long long</strong>, as in <code>5ull</code> or <code>10LLU</code> .<br>&nbsp;<br>Note that the <strong>short</strong> variable end is displayed the same whether you tell <strong>printf()</strong> that end is a <strong>short</strong> (the <strong>%hd</strong> specifier) or an <strong>int</strong> (the <strong>%d</strong> specifier). </p><p><strong>That’s because C automatically expands a type short value to a type int value when it’s passed as an argument to a function</strong>.</p><p><strong>The int type is intended to be the integer size that the computer handles most efficiently</strong>.</p><h2 id="2-Using-Characters-Type-char"><a href="#2-Using-Characters-Type-char" class="headerlink" title="(2) Using Characters: Type char"></a>(2) Using Characters: Type char</h2><p>The <strong>char</strong> type is used for storing characters such as <strong>letters</strong> and <strong>punctuation marks</strong>, but technically it is an <strong>integer</strong> type.<br>&nbsp;<br>To handle characters, the computer uses a <strong>numerical code</strong> in which certain integers represent certain characters. </p><p>The most commonly used code in the U.S. is the <code>ASCII</code> code.<br>&nbsp;<br>The standard <code>ASCII</code> code runs numerically from 0 to 127. This range is small enough that 7 bits can hold it. The char type is typically defined as an 8-bit unit of memory.<br>&nbsp;<br><strong>Character Constants and Initialization</strong>：A single character contained between single quotes is a C character constant.<br>&nbsp;<br>Because characters are really stored as numeric values, you can also use the numerical code to assign values:</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> grade = <span class="hljs-number">65</span>; <span class="hljs-comment">/* ok for ASCII, but poor style */</span></code></pre><p>Because 65 is the <code>ASCII</code> code for the letter <code>A</code>, this example assigns the value <code>A</code> to grade.<br>&nbsp;<br>C treats character constants as type <code>int</code> rather than type <code>char</code>. For example, on an <code>ASCII</code> system with a 32-bit int and an 8-bit char, the code.</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> grade = <span class="hljs-string">'B'</span>;</code></pre><p><strong>represents ‘B’ as the numerical value 66 stored in a 32-bit unit, but grade winds up with 66 stored in an 8-bit unit.</strong> </p><p>This characteristic of character constants makes it possible to define a character constant such as <code>&#39;FATE&#39;</code>, with four separate 8-bit <code>ASCII</code> codes stored in a 32-bit unit.</p><p>However, attempting to assign such a character constant to a char variable results in only the <strong>last 8 bits</strong> being used, so the variable gets the value <code>&#39;E&#39;</code>.</p><p><strong>Nonprinting Characters</strong><br>The first way we have already mentioned—just use the <code>ASCII</code> code.<br>&nbsp;<br>The second way to represent certain awkward characters in C is to use special symbol sequences. These are called <strong>escape sequences</strong>. </p><table><thead><tr><th align="left">Sequence</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">\a</td><td align="left">Aleart(ANSI C)</td></tr><tr><td align="left">\b</td><td align="left">Backspace</td></tr><tr><td align="left">\f</td><td align="left">Form feed</td></tr><tr><td align="left">\n</td><td align="left">Newline</td></tr><tr><td align="left">\r</td><td align="left">Carrigae return</td></tr><tr><td align="left">\t</td><td align="left">Horizontal tab</td></tr><tr><td align="left">\v</td><td align="left">Vertical tab</td></tr><tr><td align="left">\</td><td align="left">Backslash()</td></tr><tr><td align="left">&#39;</td><td align="left">Single quote(‘)</td></tr><tr><td align="left">&quot;</td><td align="left">Double quote(“)</td></tr><tr><td align="left">?</td><td align="left">Question mark(?)</td></tr><tr><td align="left">\0oo</td><td align="left">Octal value (o represents an octal digit.)</td></tr><tr><td align="left">\0hh</td><td align="left">Hexadecimal value (h represents a hexadecimal digit.)</td></tr></tbody></table><p>To represent alert character (<code>\a</code>), you could use the <code>ASCII</code> code instead: <code>&#39;007&#39;</code>. You can omit the leading zeros, so <code>&#39;\07&#39;</code> or even <code>&#39;\7&#39;</code>will do. This notation causes numbers to be interpreted as octal, even if there is no initial 0.</p><p><strong>Note:</strong> When a character, be it an <strong>escape sequence or not</strong>, is part of a string of characters enclosed in double quotes, <strong>don’t enclose it in single quotes</strong>.</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello!\007\n"</span>);</code></pre><p>will print </p><pre><code class="hljs c">Hello! <span class="hljs-keyword">and</span> <span class="hljs-built_in">beep</span></code></pre><h2 id="3-The-Bool-Type"><a href="#3-The-Bool-Type" class="headerlink" title="(3) The _Bool Type"></a>(3) The _Bool Type</h2><p>C uses the value $1$ for <strong>true</strong> and $0$ for <strong>false</strong>, the <strong>_Bool</strong> type really is just an <strong>integer</strong> type, but one that, in principle, only requires 1 bit of memory, because that is enough to cover the full range from $0$ to $1$.</p><h2 id="4-Portable-Types-stdint-h-and-inttypes-h"><a href="#4-Portable-Types-stdint-h-and-inttypes-h" class="headerlink" title="(4) Portable Types: stdint.h and inttypes.h"></a>(4) Portable Types: stdint.h and inttypes.h</h2><p>The same type name doesn’t necessarily mean the same thing on different systems, What C has done is create more names for the existing types. The trick is to define these new names in a header file called <strong>stdint.h</strong>. </p><p>For example, <code>int32_t</code> represents the type for a <strong>32-bit signed integer</strong>. The header file on a system that uses a 32-bit int could define <code>int32_t</code> as an <strong>alias for int</strong>. A different system, one with a 16-bit int and a 32-bit long, could define the same name, <code>int32_t</code>, as an <strong>alias for int</strong>. </p><h2 id="5-Types-float-double-and-long-double"><a href="#5-Types-float-double-and-long-double" class="headerlink" title="(5) Types float, double, and long double"></a>(5) Types float, double, and long double</h2><p>Here are two <strong>valid floating-point constants</strong>:</p><pre><code class="hljs angelscript"><span class="hljs-number">-1.56E+12</span><span class="hljs-number">3.14159</span><span class="hljs-number">.2</span><span class="hljs-number">4e16</span><span class="hljs-number">.8E-5</span><span class="hljs-number">100.</span></code></pre><p><strong>Rules:</strong></p><ul><li>You can leave out positive signs. </li><li>You can do without a <strong>decimal point</strong> (2E5) or an <strong>exponential part</strong> (19.28), but <strong>not both simultaneously</strong>. </li><li>You can <strong>omit a fractional part</strong> (3.E16) or <strong>an integer<br>part</strong> (.45E–6), but <strong>not both</strong> (that wouldn’t leave much!). </li><li>Don’t use spaces in a floating-point constant.</li></ul><p>By default, the compiler assumes <strong>floating-point constants</strong> are <strong>double</strong> precision.</p><p>C enables you to <strong>override</strong> this default by using an <strong>f</strong> or <strong>F</strong> <strong>suffix</strong> to make the compiler treat a <strong>floating-point</strong> constant as type <strong>float</strong>; examples are <code>2.3f</code> and <code>9.11E9F</code>. </p><p>An <strong>l</strong> or <strong>L</strong> <strong>suffix</strong> makes a number type <strong>long double</strong>; examples are <code>54.3l</code> and <code>4.32e4L</code>. </p><p>If the floating-point number has <strong>no suffix</strong>, it is type <strong>double</strong>.</p><h1 id="4-Format-Specifier"><a href="#4-Format-Specifier" class="headerlink" title="4. Format Specifier"></a>4. Format Specifier</h1><p>It indicates the form that <strong>printf()</strong> uses to display a value.</p><h2 id="1-d"><a href="#1-d" class="headerlink" title="(1) %d"></a>(1) %d</h2><p><strong>%d</strong> notation is used to indicate just where in a line the <strong>integer</strong> is to be printed.  <strong>d means decimal</strong><br>&nbsp;<br>Each <strong>%d</strong> in the format string must be matched by a corresponding <strong>int</strong> value in the list of items to be printed. </p><h2 id="2-Printing-short-long-long-long-and-unsigned-Types"><a href="#2-Printing-short-long-long-long-and-unsigned-Types" class="headerlink" title="(2) Printing short, long, long long, and unsigned Types"></a>(2) Printing short, long, long long, and unsigned Types</h2><p>To print an <strong>unsigned int</strong> number, use the <strong>%u</strong> notation. To print a <strong>long</strong> value, use the <strong>%ld</strong> format specifier.<br>&nbsp;<br>Note that although C allows both <strong>uppercase</strong> and <strong>lowercase</strong> letters for <strong>constant suffixes</strong>, these format specifiers use just <strong>lowercase</strong>.<br>&nbsp;<br>C has several additional <strong>printf()</strong> formats. First, you can use an <strong>h</strong> <strong>prefix</strong> for <strong>short</strong> types. Therefore, <strong>%hd</strong> displays a <strong>short integer</strong> in <strong>decimal</strong> form, and <strong>%ho</strong> displays a <strong>short integer in octal form</strong>. Both the <strong>h</strong> and <strong>l</strong> <strong>prefixes</strong> can be used with <strong>u</strong> for <strong>unsigned</strong> types. </p><h2 id="3-c"><a href="#3-c" class="headerlink" title="(3) %c"></a>(3) %c</h2><p>The <strong>printf()</strong> function uses <strong>%c</strong> to indicate that a <strong>character</strong> should be printed. </p><h2 id="4-Printing-Floating-Point-Values"><a href="#4-Printing-Floating-Point-Values" class="headerlink" title="(4) Printing Floating-Point Values"></a>(4) Printing Floating-Point Values</h2><p>The <strong>printf()</strong> function uses the <strong>%f</strong> format specifier to print type <strong>float</strong> and <strong>double</strong> numbers using <strong>decimal</strong> notation, and it uses <strong>%e</strong> to print them in <strong>exponential</strong> notation. </p><table><thead><tr><th align="left">Format</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">%f</td><td align="left"><strong>decimal</strong> notation(float, double)</td></tr><tr><td align="left">%e</td><td align="left"><strong>exponential</strong> notation(float, double)</td></tr><tr><td align="left">%a, %A</td><td align="left"><strong>hexadecimal p</strong> notation(float,double)</td></tr><tr><td align="left">%Lf, %Le, %La</td><td align="left"><strong>decimal</strong>, <strong>exponential</strong>, <strong>hexadecimal p</strong> notation(long double)</td></tr></tbody></table><h1 id="5-Type-Sizes"><a href="#5-Type-Sizes" class="headerlink" title="5. Type Sizes"></a>5. Type Sizes</h1><p>What type sizes does your system use?</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type int has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type char has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type long has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>));&#125;<span class="hljs-comment">//C has a built-in operator called sizeof that gives sizes in bytes. C99 and C11 provide a %zd specifier for this type used by sizeof.</span></code></pre><p>answer</p><pre><code class="hljs routeros">Type int has a size of 4 bytes.Type char has a size of 1 bytes.Type long has a size of 8 bytes.</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
