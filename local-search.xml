<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Character Input/Output</title>
    <link href="/2020/11/29/Character-Input-Output/"/>
    <url>/2020/11/29/Character-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 8 Character Input/Output and Input Validation</p><a id="more"></a><p>&nbsp;</p><h1 id="1-Single-Character-I-O-getchar-and-putchar"><a href="#1-Single-Character-I-O-getchar-and-putchar" class="headerlink" title="1. Single-Character I/O: getchar() and putchar()"></a>1. Single-Character I/O: getchar() and putchar()</h1><p><strong>getchar()</strong> and <strong>putchar()</strong> perform input and output one character at a time. </p><p>All it does is fetch characters from <strong>keyboard input</strong> and send them to the screen. This process is called <strong>echoing the input</strong>. </p><h1 id="2-Buffers"><a href="#2-Buffers" class="headerlink" title="2. Buffers"></a>2. Buffers</h1><h2 id="1-unbuffered-or-direct-input"><a href="#1-unbuffered-or-direct-input" class="headerlink" title="(1) unbuffered (or direct) input"></a>(1) unbuffered (or direct) input</h2><p>The characters you type are <strong>immediately made available</strong> to the waiting program. </p><h2 id="2-buffered-input"><a href="#2-buffered-input" class="headerlink" title="(2)  buffered input"></a>(2)  buffered input</h2><p>The characters you type are <strong>collected and stored in an area of temporary storage</strong> called a <strong>buffer</strong>.  Pressing <strong>Enter</strong> causes the block of characters you typed to be made available to your program. </p><h3 id="1-fully-buffered-I-O"><a href="#1-fully-buffered-I-O" class="headerlink" title="1)  fully buffered I/O"></a>1)  fully buffered I/O</h3><p>The <strong>buffer</strong> is flushed (the contents are sent to their destination) when it is <strong>full</strong>. This kind of buffering usually occurs with <strong>file input</strong>. </p><p>The buffer size depends on the system, but 512 bytes and 4096 bytes are common values. </p><h3 id="2-line-buffered-I-O"><a href="#2-line-buffered-I-O" class="headerlink" title="2) line-buffered I/O"></a>2) line-buffered I/O</h3><p>The <strong>buffer</strong> is flushed whenever a <strong>newline character shows up</strong>. <strong>Keyboard input</strong> is normally <strong>line buffered</strong>, so that pressing <strong>Enter</strong> flushes the buffer.</p><h1 id="3-Files-Streams-and-Keyboard-Input"><a href="#3-Files-Streams-and-Keyboard-Input" class="headerlink" title="3. Files, Streams, and Keyboard Input"></a>3. Files, Streams, and Keyboard Input</h1><h2 id="1-file"><a href="#1-file" class="headerlink" title="(1)  file"></a>(1)  file</h2><p>A <strong>file</strong> is an area of memory in which information is stored. </p><p>Conceptually, the C program deals with a <strong>stream</strong> instead of directly with a file. </p><h2 id="2-stream"><a href="#2-stream" class="headerlink" title="(2) stream"></a>(2) stream</h2><p>A <strong>stream</strong> is an idealized flow of data to which the actual input or output is mapped.</p><h1 id="4-The-End-of-File"><a href="#4-The-End-of-File" class="headerlink" title="4. The End of File"></a>4. The End of File</h1><p>A computer operating system needs some way to tell where each file begins and ends. </p><p>One method to detect the end of a file is to place a <strong>special character</strong> in the file to <strong>mark the end</strong>.</p><p>A second approach is for the operating system to store information on the size of the file.</p><p>C handles this variety of methods by having the  <strong>getchar()</strong>  function return a special value when the end of a file is reached, regardless of how the operating system actually detects the end of file. The name given to this value is <strong>EOF</strong> (end of file). </p><p>Therefore, the <strong>return value</strong> for <strong>getchar()</strong> when it detects an end of file is <strong>EOF</strong>. The <strong>scanf()</strong> function also returns <strong>EOF</strong> on detecting the end of a file. </p><p>Typically, <strong>EOF</strong> is defined in the <strong>stdio.h</strong> file as follows:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOF (-1)</span></code></pre><p>Normally, <strong>getchar()</strong> returns a value in the range <strong>0</strong> through <strong>127</strong>, because those are values corresponding to the standard character set, but it might return values from <strong>0</strong> through <strong>255</strong> if the system recognizes an extended character set. </p><p>In either case, the value <strong>-1</strong> does not correspond to any character, so it can be used to signal the end of a file.<br>&nbsp;</p><pre><code class="hljs c"><span class="hljs-comment">/* echo_eof.c -- repeats input to end of file */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ch;    <span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)        <span class="hljs-built_in">putchar</span>(ch);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>Note:</strong></p><ul><li>You don’t have to define <strong>EOF</strong> because <strong>stdio.h</strong> takes care of that.</li><li>You don’t have to worry about the actual value of <strong>EOF</strong>, because the <strong>#define</strong> statement in <strong>stdio.h</strong> enables you to use the symbolic representation <strong>EOF</strong>. You shouldn’t write code that assumes <strong>EOF</strong> has a particular value.</li><li><strong>getchar()</strong> is actually type int itself, so it can read the EOF character.</li><li>The fact that <strong>getchar()</strong> is type <strong>int</strong> is why some compilers warn of possible data loss if you assign the <strong>getchar()</strong> return value to a type <strong>char</strong> variable.</li><li>The fact that <strong>ch</strong> is an <strong>integer</strong> doesn’t faze <strong>putchar()</strong>. It still prints the character equivalent.</li><li>To use this program on <strong>keyboard input</strong>, you need a way to type the <strong>EOF</strong> character. On <strong>most Unix and Linux systems</strong>, for example, pressing <strong>Ctrl+D</strong> at the <strong>beginning of a line</strong> causes the <strong>end-of-file signal</strong> to be transmitted. Many <strong>microcomputing systems</strong> recognize <strong>Ctrl+Z</strong> at the beginning of a line as an end-of-file signal; some interpret a <strong>Ctrl+Z</strong> anywhere as an <strong>end-of-file signal</strong>.</li></ul><h1 id="5-Redirection"><a href="#5-Redirection" class="headerlink" title="5. Redirection"></a>5. Redirection</h1><p><strong>Redirecting</strong> input enables your program to use a <strong>file</strong> instead of the <strong>keyboard</strong> for input, and redirecting output enables it to use a <strong>file</strong> instead of the <strong>screen</strong> for output.</p><h2 id="1-Redirecting-Input"><a href="#1-Redirecting-Input" class="headerlink" title="(1) Redirecting Input"></a>(1) Redirecting Input</h2><p>The program runs as described earlier, taking its input from the keyboard. Now suppose you want to use the program on a <strong>text file</strong> called <code>words</code>. </p><p>A <strong>text file</strong> is one containing text—that is, data stored as <strong>human-readable characters</strong>. It could be an essay or a program in C, for example. A file containing machine language instructions, such as the file holding the executable version<br>of a program, is not a text file. </p><p>All you need to do is enter this command instead of the previous one:</p><pre><code class="hljs bash">echo_eof &lt; words</code></pre><p>The <code>&lt;</code> symbol is a <strong>Unix and Linux and DOS/Windows redirection operator</strong>. It causes the <code>words</code> file to be associated with the <strong>stdin stream</strong>, channeling the file contents into the <code>echo_eof</code> program. </p><p>The <code>echo_eof</code> program itself doesn’t know (or care) that the input is coming from a file instead of the keyboard. All it knows is that a stream of characters is being fed to it, so it reads them and prints them one character at a time until the end of file shows up. </p><p>Because C puts files and I/O devices on the same footing, the file is now the I/O device. </p><h2 id="2-Redirecting-Output"><a href="#2-Redirecting-Output" class="headerlink" title="(2) Redirecting Output"></a>(2) Redirecting Output</h2><p>Now suppose you want to have <code>echo_eof</code> send your keyboard input to a file called <code>mywords</code>.</p><p>Then you can enter the following and begin typing:</p><pre><code class="hljs bash">echo_eof &gt; mywords</code></pre><p>The <code>&gt;</code> is a second <strong>redirection operator</strong>. It causes a new file called <code>mywords</code> to be created for your use, and then it *<em>redirects the output *</em>of <code>echo_eof</code> (that is, a copy of the characters you type) to that file. </p><p>If you already have a file with the name <code>mywords</code>, normally it would be <strong>erased</strong> and then <strong>replaced</strong> by the new one. (Many operating systems, however, give you the option of protecting existing files by making them <strong>read-only</strong>.) </p><p>All that appears on your screen are the letters as you type them, and the copies go to the file instead. To end the program, press <strong>Ctrl+D</strong>.</p><h2 id="3-Combined-Redirection"><a href="#3-Combined-Redirection" class="headerlink" title="(3) Combined Redirection"></a>(3) Combined Redirection</h2><p>Now suppose you want to make a copy of the file mywords and call it savewords. Just issue this next command:</p><pre><code class="hljs bash">echo_eof &lt; mywords &gt; savewords</code></pre><p>or:</p><pre><code class="hljs bash">echo_eof &gt; savewords &lt; mywords</code></pre><p><strong>Beware: *<em>Don’t use the *</em>same file for both input and output</strong> to the same command.</p><pre><code class="hljs bash">echo_eof &lt; mywords &gt; mywords....&lt;--WRONG</code></pre><p>The reason is that <code>&gt;</code> mywords causes the original mywords to be <strong>truncated to zero length</strong> before it is ever used as input.</p><p><strong>Rules:</strong></p><ul><li>A <strong>redirection operator</strong> connects an <strong>executable program</strong> (including standard operating system commands) with a <strong>data file</strong>. It cannot be used to connect one data file to another, nor can it be used to connect one program to another program.</li><li>Input cannot be taken from <strong>more than one file</strong>, nor can output be directed to more than one file by using these operators.</li><li>Normally, <strong>spaces between the names and operators are optional</strong>, except occasionally when some characters with special meaning to the Unix shell or Linux shell or the Windows Command Prompt mode are used. We could, for example, have used <code>echo_ eof&lt;words</code>.</li></ul><p>Unix, Linux, and Windows/DOS also feature the <code>&gt;&gt;</code> operator, which enables you to <strong>add data</strong> to the end of an <strong>existing file</strong>, and the pipe operator (<code>|</code>), which enables you to connect the <strong>output of one program</strong> to the <strong>input of a second program</strong>. </p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Branching and Jumps</title>
    <link href="/2020/11/29/Branching-and-Jumps/"/>
    <url>/2020/11/29/Branching-and-Jumps/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 7 C Control Statements: Branching and Jumps</p><a id="more"></a><p>&nbsp;</p><h1 id="1-getchar-and-putchar"><a href="#1-getchar-and-putchar" class="headerlink" title="1.  getchar() and putchar()"></a>1.  getchar() and putchar()</h1><p>The <strong>getchar()</strong> function takes no arguments, and it <strong>returns</strong> the next character from input.<br>&nbsp;<br>The <strong>putchar()</strong> function prints its argument.<br>&nbsp;<br>Because these functions deal only with characters, they are faster and more compact than the more general <strong>scanf()</strong> and <strong>printf()</strong> functions.<br>&nbsp;<br>Characters are really stored as <strong>integers</strong>. <strong>getchar( )</strong> is actually type <strong>int</strong> itself.</p><h1 id="2-The-ctype-h-Family-of-Character-Functions"><a href="#2-The-ctype-h-Family-of-Character-Functions" class="headerlink" title="2. The ctype.h Family of Character Functions"></a>2. The ctype.h Family of Character Functions</h1><p>C has a standard set of functions for analyzing characters; the <strong>ctype.h</strong> header file contains the prototypes.<br>&nbsp;<br>Note that the mapping functions don’t modify the original argument; instead, they return the modified value. </p><pre><code class="hljs c"><span class="hljs-built_in">tolower</span>(ch); <span class="hljs-comment">// no effect on ch</span>ch = <span class="hljs-built_in">tolower</span>(ch); <span class="hljs-comment">// convert ch to lowercase</span></code></pre><table><thead><tr><th align="left">Name</th><th align="left">True If the Argument Is</th></tr></thead><tbody><tr><td align="left">isalnum()</td><td align="left">Alphanumeric (alphabetic or numeric)</td></tr><tr><td align="left">isalpha()</td><td align="left">Alphabetic</td></tr><tr><td align="left">isblank()</td><td align="left">A standard blank character (space, horizontal tab, or newline) or any additional locale-specific character so specified</td></tr><tr><td align="left">iscntrl()</td><td align="left">A control character, such as Ctrl+B</td></tr><tr><td align="left">isdigit()</td><td align="left">A digit</td></tr><tr><td align="left">isgraph()</td><td align="left">Any printing character other than a space</td></tr><tr><td align="left">islower()</td><td align="left">A lowercase character</td></tr><tr><td align="left">isprint()</td><td align="left">A printing character</td></tr><tr><td align="left">ispunct()</td><td align="left">A punctuation character (any printing character other than a space or an alphanumeric character)</td></tr><tr><td align="left">isspace()</td><td align="left">A whitespace character (a space, newline, formfeed, carriage return, vertical tab, horizontal tab, or, possibly, other locale-defined character)</td></tr><tr><td align="left">isupper()</td><td align="left">An uppercase character</td></tr><tr><td align="left">isxdigit()</td><td align="left">A hexadecimal-digit character</td></tr></tbody></table><table><thead><tr><th align="left">Name</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">tolower()</td><td align="left">If the argument is an uppercase character, this function returns the lowercase version; otherwise, it just returns the original argument.</td></tr><tr><td align="left">toupper()</td><td align="left">If the argument is a lowercase character, this function returns the uppercase version; otherwise, it just returns the original argument.</td></tr></tbody></table><h1 id="3-Logical-Operators"><a href="#3-Logical-Operators" class="headerlink" title="3. Logical Operators"></a>3. Logical Operators</h1><table><thead><tr><th align="left">Operator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">and</td></tr><tr><td align="left">||</td><td align="left">or</td></tr><tr><td align="left">!</td><td align="left">not</td></tr></tbody></table><h2 id="1-Precedence"><a href="#1-Precedence" class="headerlink" title="(1) Precedence"></a>(1) Precedence</h2><p>The <strong>!</strong> operator has a very high precedence—higher than <strong>multiplication</strong>, the same as the <strong>increment operators</strong>, and just below that of <strong>parentheses</strong>. The <strong>&amp;&amp;</strong> operator has higher precedence than <strong>||</strong>.</p><h2 id="2-Order-of-Evaluation"><a href="#2-Order-of-Evaluation" class="headerlink" title="(2) Order of Evaluation"></a>(2) Order of Evaluation</h2><p>The <strong>&amp;&amp;</strong> and <strong>||</strong> operators are sequence points, so all side effects take place before a program moves from one operand to the next. </p><pre><code class="hljs c"><span class="hljs-keyword">while</span> ( x++ &lt; <span class="hljs-number">10</span> &amp;&amp; x + y &lt; <span class="hljs-number">20</span>)</code></pre><p>The fact that the <strong>&amp;&amp;</strong> operator is a sequence point guarantees that <code>x</code> is incremented before the expression on the right is evaluated.</p><h1 id="4-A-Word-Count-Program"><a href="#4-A-Word-Count-Program" class="headerlink" title="4. A Word-Count Program"></a>4. A Word-Count Program</h1><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STOP <span class="hljs-meta-string">'\x1b'</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> c;  <span class="hljs-comment">//read in character</span>    <span class="hljs-keyword">char</span> prev; <span class="hljs-comment">//previous character read</span>    <span class="hljs-keyword">long</span> n_chars = <span class="hljs-number">0L</span>; <span class="hljs-comment">//number of characters</span>    <span class="hljs-keyword">long</span> n_alphabets = <span class="hljs-number">0L</span>; <span class="hljs-comment">//alphabetic</span>    <span class="hljs-keyword">long</span> n_digits = <span class="hljs-number">0L</span>; <span class="hljs-comment">//digits</span>    <span class="hljs-keyword">long</span> n_spaces = <span class="hljs-number">0L</span>;    <span class="hljs-keyword">long</span> n_punctuations = <span class="hljs-number">0L</span>;    <span class="hljs-keyword">int</span> n_lines = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> n_words = <span class="hljs-number">0</span>;    <span class="hljs-keyword">bool</span> inword = <span class="hljs-literal">false</span>;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter text to be analyzed (Esc to terminate):\n"</span>);    prev = <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">while</span> ((c = getchar()) != STOP)    &#123;        n_chars++;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalpha</span>(c))           n_alphabets++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))            n_digits++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ispunct</span>(c))            n_punctuations++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c))            n_spaces++;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'\n'</span>)            n_lines++;        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isspace</span>(c) &amp;&amp; !inword)         &#123;            inword = <span class="hljs-literal">true</span>;            n_words++;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c) &amp;&amp; inword)         &#123;            inword = <span class="hljs-literal">false</span>; <span class="hljs-comment">//reached end of a word</span>        &#125;        prev = c;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Charaters = %ld, alphabets = %ld, digits = %ld,\</span><span class="hljs-string">    punctuations = %ld, spaces = %ld,  words = %d, lines = %d\n"</span>,    n_chars,n_alphabets,n_digits,n_punctuations,n_spaces,n_words,n_lines);    <span class="hljs-comment">/*return 0; */</span>&#125;</code></pre><p>Output:</p><pre><code class="hljs c"><span class="hljs-function">Enter <span class="hljs-built_in">text</span> to be <span class="hljs-title">analyzed</span> <span class="hljs-params">(Esc to <span class="hljs-built_in">terminate</span>)</span>:</span><span class="hljs-function">Reason is a</span><span class="hljs-function">powerful servant but</span>an inadequate master.<span class="hljs-number">2</span> - <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;*** :) ***^[Charaters = <span class="hljs-number">77</span>, alphabets = <span class="hljs-number">45</span>, digits = <span class="hljs-number">3</span>, punctuations = <span class="hljs-number">12</span>, spaces = <span class="hljs-number">17</span>,  words = <span class="hljs-number">17</span>, lines = <span class="hljs-number">5</span></code></pre><h1 id="5-The-Conditional-Operator"><a href="#5-The-Conditional-Operator" class="headerlink" title="5. The Conditional Operator: ?:"></a>5. The Conditional Operator: ?:</h1><p>C offers a shorthand way to express one form of the <strong>if else</strong> statement. It is called a conditional expression and uses the <strong>?:</strong> conditional operator. </p><pre><code class="hljs c">expression1 ? expression2 : expression3</code></pre><p>If expression1 is true (nonzero), the whole conditional expression has the same value as expression2. If expression1 is false (zero), the whole conditional expression has the same value as expression3.</p><h1 id="6-Loop-Aids-continue-and-break"><a href="#6-Loop-Aids-continue-and-break" class="headerlink" title="6. Loop Aids: continue and break"></a>6. Loop Aids: continue and break</h1><h2 id="1-The-continue-Statement"><a href="#1-The-continue-Statement" class="headerlink" title="(1) The continue Statement"></a>(1) The continue Statement</h2><p>The continue statement causes the program to <strong>skip over</strong> the rest of the loop, which is devoted to processing valid input. Instead, the program <strong>starts the next loop cycle</strong> by attempting to read the next input value. </p><p><strong>continue</strong> works for the while, do while, for, and not for the switch function.</p><p><strong>continue</strong> terminates the current loop, but not the entire loop.</p><pre><code class="hljs c"><span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">10</span>; count++)&#123;ch = getchar();<span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'\n'</span>)<span class="hljs-keyword">continue</span>;<span class="hljs-built_in">putchar</span>(ch);&#125;</code></pre><p>In this case, when the <strong>continue</strong> statement is executed, <strong>first count is incremented</strong> and then it’s compared to 10.</p><h2 id="2-The-break-Statement"><a href="#2-The-break-Statement" class="headerlink" title="(2) The break Statement"></a>(2) The break Statement</h2><p>A <strong>break</strong> statement in a loop causes the program to break free of the loop that encloses it and to proceed to the next stage of the program. </p><p>break works for while, do while, for and switch functions.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> i;  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  &#123;    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)    <span class="hljs-keyword">break</span>;  &#125;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %d\n"</span>,i);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>In this case, when the program executes the <strong>break</strong> statement, it breaks out of the for loop <strong>without adding i</strong>.  </p><h1 id="7-The-goto-Statement"><a href="#7-The-goto-Statement" class="headerlink" title="7. The goto Statement"></a>7. The goto Statement</h1><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &gt; <span class="hljs-number">12</span>)    <span class="hljs-keyword">goto</span> a;<span class="hljs-keyword">goto</span> b;a: cost = cost * <span class="hljs-number">1.05</span>;flag = <span class="hljs-number">2</span>;b: bill = cost * flag;</code></pre><p>It is the same as:</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &gt; <span class="hljs-number">12</span>)&#123;    cost = cost * <span class="hljs-number">1.05</span>;    flag = <span class="hljs-number">2</span>;&#125;bill = cost * flag;</code></pre><p>When a <strong>goto</strong> is encountered, it jumps unconditionally to the statement where the <strong>label</strong> is, and then <strong>executes sequentially from there</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operators, Expressions, and Statements</title>
    <link href="/2020/11/28/Operators-Expressions-and-Statements/"/>
    <url>/2020/11/28/Operators-Expressions-and-Statements/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 5 Operators, Expressions, and Statements</p><a id="more"></a><p>&nbsp;</p><h1 id="1-Fundamental-Operators"><a href="#1-Fundamental-Operators" class="headerlink" title="1. Fundamental Operators"></a>1. Fundamental Operators</h1><h2 id="1-Assignment-Operator"><a href="#1-Assignment-Operator" class="headerlink" title="(1) Assignment Operator: ="></a>(1) Assignment Operator: =</h2><p>The <code>=</code> symbol is called the assignment operator.</p><h3 id="Some-Terminology-Data-Objects-Lvalues-Rvalues-and-Operands"><a href="#Some-Terminology-Data-Objects-Lvalues-Rvalues-and-Operands" class="headerlink" title="Some Terminology: Data Objects, Lvalues, Rvalues, and Operands"></a>Some Terminology: Data Objects, Lvalues, Rvalues, and Operands</h3><p>Consider an assignment statement. Its purpose is to store a value at a memory location.<br>&nbsp;<br><strong>Data object</strong> is a general term for a region of data storage that can be used to hold values.<br>&nbsp;<br>C uses the term <strong>lvalue</strong> to mean any such name or expression that identifies a particular data object. <strong>Object</strong> refers to the actual data storage, but an <strong>lvalue</strong> is a <strong>label</strong> used to identify, or locate, that storage.</p><p>The term <strong>rvalue</strong> refers to quantities that can be assigned to modifiable <strong>lvalues</strong> but which are not themselves lvalues. <strong>Rvalues</strong> can be constants, variables, or any other expression that yields a value. </p><h2 id="2-Division-Operator"><a href="#2-Division-Operator" class="headerlink" title="(2) Division Operator: /"></a>(2) Division Operator: /</h2><p>Division works differently for integer types than it does for floating types. Floating-type division gives a floating-point answer, but integer division yields an integer answer.</p><p>Integer division does not round to the nearest integer, but always truncates (that is, discards the entire fractional part).</p><pre><code class="hljs c"><span class="hljs-number">5</span>/<span class="hljs-number">2</span> = <span class="hljs-number">2</span><span class="hljs-number">-5</span>/<span class="hljs-number">2</span> = <span class="hljs-number">-2</span><span class="hljs-number">5</span>/(<span class="hljs-number">-2</span>) = <span class="hljs-number">-2</span></code></pre><h2 id="3-Modulus-Operator"><a href="#3-Modulus-Operator" class="headerlink" title="(3) Modulus Operator: %"></a>(3) Modulus Operator: %</h2><p>The modulus operator is used in <strong>integer arithmetic</strong>. It gives the remainder that results when the integer to its left is divided by the integer to its right. For example, 13 % 5 (read as “13 modulo 5”) has the value 3.</p><p>You get a negative modulus value if the first operand is negative, and you get a positive modulus otherwise.</p><pre><code class="hljs c"><span class="hljs-number">5</span>%<span class="hljs-number">2</span> = <span class="hljs-number">1</span><span class="hljs-number">-5</span>%<span class="hljs-number">2</span> = <span class="hljs-number">-1</span><span class="hljs-number">5</span>%(<span class="hljs-number">-2</span>) = <span class="hljs-number">1</span></code></pre><h2 id="4-Increment-and-Decrement-Operators-and-–"><a href="#4-Increment-and-Decrement-Operators-and-–" class="headerlink" title="(4) Increment and Decrement Operators: ++ and –"></a>(4) Increment and Decrement Operators: ++ and –</h2><p>The increment operator performs a simple task; it increments (increases) the value of its operand by 1. </p><pre><code class="hljs pgsql">a_post = a++; // postfix: a <span class="hljs-keyword">is</span> changed <span class="hljs-keyword">after</span> its <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> usedb_pre= ++b;// prefix: b <span class="hljs-keyword">is</span> changed <span class="hljs-keyword">before</span> its <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> used(a + b)++; //invalid</code></pre><p>You can get fooled if you try to do too much at once with the increment operators.</p><pre><code class="hljs c"><span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">21</span>)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%10d %10d\n"</span>, num, num*num++);&#125;</code></pre><p>In C, the compiler can choose which arguments in a function to evaluate first.</p><pre><code class="hljs c">ans = num/<span class="hljs-number">2</span> + <span class="hljs-number">5</span>*(<span class="hljs-number">1</span> + num++);</code></pre><p>You would think that it would find num/2 first and then move on, but it might do the last term first.</p><h2 id="5-The-Comma-Operator"><a href="#5-The-Comma-Operator" class="headerlink" title="(5) The Comma Operator"></a>(5) The Comma Operator</h2><p>First, it guarantees that the expressions it separates are evaluated in a <strong>left-to-right order</strong>.<br>Second, the <strong>value of the whole comma expression</strong> is the value of the <strong>right-hand member</strong>.</p><pre><code class="hljs c">x = (y = <span class="hljs-number">3</span>, (z = ++y + <span class="hljs-number">2</span>) + <span class="hljs-number">5</span>);<span class="hljs-comment">//x = (z = ++y + 2) + 5;</span></code></pre><h1 id="2-Operator-Precedence"><a href="#2-Operator-Precedence" class="headerlink" title="2. Operator Precedence"></a>2. Operator Precedence</h1><table><thead><tr><th align="center">Operators (decreasing precedence)</th><th align="center">Associativity</th></tr></thead><tbody><tr><td align="center">+ - (unary)</td><td align="center">Left to right</td></tr><tr><td align="center">* /</td><td align="center">Left to right</td></tr><tr><td align="center">+ - (binary)</td><td align="center">Left to right</td></tr><tr><td align="center">=</td><td align="center">Left to right</td></tr><tr><td align="center">,</td><td align="center">Left to right</td></tr></tbody></table><h1 id="3-Expressions-and-Statements"><a href="#3-Expressions-and-Statements" class="headerlink" title="3. Expressions and Statements"></a>3. Expressions and Statements</h1><h2 id="1-Expressions"><a href="#1-Expressions" class="headerlink" title="(1) Expressions"></a>(1) Expressions</h2><p>An expression consists of a combination of operators and operands.<br>&nbsp;<br>An important property of C is that every C expression has a value. </p><h2 id="2-Statements"><a href="#2-Statements" class="headerlink" title="(2) Statements"></a>(2) Statements</h2><p>Statements are the primary building blocks of a program. A program is a series of statements with some necessary punctuation. A statement is a complete instruction to the computer. In C, statements are indicated by a <strong>semicolon</strong> at the end. </p><h1 id="4-Type-Conversions"><a href="#4-Type-Conversions" class="headerlink" title="4. Type Conversions"></a>4. Type Conversions</h1><h2 id="1-Automatic-Type-Conversions"><a href="#1-Automatic-Type-Conversions" class="headerlink" title="(1) Automatic Type Conversions"></a>(1) Automatic Type Conversions</h2><ol><li>When appearing in an <strong>expression</strong>, <strong>char</strong> and <strong>short</strong>, both <strong>signed</strong> and <strong>unsigned</strong>, are <strong>automatically</strong> converted to <strong>int</strong> or, if necessary, to <strong>unsigned int</strong>. (If <strong>short</strong> is the same size as <strong>int</strong>, <strong>unsigned short</strong> is larger than <strong>int</strong>; in that case, <strong>unsigned short</strong> is converted to <strong>unsigned int</strong>.) Under <strong>K&amp;R</strong> C, but not under current C, <strong>float</strong> is automatically converted to <strong>double</strong>. Because they are conversions to larger types, they are called <strong>promotions</strong>.</li><li>In any <strong>operation</strong> involving <strong>two types</strong>, both values are converted to the <strong>higher ranking</strong> of the two types.</li><li>The <strong>ranking of types</strong>, from <strong>highest to lowest</strong>, is <strong>long double</strong>, <strong>double</strong>, <strong>float</strong>, <strong>unsigned long long</strong>, <strong>long long</strong>, <strong>unsigned long</strong>, <strong>long</strong>, <strong>unsigned int</strong>, and <strong>int</strong>. One possible <strong>exception</strong> is when <strong>long and int are the same size</strong>, in which case <strong>unsigned int</strong> outranks <strong>long</strong>. The <strong>short</strong> and <strong>char</strong> types don’t appear in this list because they would have been already promoted to int or perhaps <strong>unsigned int</strong>.</li><li>In an <strong>assignment statement</strong>, the final result of the calculations is converted to the type of <strong>the variable being assigned a value</strong>. This process can result in <strong>promotion</strong>, as described in rule 1, or <strong>demotion</strong>, in which a value is converted to a lower-ranking type.</li><li>When passed as <strong>function arguments</strong>, <strong>char</strong> and <strong>short</strong> are converted to <strong>int</strong>, and <strong>float</strong> is converted to <strong>double</strong>. This <strong>automatic promotion</strong> is overridden by function prototyping.</li></ol><h2 id="2-The-Cast-Operator"><a href="#2-The-Cast-Operator" class="headerlink" title="(2) The Cast Operator"></a>(2) The Cast Operator</h2><p>The parentheses and type name together constitute a cast operator.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>)<span class="hljs-number">1.6</span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Charater Strings and Formatted Input/Output</title>
    <link href="/2020/11/28/Charater-Strings-and-Formatted-Input-Output/"/>
    <url>/2020/11/28/Charater-Strings-and-Formatted-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 4 Charater Strings and Formatted Input/Output</p><a id="more"></a><h1 id="1-Character-Strings"><a href="#1-Character-Strings" class="headerlink" title="1. Character Strings"></a>1. Character Strings</h1><p> A character string is a series of one or more characters. </p><h2 id="1-Type-char-Arrays-and-the-Null-Character"><a href="#1-Type-char-Arrays-and-the-Null-Character" class="headerlink" title="(1) Type char Arrays and the Null Character"></a>(1) Type char Arrays and the Null Character</h2><p>C has no special variable type for strings. Instead, strings are stored in an array of type char. Characters in a string are stored in adjacent memory cells, one character per cell, and an array consists of adjacent memory locations.<br><img src="https://img-blog.csdnimg.cn/20190521222859479.png" srcset="/img/loading.gif" alt=""><br>The <strong>null character</strong> is not the digit zero; it is the nonprinting character whose <strong>ASCII</strong> code value (or equivalent) is <strong>0</strong>. Strings in C are always stored with this terminating null character. The presence of the null character means that the array must have <strong>at least one more cell</strong> than the number of characters to be stored. </p><h2 id="2-Using-Strings"><a href="#2-Using-Strings" class="headerlink" title="(2) Using Strings"></a>(2) Using Strings</h2><p>In general, <strong>scanf()</strong> is used with <strong>%s</strong> to read only a <strong>single word</strong>, not a whole phrase, as a string. C has other input-reading functions, such as <strong>fgets()</strong>, for handling general strings.</p><h2 id="3-Strings-Versus-Characters"><a href="#3-Strings-Versus-Characters" class="headerlink" title="(3) Strings Versus Characters"></a>(3) Strings Versus Characters</h2><p><img src="https://img-blog.csdnimg.cn/201905212249433.png" srcset="/img/loading.gif" alt="A word is the natural unit of memory for a given computer design.For 8-bit microcomputers,"></p><h1 id="2-The-strlen-Function"><a href="#2-The-strlen-Function" class="headerlink" title="2. The strlen() Function"></a>2. The strlen() Function</h1><p>The <strong>strlen()</strong> function gives the length of a string in characters.<br>The <strong>string.h</strong> file contains function prototypes for several string related functions, including <strong>strlen()</strong>.<br>&nbsp;<br>The <strong>strlen()</strong> gives you the exact number of characters (including spaces and punctuation) in the string. The <strong>sizeof</strong> operator gives you a number one <strong>larger</strong> because it also counts the <strong>invisible null character</strong> used to end the string.<br>&nbsp;<br>The <strong>C99</strong> and <strong>C11</strong> standards use a <strong>%zd</strong> specifier for the type used by the <strong>sizeof</strong> operator. This also applies for type returned by <strong>strlen()</strong>.<br>&nbsp;<br>The preceding chapter used <strong>sizeof</strong> with <strong>parentheses</strong>, but this example doesn’t. <strong>Parentheses</strong> are <strong>required for types</strong> but are <strong>optional for particular quantities</strong>. That is, you would use <strong>sizeof(char)</strong> or <strong>sizeof(float)</strong> but can use <strong>sizeof name</strong> or <strong>sizeof 6.28.</strong></p><h1 id="3-Constants-and-the-C-Preprocessor"><a href="#3-Constants-and-the-C-Preprocessor" class="headerlink" title="3. Constants and the C Preprocessor"></a>3. Constants and the C Preprocessor</h1><p>The <strong>preprocessor</strong> uses <strong>#include</strong> to incorporate information from another file, it also lets you define constants. Just add a line like the following at the top of the file containing your program:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TAXRATE 0.015</span></code></pre><p><strong>No semicolon</strong> is used because this is a substitution mechanism handled by the <strong>preprocessor</strong>, not a <strong>C</strong> statement.</p><h1 id="4-The-const-Modifier"><a href="#4-The-const-Modifier" class="headerlink" title="4. The const Modifier"></a>4. The const Modifier</h1><p><strong>C90</strong> added a second way to <strong>create symbolic constants</strong>—using the <strong>const</strong> keyword to convert a declaration for a <strong>variable</strong> into a declaration for a <strong>constant</strong>:</p><pre><code class="hljs c"><span class="hljs-comment">// MONTHS a symbolic constant for 12</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MONTHS = <span class="hljs-number">12</span>;</code></pre><p>This newer approach is more flexible than using <strong>#define</strong>; it lets you declare a type, and it allows better control over which parts of a program can use the constant.</p><h1 id="5-Manifest-Constants-on-the-Job"><a href="#5-Manifest-Constants-on-the-Job" class="headerlink" title="5. Manifest Constants on the Job"></a>5. Manifest Constants on the Job</h1><p>The C header files <strong>limits.h</strong> and <strong>float.h</strong> supply detailed information about the <strong>size limits</strong> of <strong>integer</strong> types and <strong>floating</strong> types, respectively. </p><h1 id="6-The-printf-Function"><a href="#6-The-printf-Function" class="headerlink" title="6. The printf() Function"></a>6. The printf() Function</h1><p>The instructions you give <strong>printf()</strong> when you ask it to print a variable depend on the variable type. </p><table><thead><tr><th align="left">Conversion</th><th align="left">Output Specification</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">Floating-point-number, hexadecimal digits and p-notation(C99/C11).</td></tr><tr><td align="left">%A</td><td align="left">Floating-point-number, hexadecimal digits and p-notation(C99/C11).</td></tr><tr><td align="left">%c</td><td align="left">Single character.</td></tr><tr><td align="left">%d</td><td align="left">Single decimal integer.</td></tr><tr><td align="left">%e</td><td align="left">Floating-point number, e-notation.</td></tr><tr><td align="left">%E</td><td align="left">Floating-point number, e-notation.</td></tr><tr><td align="left">%f</td><td align="left">Floating-point number, decimal notation.</td></tr><tr><td align="left">%g</td><td align="left">Using %f or %e, depending on the value. The %e style is used if the exponent is less than -4 or greater than or equal to the presion.</td></tr><tr><td align="left">%G</td><td align="left">Using %f or %E, depending on the value. The %E style is used if the exponent is less than -4 or greater than or equal to the presion.</td></tr><tr><td align="left">%i</td><td align="left">Single decimal integer(same as %d).</td></tr><tr><td align="left">%o</td><td align="left">Unsigned octal integer.</td></tr><tr><td align="left">%p</td><td align="left">A pointer.</td></tr><tr><td align="left">%s</td><td align="left">Character string.</td></tr><tr><td align="left">%u</td><td align="left">Unsigned decimal integer.</td></tr><tr><td align="left">%x</td><td align="left">Unsigned hexadecimal integer, using hex digits 0f.</td></tr><tr><td align="left">%X</td><td align="left">Unsigned hexadecimal integer, using hex digits 0F.</td></tr><tr><td align="left">%%</td><td align="left">Prints a percent sign.</td></tr></tbody></table><h2 id="（1）Conversion-Specification-Modifiers-for-printf"><a href="#（1）Conversion-Specification-Modifiers-for-printf" class="headerlink" title="（1）Conversion Specification Modifiers for printf()"></a>（1）Conversion Specification Modifiers for printf()</h2><table><thead><tr><th align="left">Modifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">flag</td><td align="left">Five flags:-,+,space,#, and 0.</td></tr><tr><td align="left">digit(s)</td><td align="left">The minimun field width. A wilder field will be used if the printed number or string won’t fit in the field.</td></tr><tr><td align="left">.digit(s)</td><td align="left">Presions. For %e, %E, and %f conversions, the maximun number of significant digits. For %g and %G conversions, the maximun number of significant digits. For %s conversion, the maximun number of characters to be printed. For integer conversions, the minimun number of digits to apper: leading zeros are used if necessary to meet this minimum. Using only . implies a following zero, so %.f is the same as %.0f.</td></tr><tr><td align="left">h</td><td align="left">Used with an integer conversion specifier to indicate a short int or unsigned short int value.</td></tr><tr><td align="left">hh</td><td align="left">Used with an integer conversion specifier to indicate a signed char or unsigned char value.</td></tr><tr><td align="left">j</td><td align="left">Used with an integer conversion specifier to indicate an intmax_t or uintmax_t value; these are types defined in stdint.h.</td></tr><tr><td align="left">l</td><td align="left">Used with an integer conversion specifier to indicate a long int or unsigned long int.</td></tr><tr><td align="left">ll</td><td align="left">Used with an integer conversion specifier to indicate a long long int or unsigned long long int.(C99).</td></tr><tr><td align="left">L</td><td align="left">Used with a floating-point conversion specifier to indicate a long double value.</td></tr><tr><td align="left">t</td><td align="left">Used with an integer conversion specifier to indicate a ptrdiff_t value. This is the type corresponding to the difference between two pointers. (C99).</td></tr><tr><td align="left">z</td><td align="left">Used with an integer conversion specifier to indicate a size_t value. This is the type returned by sizeof. (C99).</td></tr></tbody></table><h2 id="（2）The-printf-Flags"><a href="#（2）The-printf-Flags" class="headerlink" title="（2）The printf( ) Flags"></a>（2）The printf( ) Flags</h2><table><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">The item is left-justified; that is, it is printed begining at the left of the field.</td></tr><tr><td align="left">+</td><td align="left">Signed values are displayed with a plus sign, if positive, and with a minus sign, if negative.</td></tr><tr><td align="left">space</td><td align="left">Signed values are displayed with a  leading space (but no sign) if positive and with a minus sign if negative. A + flag overrides a space.</td></tr><tr><td align="left">#</td><td align="left">Used  an alternative form for the conversion specification. Produces an initial 0 for the %o form and initial 0x for the %x or %X form, respectively. For all floating-point forms, # gurantees that a decimal-point character is printed, even if no digits follow. For %g and %G forms, it prevents traing zeros form being removed.</td></tr><tr><td align="left">0</td><td align="left">For numeric forms, pad the field width with leading zeros indtead of with spaces. This flag is ignored if a - flag is present or if, for an integer form, a precision is specified.</td></tr></tbody></table><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">float</span> f = <span class="hljs-number">321454.321345</span>;   <span class="hljs-keyword">float</span> f1 = <span class="hljs-number">12.2345678</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %04f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %06.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %6.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %-6.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"321454.321345 = %7f\n"</span>,f);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"321454.321345 = %7.3f\n"</span>,f);    <span class="hljs-keyword">int</span> n1 = <span class="hljs-number">3456</span>;  <span class="hljs-keyword">int</span> n2  = <span class="hljs-number">1</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3456 = %3.2d\n"</span>,n1);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3456 = %6.2d\n\n"</span>,n1);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 = %.4d\n"</span>,n2);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 = %3.2d\n\n"</span>,n2);    <span class="hljs-comment">//测试字符串宽度精度</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %9.3s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %9s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %3s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Output：</p><pre><code class="hljs c"><span class="hljs-number">2.3</span> = <span class="hljs-number">2.300000</span> <span class="hljs-comment">//%04f：输出宽度至少4，精度不限制时用默认的，浮点数默认精度6位，这里宽度指总的宽度（包括小数点和小数点后面的数）</span><span class="hljs-number">2.3</span> = <span class="hljs-number">002.30</span> <span class="hljs-comment">//%06.2f： 总共宽度至少6位，精度2位，因此左边补0</span><span class="hljs-number">2.3</span> =   <span class="hljs-number">2.30</span> <span class="hljs-comment">//%6.2f：总共宽度至少6位，精度2位，左边空两格，默认右对齐</span><span class="hljs-number">2.3</span> = <span class="hljs-number">2.30</span> <span class="hljs-comment">// %-6.2f：总共宽度至少6位，精度2位，右边空两格，加-号左对齐</span><span class="hljs-number">321454.321345</span> = <span class="hljs-number">321454.312500</span><span class="hljs-number">321454.321345</span> = <span class="hljs-number">321454.312</span><span class="hljs-number">3456</span> = <span class="hljs-number">3456</span>  <span class="hljs-comment">//%3.2d ，总宽度至少3</span><span class="hljs-number">3456</span> =   <span class="hljs-number">3456</span>  <span class="hljs-comment">//%6.2d ，总宽度至少6</span><span class="hljs-number">1</span> = <span class="hljs-number">0001</span> <span class="hljs-comment">//%.4d 有效位4位，只有1位，其余补0</span><span class="hljs-number">1</span> =  <span class="hljs-number">01</span>  <span class="hljs-comment">//%3.2d 总宽度3，有效位2，因此左边空1格，补一个0</span><span class="hljs-string">"printf"</span> =        pri <span class="hljs-comment">// %9.3s 总宽度至少9，有效3位，因此只现实3个字符</span><span class="hljs-string">"printf"</span> =    <span class="hljs-built_in">printf</span>  <span class="hljs-comment">// %9s，总宽度至少9，宽度9</span><span class="hljs-string">"printf"</span> = <span class="hljs-built_in">printf</span>   <span class="hljs-comment">// %3s，总宽度至少3，因此宽度为6</span></code></pre><h2 id="（3）The-Return-Value-of-printf"><a href="#（3）The-Return-Value-of-printf" class="headerlink" title="（3）The Return Value of printf()"></a>（3）The Return Value of printf()</h2><p>The <strong>printf()</strong> function also has a return value; it returns the <strong>number of characters</strong> it printed. </p><h2 id="（4）Printing-Long-Strings"><a href="#（4）Printing-Long-Strings" class="headerlink" title="（4）Printing Long Strings"></a>（4）Printing Long Strings</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's one way to print a "</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"long string.\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's another way to print a \</span><span class="hljs-string">long string.\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's the newest way to print a "</span><span class="hljs-string">"long string.\n"</span>); <span class="hljs-comment">/* ANSI C */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Method 1 is to use more than one <strong>printf()</strong> statement.<br>Method 2 is to terminate the end of the first line with a backslash/return combination.<br>Method 3, which ANSI C introduced, is <strong>string concatenation</strong>. If you follow one <strong>quoted</strong> string constant with another, separated only by <strong>whitespace</strong>, C treats the combination as a <strong>single string</strong>. </p><h1 id="7-scanf"><a href="#7-scanf" class="headerlink" title="7. scanf()"></a>7. scanf()</h1><p>It converts string input into various forms: integers, floating-point numbers, characters, and C strings.<br>&nbsp;<br>Rules:</p><blockquote><ul><li>If you use <strong>scanf()</strong> to read a value for one of the basic variable types, precede the variable name with an <strong>&amp;</strong>.</li><li>If you use <strong>scanf()</strong> to read a string into a <strong>character array</strong>, don’t use an <strong>&amp;</strong>.</li></ul></blockquote><h2 id="1-Conversion-Specifiers-for-scanf"><a href="#1-Conversion-Specifiers-for-scanf" class="headerlink" title="(1) Conversion Specifiers for scanf()"></a>(1) Conversion Specifiers for scanf()</h2><p>The <strong>scanf()</strong> function uses pretty much the same set of conversion specification characters as <strong>printf()</strong> does. The main difference is that <strong>printf()</strong> uses %f, %e, %E, %g, and %G for both type float and type double, whereas <strong>scanf()</strong> uses them just for type float, requiring the <strong>l</strong> modifier for double. </p><table><thead><tr><th align="left">Conversion Specifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">%c</td><td align="left">Interpret input as a character.</td></tr><tr><td align="left">%d</td><td align="left">Interpret input as a signed decimal integer.</td></tr><tr><td align="left">%e, %f, %g, %a</td><td align="left">Interpret input as a floating-point number (%a is C99).</td></tr><tr><td align="left">%E, %F, %G, %A</td><td align="left">Interpret input as a floating-point number (%A is C99).</td></tr><tr><td align="left">%i</td><td align="left">Interpret input as a signed decimal integer.</td></tr><tr><td align="left">%o</td><td align="left">Interpret input as a signed Octal integer.</td></tr><tr><td align="left">%p</td><td align="left">Intepret input as a pointer (an address).</td></tr><tr><td align="left">%s</td><td align="left">Intepret input as a string. Input begins with the first non-whitespace character and includes evertything up to the next whitespace character.</td></tr><tr><td align="left">%u</td><td align="left">Interpret input as a unsigned decimal integer.</td></tr><tr><td align="left">%x, %X</td><td align="left">Interpret input as a signed hexadecimal integer.</td></tr></tbody></table><h2 id="2-Conversion-Modifiers-for-scanf"><a href="#2-Conversion-Modifiers-for-scanf" class="headerlink" title="(2) Conversion Modifiers for scanf()"></a>(2) Conversion Modifiers for scanf()</h2><table><thead><tr><th align="left">Modifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">Suppress assignment.</td></tr><tr><td align="left">digit(s)</td><td align="left">Maximum field width. Input stops when the maximum field width is reached or when the first whitespace character is encountered, whichever comes first.</td></tr><tr><td align="left">hh</td><td align="left">Read an integer as a signed char or unsigned char.</td></tr><tr><td align="left">ll</td><td align="left">Read an integer as a long long or unsigned long long (C99).</td></tr><tr><td align="left">h, l or L</td><td align="left">“%hd” and “%hi” indicate that the value will be stored in a <strong>short int</strong>. “%ho”, “%hx”, and “%hu” indicate that the value will be stored in an <strong>unsigned short int</strong>. “%ld” and “%li” indicate that the value will be stored in a <strong>long</strong>. “%lo”, “%lx”, and “%lu” indicate that the value will be stored in <strong>unsigned long</strong>. “%le”, “%lf”, and “%lg” indicate that the value will be stored in type <strong>double</strong>. Using L instead of l with e, f, and g indicates that the value will be stored in type <strong>long double</strong>. In the absence of these modifiers, d, i, o, and x indicate type <strong>int</strong>, and e, f, and g indicate type <strong>float</strong>.</td></tr><tr><td align="left">j</td><td align="left">When followed by an integer specifier, indicates using the intmax_t or uintmax_t type (C99).</td></tr><tr><td align="left">z</td><td align="left">When followed by an integer specifier, indicates using the type returned by sizeof (C99).</td></tr><tr><td align="left">t</td><td align="left">When followed by an integer specifier, indicates using the type used to represent the difference between two pointers (C99).</td></tr></tbody></table><h2 id="3-The-scanf-View-of-Input"><a href="#3-The-scanf-View-of-Input" class="headerlink" title="(3) The scanf() View of Input"></a>(3) The scanf() View of Input</h2><p>It skips over whitespace characters (spaces, tabs, and newlines) until it finds a non-whitespace character. scanf() continues reading and saving characters until it encounters a nondigit. </p><p>&nbsp;<br>If you use a <strong>%c</strong> specifier, all input characters are fair game. If the next input character is a space or a newline, a space or a newline is assigned to the indicated variable; <strong>whitespace is not skipped</strong>.</p><h2 id="4-The-scanf-Return-Value"><a href="#4-The-scanf-Return-Value" class="headerlink" title="(4) The scanf() Return Value"></a>(4) The scanf() Return Value</h2><p>The <strong>scanf()</strong> function returns <strong>the number of items</strong> that it successfully reads. If it reads no items, which happens if you type a nonnumeric string when it expects a number, <strong>scanf()</strong> returns the value 0. It returns <strong>EOF</strong> when it detects the condition known as “end of file.” </p><h1 id="8-The-Modifier-with-printf-and-scanf"><a href="#8-The-Modifier-with-printf-and-scanf" class="headerlink" title="8. The * Modifier with printf() and scanf()"></a>8. The * Modifier with printf() and scanf()</h1><h2 id="a-The-Modifier-with-printf"><a href="#a-The-Modifier-with-printf" class="headerlink" title="a. The * Modifier with printf()"></a>a. The * Modifier with printf()</h2><p>Suppose that you don’t want to commit yourself to a field width in advance but rather you want the program to specify it. You can do this by using <code>*</code> instead of a number for the field width, but you also have to add an argument to tell what the field width should be.<br>&nbsp;<br>That is, if you have the conversion specifier <code>%*d</code>, the argument list should include a value for <code>*</code> and a value for <code>d</code>. </p><h2 id="b-The-Modifier-with-scanf"><a href="#b-The-Modifier-with-scanf" class="headerlink" title="b. The * Modifier with scanf()"></a>b. The * Modifier with scanf()</h2><p>The <code>*</code> serves quite a different purpose for <strong>scanf()</strong>. When placed between the <code>%</code> and the specifier letter, it causes that function to <strong>skip over corresponding input</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data and C</title>
    <link href="/2020/11/24/Data-and-C/"/>
    <url>/2020/11/24/Data-and-C/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 3 Data and C</p><a id="more"></a><h1 id="1-Bits-Bytes-and-Words"><a href="#1-Bits-Bytes-and-Words" class="headerlink" title="1. Bits, Bytes, and Words"></a>1. Bits, Bytes, and Words</h1><h2 id="1-Bit"><a href="#1-Bit" class="headerlink" title="(1) Bit"></a>(1) Bit</h2><p>The smallest unit of memory is called a <strong>bit</strong>. It can hold one of two values: 0 or 1.</p><h2 id="2-Byte"><a href="#2-Byte" class="headerlink" title="(2) Byte"></a>(2) Byte</h2><p><strong>byte</strong> is the usual unit of computer memory. For nearly all machines, a byte is 8 bits, and that is the standard definition, at least when used to measure storage.<br>&nbsp;<br>Because each bit can be either 0 or 1, there are 256 (that’s 2 times itself 8 times) possible bit patterns of 0s and 1s that can fit in an 8-bit byte.</p><h2 id="3-Word"><a href="#3-Word" class="headerlink" title="(3) Word"></a>(3) Word</h2><p>A <strong>word</strong> is the natural unit of memory for a given computer design.<br>&nbsp;<br>For 8-bit microcomputers, such as the original Apples, a word is just 8 bits. Since then, personal computers moved up to 16-bit words, 32-bit words, and, at the present, 64-bit words. Larger word sizes enable faster transfer of data and allow more memory to be accessed.</p><h1 id="2-Integer-Versus-Floating-Point-Types"><a href="#2-Integer-Versus-Floating-Point-Types" class="headerlink" title="2. Integer Versus Floating-Point Types"></a>2. Integer Versus Floating-Point Types</h1><h2 id="1-The-Integer"><a href="#1-The-Integer" class="headerlink" title="(1) The Integer"></a>(1) The Integer</h2><p>An <strong>integer</strong> is a number with no fractional part.</p><h2 id="2-The-Floating-Point-Number"><a href="#2-The-Floating-Point-Number" class="headerlink" title="(2) The Floating-Point Number"></a>(2) The Floating-Point Number</h2><p>A <strong>floating-point</strong> number more or less corresponds to what mathematicians call a real number.<br>&nbsp;<br>The key point here is that the scheme used to store a floating-point number is different from the one used to store an integer. <strong>Floating-point representation involves breaking up a number into a fractional part and an exponent part and storing the parts separately</strong>.<br>&nbsp;<br>For some arithmetic operations, such as subtracting one large number from another, floating-point numbers are subject to greater <strong>loss of precision</strong>. Because there is an infinite number of real numbers in any range，For example, 7.0 might be stored as a 6.99999 float value.</p><h1 id="3-Basic-C-Data-Types"><a href="#3-Basic-C-Data-Types" class="headerlink" title="3. Basic C Data Types"></a>3. Basic C Data Types</h1><h2 id="1-The-int-Type"><a href="#1-The-int-Type" class="headerlink" title="(1) The int Type"></a>(1) The int Type</h2><p>The <strong>int</strong> type is a signed integer. That means it must be an integer and it can be positive, negative, or zero.</p><h3 id="Octal-and-Hexadecimal"><a href="#Octal-and-Hexadecimal" class="headerlink" title="Octal and Hexadecimal"></a>Octal and Hexadecimal</h3><p>A prefix of <strong>0x</strong> or <strong>0X</strong> (zero-ex) means that you are specifying a <strong>hexadecimal</strong> value, so 16 is written as 0x10, or 0X10.<br>&nbsp;<br>A <strong>0</strong> (zero) prefix means that you are writing in <strong>octal</strong>. For example, the decimal value 16 is written as 020 in <strong>octal</strong>.</p><h3 id="Other-Integer-Types"><a href="#Other-Integer-Types" class="headerlink" title="Other Integer Types"></a>Other Integer Types</h3><p>C offers three adjective keywords to modify the basic integer type: <strong>short</strong>, <strong>long</strong>, and <strong>unsigned</strong>.<br>&nbsp;<br>To cause a small constant to be treated as type long, you can append an <strong>l</strong> (lowercase <strong>L</strong>) or <strong>L</strong> as a <strong>suffix</strong>. </p><p>Add a <strong>u</strong> or <strong>U</strong> to the <strong>suffix</strong> for <strong>unsigned long long</strong>, as in <code>5ull</code> or <code>10LLU</code> .<br>&nbsp;<br>Note that the <strong>short</strong> variable end is displayed the same whether you tell <strong>printf()</strong> that end is a <strong>short</strong> (the <strong>%hd</strong> specifier) or an <strong>int</strong> (the <strong>%d</strong> specifier). </p><p><strong>That’s because C automatically expands a type short value to a type int value when it’s passed as an argument to a function</strong>.</p><p><strong>The int type is intended to be the integer size that the computer handles most efficiently</strong>.</p><h2 id="2-Using-Characters-Type-char"><a href="#2-Using-Characters-Type-char" class="headerlink" title="(2) Using Characters: Type char"></a>(2) Using Characters: Type char</h2><p>The <strong>char</strong> type is used for storing characters such as <strong>letters</strong> and <strong>punctuation marks</strong>, but technically it is an <strong>integer</strong> type.<br>&nbsp;<br>To handle characters, the computer uses a <strong>numerical code</strong> in which certain integers represent certain characters. </p><p>The most commonly used code in the U.S. is the <code>ASCII</code> code.<br>&nbsp;<br>The standard <code>ASCII</code> code runs numerically from 0 to 127. This range is small enough that 7 bits can hold it. The char type is typically defined as an 8-bit unit of memory.<br>&nbsp;<br><strong>Character Constants and Initialization</strong>：A single character contained between single quotes is a C character constant.<br>&nbsp;<br>Because characters are really stored as numeric values, you can also use the numerical code to assign values:</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> grade = <span class="hljs-number">65</span>; <span class="hljs-comment">/* ok for ASCII, but poor style */</span></code></pre><p>Because 65 is the <code>ASCII</code> code for the letter <code>A</code>, this example assigns the value <code>A</code> to grade.<br>&nbsp;<br>C treats character constants as type <code>int</code> rather than type <code>char</code>. For example, on an <code>ASCII</code> system with a 32-bit int and an 8-bit char, the code.</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> grade = <span class="hljs-string">'B'</span>;</code></pre><p><strong>represents ‘B’ as the numerical value 66 stored in a 32-bit unit, but grade winds up with 66 stored in an 8-bit unit.</strong> </p><p>This characteristic of character constants makes it possible to define a character constant such as <code>&#39;FATE&#39;</code>, with four separate 8-bit <code>ASCII</code> codes stored in a 32-bit unit.</p><p>However, attempting to assign such a character constant to a char variable results in only the <strong>last 8 bits</strong> being used, so the variable gets the value <code>&#39;E&#39;</code>.</p><p><strong>Nonprinting Characters</strong><br>The first way we have already mentioned—just use the <code>ASCII</code> code.<br>&nbsp;<br>The second way to represent certain awkward characters in C is to use special symbol sequences. These are called <strong>escape sequences</strong>. </p><table><thead><tr><th align="left">Sequence</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">\a</td><td align="left">Aleart(ANSI C)</td></tr><tr><td align="left">\b</td><td align="left">Backspace</td></tr><tr><td align="left">\f</td><td align="left">Form feed</td></tr><tr><td align="left">\n</td><td align="left">Newline</td></tr><tr><td align="left">\r</td><td align="left">Carrigae return</td></tr><tr><td align="left">\t</td><td align="left">Horizontal tab</td></tr><tr><td align="left">\v</td><td align="left">Vertical tab</td></tr><tr><td align="left">\</td><td align="left">Backslash()</td></tr><tr><td align="left">&#39;</td><td align="left">Single quote(‘)</td></tr><tr><td align="left">&quot;</td><td align="left">Double quote(“)</td></tr><tr><td align="left">?</td><td align="left">Question mark(?)</td></tr><tr><td align="left">\0oo</td><td align="left">Octal value (o represents an octal digit.)</td></tr><tr><td align="left">\0hh</td><td align="left">Hexadecimal value (h represents a hexadecimal digit.)</td></tr></tbody></table><p>To represent alert character (<code>\a</code>), you could use the <code>ASCII</code> code instead: <code>&#39;007&#39;</code>. You can omit the leading zeros, so <code>&#39;\07&#39;</code> or even <code>&#39;\7&#39;</code>will do. This notation causes numbers to be interpreted as octal, even if there is no initial 0.</p><p><strong>Note:</strong> When a character, be it an <strong>escape sequence or not</strong>, is part of a string of characters enclosed in double quotes, <strong>don’t enclose it in single quotes</strong>.</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello!\007\n"</span>);</code></pre><p>will print </p><pre><code class="hljs c">Hello! <span class="hljs-keyword">and</span> <span class="hljs-built_in">beep</span></code></pre><h2 id="3-The-Bool-Type"><a href="#3-The-Bool-Type" class="headerlink" title="(3) The _Bool Type"></a>(3) The _Bool Type</h2><p>C uses the value $1$ for <strong>true</strong> and $0$ for <strong>false</strong>, the <strong>_Bool</strong> type really is just an <strong>integer</strong> type, but one that, in principle, only requires 1 bit of memory, because that is enough to cover the full range from $0$ to $1$.</p><h2 id="4-Portable-Types-stdint-h-and-inttypes-h"><a href="#4-Portable-Types-stdint-h-and-inttypes-h" class="headerlink" title="(4) Portable Types: stdint.h and inttypes.h"></a>(4) Portable Types: stdint.h and inttypes.h</h2><p>The same type name doesn’t necessarily mean the same thing on different systems, What C has done is create more names for the existing types. The trick is to define these new names in a header file called <strong>stdint.h</strong>. </p><p>For example, <code>int32_t</code> represents the type for a <strong>32-bit signed integer</strong>. The header file on a system that uses a 32-bit int could define <code>int32_t</code> as an <strong>alias for int</strong>. A different system, one with a 16-bit int and a 32-bit long, could define the same name, <code>int32_t</code>, as an <strong>alias for int</strong>. </p><h2 id="5-Types-float-double-and-long-double"><a href="#5-Types-float-double-and-long-double" class="headerlink" title="(5) Types float, double, and long double"></a>(5) Types float, double, and long double</h2><p>Here are two <strong>valid floating-point constants</strong>:</p><pre><code class="hljs angelscript"><span class="hljs-number">-1.56E+12</span><span class="hljs-number">3.14159</span><span class="hljs-number">.2</span><span class="hljs-number">4e16</span><span class="hljs-number">.8E-5</span><span class="hljs-number">100.</span></code></pre><p><strong>Rules:</strong></p><ul><li>You can leave out positive signs. </li><li>You can do without a <strong>decimal point</strong> (2E5) or an <strong>exponential part</strong> (19.28), but <strong>not both simultaneously</strong>. </li><li>You can <strong>omit a fractional part</strong> (3.E16) or <strong>an integer<br>part</strong> (.45E–6), but <strong>not both</strong> (that wouldn’t leave much!). </li><li>Don’t use spaces in a floating-point constant.</li></ul><p>By default, the compiler assumes <strong>floating-point constants</strong> are <strong>double</strong> precision.</p><p>C enables you to <strong>override</strong> this default by using an <strong>f</strong> or <strong>F</strong> <strong>suffix</strong> to make the compiler treat a <strong>floating-point</strong> constant as type <strong>float</strong>; examples are <code>2.3f</code> and <code>9.11E9F</code>. </p><p>An <strong>l</strong> or <strong>L</strong> <strong>suffix</strong> makes a number type <strong>long double</strong>; examples are <code>54.3l</code> and <code>4.32e4L</code>. </p><p>If the floating-point number has <strong>no suffix</strong>, it is type <strong>double</strong>.</p><h1 id="4-Format-Specifier"><a href="#4-Format-Specifier" class="headerlink" title="4. Format Specifier"></a>4. Format Specifier</h1><p>It indicates the form that <strong>printf()</strong> uses to display a value.</p><h2 id="1-d"><a href="#1-d" class="headerlink" title="(1) %d"></a>(1) %d</h2><p><strong>%d</strong> notation is used to indicate just where in a line the <strong>integer</strong> is to be printed.  <strong>d means decimal</strong><br>&nbsp;<br>Each <strong>%d</strong> in the format string must be matched by a corresponding <strong>int</strong> value in the list of items to be printed. </p><h2 id="2-Printing-short-long-long-long-and-unsigned-Types"><a href="#2-Printing-short-long-long-long-and-unsigned-Types" class="headerlink" title="(2) Printing short, long, long long, and unsigned Types"></a>(2) Printing short, long, long long, and unsigned Types</h2><p>To print an <strong>unsigned int</strong> number, use the <strong>%u</strong> notation. To print a <strong>long</strong> value, use the <strong>%ld</strong> format specifier.<br>&nbsp;<br>Note that although C allows both <strong>uppercase</strong> and <strong>lowercase</strong> letters for <strong>constant suffixes</strong>, these format specifiers use just <strong>lowercase</strong>.<br>&nbsp;<br>C has several additional <strong>printf()</strong> formats. First, you can use an <strong>h</strong> <strong>prefix</strong> for <strong>short</strong> types. Therefore, <strong>%hd</strong> displays a <strong>short integer</strong> in <strong>decimal</strong> form, and <strong>%ho</strong> displays a <strong>short integer in octal form</strong>. Both the <strong>h</strong> and <strong>l</strong> <strong>prefixes</strong> can be used with <strong>u</strong> for <strong>unsigned</strong> types. </p><h2 id="3-c"><a href="#3-c" class="headerlink" title="(3) %c"></a>(3) %c</h2><p>The <strong>printf()</strong> function uses <strong>%c</strong> to indicate that a <strong>character</strong> should be printed. </p><h2 id="4-Printing-Floating-Point-Values"><a href="#4-Printing-Floating-Point-Values" class="headerlink" title="(4) Printing Floating-Point Values"></a>(4) Printing Floating-Point Values</h2><p>The <strong>printf()</strong> function uses the <strong>%f</strong> format specifier to print type <strong>float</strong> and <strong>double</strong> numbers using <strong>decimal</strong> notation, and it uses <strong>%e</strong> to print them in <strong>exponential</strong> notation. </p><table><thead><tr><th align="left">Format</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">%f</td><td align="left"><strong>decimal</strong> notation(float, double)</td></tr><tr><td align="left">%e</td><td align="left"><strong>exponential</strong> notation(float, double)</td></tr><tr><td align="left">%a, %A</td><td align="left"><strong>hexadecimal p</strong> notation(float,double)</td></tr><tr><td align="left">%Lf, %Le, %La</td><td align="left"><strong>decimal</strong>, <strong>exponential</strong>, <strong>hexadecimal p</strong> notation(long double)</td></tr></tbody></table><h1 id="5-Type-Sizes"><a href="#5-Type-Sizes" class="headerlink" title="5. Type Sizes"></a>5. Type Sizes</h1><p>What type sizes does your system use?</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type int has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type char has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type long has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>));&#125;<span class="hljs-comment">//C has a built-in operator called sizeof that gives sizes in bytes. C99 and C11 provide a %zd specifier for this type used by sizeof.</span></code></pre><p>answer</p><pre><code class="hljs routeros">Type int has a size of 4 bytes.Type char has a size of 1 bytes.Type long has a size of 8 bytes.</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
