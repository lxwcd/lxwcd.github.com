<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Character Strings and String Functions</title>
    <link href="/2020/12/01/Character-Strings-and-String-Functions/"/>
    <url>/2020/12/01/Character-Strings-and-String-Functions/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 11 Character Strings and String Functions</p><a id="more"></a><h1 id="1-Representing-Strings-and-String-I-O"><a href="#1-Representing-Strings-and-String-I-O" class="headerlink" title="1. Representing Strings and String I/O"></a>1. Representing Strings and String I/O</h1><p>The <strong>puts()</strong> function, like <strong>printf()</strong>, belongs to the the <strong>stdio.h</strong> family of <strong>input/output</strong> functions. It only displays <strong>strings</strong>, and, unlike <strong>printf()</strong>, it automatically <strong>appends a newline</strong> to the string it displays. </p><p>There are many ways to define a string. The principal ways are using string constants, using char arrays, and using char pointers. </p><p>A program should make sure there is a place to store a string.</p><h2 id="1-Character-String-Literals-String-Constants"><a href="#1-Character-String-Literals-String-Constants" class="headerlink" title="(1) Character String Literals (String Constants)"></a>(1) Character String Literals (String Constants)</h2><p>A <strong>string literal</strong>, also termed a <strong>string constant</strong>, is anything enclosed in <strong>double quotation marks</strong>. The enclosed characters, plus a terminating <code>\0</code> character automatically provided by the compiler, are stored in memory as a character string. </p><p><strong>Character string constants</strong> are placed in the <strong>static storage class</strong>, which means that if you use a <strong>string constant</strong> in a function, the string is <strong>stored just once</strong> and <strong>lasts for the duration of the program</strong>, even if the function is called several times. </p><h2 id="2-Character-String-Arrays-and-Initialization"><a href="#2-Character-String-Arrays-and-Initialization" class="headerlink" title="(2) Character String Arrays and Initialization"></a>(2) Character String Arrays and Initialization</h2><p>When you define a <strong>character string array</strong>, you must let the compiler know <strong>how much space</strong> is needed. </p><h1 id="2-Array-Versus-Pointer"><a href="#2-Array-Versus-Pointer" class="headerlink" title="2. Array Versus Pointer"></a>2. Array Versus Pointer</h1><p>In short, initializing the <strong>array</strong> copies a <strong>string</strong> from <strong>static storage</strong> to the <strong>array</strong>, whereas initializing the <strong>pointer</strong> merely copies the <strong>address</strong> of the <strong>string</strong>.</p><h2 id="1-Array-and-Pointer-Differences"><a href="#1-Array-and-Pointer-Differences" class="headerlink" title="(1) Array and Pointer Differences"></a>(1) Array and Pointer Differences</h2><p>The chief <strong>difference</strong> is that the <strong>array name</strong> is a <strong>constant</strong>, but the <strong>pointer</strong> is a variable. </p><p>In short, don’t use a <strong>pointer to a string literal</strong> if you plan to alter the string.</p><h2 id="2-Arrays-of-Character-Strings"><a href="#2-Arrays-of-Character-Strings" class="headerlink" title="(2) Arrays of Character Strings"></a>(2) Arrays of Character Strings</h2><p><img src="https://img-blog.csdnimg.cn/20190615215441173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="3-String-Input"><a href="#3-String-Input" class="headerlink" title="3. String Input"></a>3. String Input</h1><p>If you want to read a <strong>string</strong> into a program, you must first <strong>set aside space</strong> to store the <strong>string</strong> and then use an <strong>input function</strong> to fetch the string.</p><h2 id="1-Creating-Space"><a href="#1-Creating-Space" class="headerlink" title="(1) Creating Space"></a>(1) Creating Space</h2><p>The first order of business is setting up a place to put the string after it is read. </p><h2 id="2-The-Unfortunate-gets-Function"><a href="#2-The-Unfortunate-gets-Function" class="headerlink" title="(2) The Unfortunate gets() Function"></a>(2) The Unfortunate gets() Function</h2><p> It reads an entire <strong>line up</strong> through the <strong>newline character</strong>, <strong>discards</strong> the <strong>newline character</strong>, stores the remaining characters, <strong>adding a null character</strong> to create a C <strong>string</strong>. </p><p>It’s often paired with <strong>puts()</strong>, which displays a <strong>string</strong>, <strong>adding a newline</strong>. </p><p>The problem is that <strong>gets()</strong> doesn’t check to see if the input line actually fits into the array. </p><h2 id="3-The-fgets-Function"><a href="#3-The-fgets-Function" class="headerlink" title="(3) The fgets() Function"></a>(3) The fgets() Function</h2><p>The <strong>fgets()</strong> function meets the possible <strong>overflow</strong> problem by taking a second argument that <strong>limits the number of characters</strong> to be read. </p><p>This function is designed for <strong>file input</strong>, which makes it a little more awkward to use. Here is how <strong>fgets()</strong> differs from <strong>gets()</strong>:</p><ul><li><p>It takes a <strong>second argument</strong> indicating the <strong>maximum number of characters to read</strong>. If this argument has the value <strong>n</strong>, <strong>fgets()</strong> reads up to <strong>n-1</strong> characters or through the <strong>newline character</strong>, whichever comes first.</p></li><li><p>If <strong>fgets()</strong> reads the <strong>newline</strong>, it <strong>stores it in the string</strong>, unlike <strong>gets()</strong>, which discards it.</p></li><li><p>It takes a <strong>third argument</strong> indicating <strong>which file to read</strong>. To read from the <strong>keyboard</strong>, use <strong>stdin</strong> (for standard input) as the argument; this identifier is defined in <code>stdio.h</code>.</p><h3 id="Null-and-NULL"><a href="#Null-and-NULL" class="headerlink" title="Null and NULL"></a>Null and NULL</h3><p>The <strong>null character</strong>, or <strong>‘\0’</strong>, is the character used to mark the end of a <strong>C string</strong>. It’s the character whose code is <strong>zero</strong>. Because that isn’t the code of any character, it won’t show up accidentally in some other part of the string.</p></li></ul><p>The <strong>null pointer</strong>, or <strong>NULL</strong>, <strong>has a value</strong> that doesn’t correspond to a <strong>valid address</strong> of data. It’s often used by functions that otherwise return valid addresses to indicate some special occurrence, such as encountering <strong>end-of-file</strong> or failing to perform as expected.</p><p>So the <strong>null character</strong> is an <strong>integer type</strong>, while the <strong>null pointer</strong> is a <strong>pointer type</strong>. </p><h2 id="4-The-s-gets-Function"><a href="#4-The-s-gets-Function" class="headerlink" title="(4) The s _ gets() Function"></a>(4) The s _ gets() Function</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* st, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> * ret_val;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    ret_val = fgets(st, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span> (ret_val) <span class="hljs-comment">// i.e., ret_val != NULL</span>    &#123;        <span class="hljs-keyword">while</span> (st[i] != <span class="hljs-string">'\n'</span> &amp;&amp; st[i] != <span class="hljs-string">'\0'</span>)            i++;        <span class="hljs-keyword">if</span> (st[i] == <span class="hljs-string">'\n'</span>)            st[i] = <span class="hljs-string">'\0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">// must have words[i] == '\0'</span>            <span class="hljs-keyword">while</span> (getchar() != <span class="hljs-string">'\n'</span>)                <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret_val;&#125;</code></pre><h1 id="4-String-Output"><a href="#4-String-Output" class="headerlink" title="4. String Output"></a>4. String Output</h1><h2 id="1-The-puts-Function"><a href="#1-The-puts-Function" class="headerlink" title="(1) The puts() Function"></a>(1) The puts() Function</h2><p>The <strong>puts()</strong> function is very easy to use. Just give it the <strong>address of a string</strong> for an argument.</p><p><strong>puts()</strong> automatically <strong>appends a newline</strong> when it displays a string.</p><h2 id="2-The-fputs-Function"><a href="#2-The-fputs-Function" class="headerlink" title="(2) The fputs() Function"></a>(2) The fputs() Function</h2><p>The <strong>fputs()</strong> function is the <strong>file-oriented</strong> version of <strong>puts()</strong>. The main differences are these:</p><ul><li><p>The <strong>fputs()</strong> function takes a <strong>second argument</strong> indicating the <strong>file</strong> to which to <strong>write</strong>. You can use <strong>stdout</strong> (for standard output), which is defined in <code>stdio.h</code>, as an argument to output to your display.</p></li><li><p>Unlike <strong>puts()</strong>, <strong>fputs()</strong> does not automatically append a <strong>newline</strong> to the output.</p></li></ul><p>Note that <strong>gets()</strong> discards a <strong>newline</strong> on input, but <strong>puts()</strong> adds a <strong>newline</strong> on output. On the other hand, <strong>fgets()</strong> stores the <strong>newline</strong> on input, and <strong>fputs()</strong> doesn’t add a <strong>newline</strong> on output. </p><p><strong>gets()</strong> returns the <strong>null pointer</strong> if it encounters <strong>end-of-file</strong>. The <strong>null pointer *<em>evaluates as *</em>zero</strong>, or <strong>false</strong>, so that terminates the loop.</p><h1 id="5-String-Functions"><a href="#5-String-Functions" class="headerlink" title="5. String Functions"></a>5. String Functions</h1><h2 id="1-The-strlen-Function"><a href="#1-The-strlen-Function" class="headerlink" title="(1) The strlen() Function"></a>(1) The strlen() Function</h2><p>The <strong>strlen()</strong> function, finds the <strong>length</strong> of a string. </p><h2 id="2-The-strcat-Function"><a href="#2-The-strcat-Function" class="headerlink" title="(2) The strcat() Function"></a>(2) The strcat() Function</h2><p>The <strong>strcat()</strong> (for string concatenation) function takes <strong>two strings for arguments</strong>. A copy of the second string is tacked onto the end of the first, and this combined version becomes the new first string. </p><p>The second string is <strong>not altered</strong>. The <strong>strcat()</strong> function is type <code>char *</code> (that is, a pointer-to-char).</p><p>It <strong>returns</strong> the value of its <strong>first argument</strong>—the <strong>address</strong> of the first character of the string to which the second string is appended.</p><h2 id="3-The-strncat-Function"><a href="#3-The-strncat-Function" class="headerlink" title="(3) The strncat() Function"></a>(3) The strncat() Function</h2><p>Alternatively, you can use <strong>strncat()</strong>, which takes a second argument indicating the <strong>maximum number of characters</strong> to add. For example, <code>strncat(bugs, addon, 13)</code> will add the contents of the <code>addon</code> string to bugs, stopping when it reaches <code>13</code> additional characters or the <strong>null character</strong>, whichever comes first. </p><h2 id="4-The-strcmp-Function"><a href="#4-The-strcmp-Function" class="headerlink" title="(4) The strcmp() Function"></a>(4) The strcmp() Function</h2><p>These results suggest that <strong>strcmp()</strong> returns a <strong>negative number</strong> if the <strong>first string precedes the second</strong> alphabetically and that it <strong>returns a positive number</strong> if the order is the other way.  It returns <strong>0</strong> if they are the <strong>same</strong>.</p><p>The <strong>strcmp()</strong> function is for <strong>comparing strings</strong>, not <strong>characters</strong>.</p><h2 id="5-The-strncmp-Variation"><a href="#5-The-strncmp-Variation" class="headerlink" title="(5) The strncmp() Variation"></a>(5) The strncmp() Variation</h2><p>The <strong>strncmp()</strong> function compares the strings until they differ or until it has compared a number of characters specified by a third argument.</p><h2 id="6-The-sprintf-Function"><a href="#6-The-sprintf-Function" class="headerlink" title="(6) The sprintf() Function"></a>(6) The sprintf() Function</h2><p>The <strong>sprintf()</strong> function is declared in <code>stdio.h</code> instead of <code>string.h</code>. It works like <strong>printf()</strong>, but it <strong>writes</strong> to a string instead of writing to a display. </p><h2 id="7-Other-String-Functions"><a href="#7-Other-String-Functions" class="headerlink" title="(7) Other String Functions"></a>(7) Other String Functions</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2)</span></span>;</code></pre><p>This function <strong>copies *<em>the string (including the *</em>null character</strong>) pointed to by <code>s2</code> to the location pointed to by <code>s1</code>. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strncpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>This function <strong>copies</strong> to the location pointed to by <code>s1</code> no more than <code>n</code> characters from the string pointed to by <code>s2</code>. The return value is <code>s1</code>. No characters after a <strong>null character</strong> are copied and, if the source string is shorter than <code>n</code> characters, the <strong>target string</strong> is padded with <strong>null characters</strong>. If the source string has <code>n</code> or more characters, <strong>no null character is copied</strong>. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2)</span></span>;</code></pre><p>The string pointed to by <code>s2</code> is copied to the <strong>end of the string</strong> pointed to by <code>s1</code>. The first character of the <code>s2</code> string is copied <strong>over the null character</strong> of the <code>s1</code> string. The <strong>return value</strong> is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strncat</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">restrict</span> s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>No more than the first <code>n</code> characters of the <code>s2</code> string are appended to the <code>s1</code> string, with the first character of the <code>s2</code> string being copied <strong>over the null character</strong> of the <code>s1</code> string. The <strong>null character</strong> and any characters following it in the <code>s2</code> string are <strong>not copied</strong>, and a <strong>null character</strong> is appended to the result. The return value is <code>s1</code>.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>positive value</strong> if the <code>s1</code> string follows the <code>s2</code> string in the machine collating sequence, the value <strong>0</strong> if the two strings are <strong>identical</strong>, and a <strong>negative</strong> value if the <strong>first string</strong> precedes the <strong>second string</strong> in the machine collating sequence.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strncmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2, <span class="hljs-keyword">size_t</span> n)</span></span>;</code></pre><p>This function works like <strong>strcmp()</strong>, except that the comparison stops after <code>n</code> characters or when the first <strong>null character</strong> is encountered, whichever comes first.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s, <span class="hljs-keyword">int</span> c)</span></span>;</code></pre><p>This function <strong>returns a pointer to the first location</strong> in the string <code>s</code> that holds the character <code>c</code>. (The terminating <strong>null character</strong> is part of the string, so it can be searched for.) The function returns the <strong>null pointer</strong> if the character is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strpbrk</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>pointer to the first location</strong> in the string <code>s1</code> that holds <strong>any character</strong> found in the <code>s2</code> string. The function returns the <strong>null pointer</strong> if no character is found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strrchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s, <span class="hljs-keyword">int</span> c)</span></span>;</code></pre><p>This function returns a <strong>pointer to the last occurrence of the character</strong> <code>c</code> in the strings. (The terminating <strong>null character</strong> is part of the string, so it can be searched for.) The function returns the <strong>null pointer</strong> if the character is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s2)</span></span>;</code></pre><p>This function returns a <strong>pointer to the first occurrence</strong> of string <code>s2</code> in string <code>s1</code>. The function returns the <strong>null pointer</strong> if the string is not found.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s)</span></span>;</code></pre><p>This function returns the <strong>number of characters</strong>, not including the terminating <strong>null character</strong>, found in the <strong>strings</strong>.</p><h1 id="6-Command-Line-Arguments"><a href="#6-Command-Line-Arguments" class="headerlink" title="6. Command-Line Arguments"></a>6. Command-Line Arguments</h1><p><img src="_v_images/20201201201425398_503175558.png" srcset="/img/loading.gif" alt=""><br>A C program reads these items by using arguments to <strong>main()</strong>.</p><pre><code class="hljs c"><span class="hljs-comment">/* 11.31 repeat.c -- main() with arguments */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> count;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"The command line has %d arguments:\n"</span>, argc - <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (count = <span class="hljs-number">1</span>; count &lt; argc; count++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: %s\n"</span>, count, argv[count]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs bash">$ repeat Resistance is futile</code></pre><p>repeat is the name of the program.</p><pre><code class="hljs vim"><span class="hljs-built_in">argv</span>[<span class="hljs-number">0</span>] points <span class="hljs-keyword">to</span> <span class="hljs-built_in">repeat</span> (<span class="hljs-keyword">for</span> most systems)<span class="hljs-built_in">argv</span>[<span class="hljs-number">1</span>] points <span class="hljs-keyword">to</span> Resistance<span class="hljs-built_in">argv</span>[<span class="hljs-number">2</span>] points <span class="hljs-keyword">to</span> <span class="hljs-keyword">is</span><span class="hljs-built_in">argv</span>[<span class="hljs-number">3</span>] points <span class="hljs-keyword">to</span> futile</code></pre><p>output:</p><pre><code class="hljs c">The command <span class="hljs-built_in">line</span> has <span class="hljs-number">3</span> arguments:<span class="hljs-number">1</span>: Resistance<span class="hljs-number">2</span>: is<span class="hljs-number">3</span>: futile</code></pre><p>C compilers allow <strong>main()</strong> to have <strong>no arguments</strong> or else to have <strong>two arguments</strong>. (Some implementations allow additional arguments, but that would be an extension of the standard.) </p><p>With two arguments, the <strong>first argument</strong> is the number of strings in the command line. </p><p>The system uses <strong>spaces</strong> to tell when one string ends and the next begins. Therefore, the repeat example has <strong>four strings</strong>, including the command <strong>name</strong>. </p><p>The program stores the command line strings in memory and stores the <strong>address of each string</strong> in an <strong>array of pointers</strong>. </p><p>The address of this array is stored in the <strong>second argument</strong>.</p><h1 id="7-String-to-Number-Conversions"><a href="#7-String-to-Number-Conversions" class="headerlink" title="7. String-to-Number Conversions"></a>7. String-to-Number Conversions</h1><h2 id="1-atoi"><a href="#1-atoi" class="headerlink" title="(1) atoi( )"></a>(1) atoi( )</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*str)</span></span>;</code></pre><p>It takes a <strong>string</strong> str as  an argument and returns the corresponding <strong>integer value</strong>.  The <code>stdlib.h</code> header contains the function declaration<br>for <strong>atoi()</strong>.</p><p>该函数会扫描字符串，跳过空白字符，直到遇到数字或者正负符号才开始转换，一直到遇到非数字或者字符串结束符 <strong>‘\0’</strong> 结束扫描，如果一开始扫描到是非数字，则结束扫描，未扫描到数字返回数字 <strong>0</strong>，否则返回转换后的数字，能识别<strong>正负号</strong>。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> i,j;  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)  &#123;    j = atoi(argv[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %-10scorresponding integer: %d\n"</span>,argv[i], j);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>output:</p><pre><code class="hljs c">./atoi1.o jds323sd <span class="hljs-number">898</span>dsj23 js<span class="hljs-number">-98</span>dk +<span class="hljs-number">23</span>sd33 <span class="hljs-number">-92</span>d89s i<span class="hljs-number">-988</span>sj<span class="hljs-built_in">string</span>: jds323sd  corresponding integer: <span class="hljs-number">0</span><span class="hljs-built_in">string</span>: <span class="hljs-number">898</span>dsj23  corresponding integer: <span class="hljs-number">898</span><span class="hljs-built_in">string</span>: js<span class="hljs-number">-98</span>dk   corresponding integer: <span class="hljs-number">0</span><span class="hljs-built_in">string</span>: +<span class="hljs-number">23</span>sd33   corresponding integer: <span class="hljs-number">23</span><span class="hljs-built_in">string</span>: <span class="hljs-number">-92</span>d89s   corresponding integer: <span class="hljs-number">-92</span><span class="hljs-built_in">string</span>: i<span class="hljs-number">-988</span>sj   corresponding integer: <span class="hljs-number">0</span></code></pre><p>Implementation of <strong>atoi()</strong>:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *st)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sign, ret;    ret = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(*st))        st++;    sign = (*st == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(*st == <span class="hljs-string">'+'</span> || *st == <span class="hljs-string">'-'</span>)        st++;    <span class="hljs-keyword">for</span>( ; *st; st++)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*st))            ret = *st - <span class="hljs-string">'0'</span> + ret * <span class="hljs-number">10</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">return</span> sign * ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)    &#123;        n = atoi(argv[i]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %10sint: %d;\n"</span>, argv[i], n);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>output:</p><pre><code class="hljs c">./atoi.o sdj87<span class="hljs-number">-08</span> <span class="hljs-number">98</span>sjd09 <span class="hljs-number">-98</span>sd88 <span class="hljs-number">-09</span>sdj88<span class="hljs-built_in">string</span>:   sdj87<span class="hljs-number">-08</span><span class="hljs-keyword">int</span>: <span class="hljs-number">0</span>;<span class="hljs-built_in">string</span>:    <span class="hljs-number">98</span>sjd09<span class="hljs-keyword">int</span>: <span class="hljs-number">98</span>;<span class="hljs-built_in">string</span>:    <span class="hljs-number">-98</span>sd88<span class="hljs-keyword">int</span>: <span class="hljs-number">-98</span>;<span class="hljs-built_in">string</span>:   <span class="hljs-number">-09</span>sdj88<span class="hljs-keyword">int</span>: <span class="hljs-number">-9</span>;```                                                                                                                                                                                ## (<span class="hljs-number">2</span>) atof() ```c<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">atof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;</code></pre><p>该函数将参数 <strong>str</strong> 所指向的字符串转换为一个<strong>double</strong> 型浮点数。</p><p>浮点数合法表示:</p><pre><code class="hljs angelscript"><span class="hljs-number">3.123</span><span class="hljs-number">.2</span><span class="hljs-number">-.32</span><span class="hljs-number">2e-2</span><span class="hljs-number">2.E-2</span><span class="hljs-number">.3e-2</span></code></pre><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *ret, *<span class="hljs-built_in">find</span>;    ret = fgets(s, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span>(ret)    &#123;        <span class="hljs-built_in">find</span> = <span class="hljs-built_in">strchr</span>(s, <span class="hljs-string">'\n'</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>)        &#123;          *<span class="hljs-built_in">find</span> = <span class="hljs-string">'\0'</span>;        &#125;        <span class="hljs-keyword">else</span>        <span class="hljs-keyword">while</span>(getchar() != <span class="hljs-string">'\n'</span>)            <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> n;    <span class="hljs-keyword">char</span> s[<span class="hljs-number">10</span>];    <span class="hljs-keyword">while</span>(s_gets(s, <span class="hljs-number">10</span>) &amp;&amp; s[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span>)    &#123;        n = atof(s);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %s, float: %f\n"</span>, s, n); <span class="hljs-comment">//printf()输出双精度也是%f,输出形式为小数点形式</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Answer:</p><pre><code class="hljs c"><span class="hljs-number">.023e-3</span><span class="hljs-number">.2</span>sj<span class="hljs-built_in">string</span>: <span class="hljs-number">.023e-3</span><span class="hljs-number">.2</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000023</span><span class="hljs-number">-.32</span><span class="hljs-number">.3e2</span><span class="hljs-built_in">string</span>: <span class="hljs-number">-.32</span><span class="hljs-number">.3e2</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">-0.320000</span>sj3<span class="hljs-built_in">string</span>: sj3, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span>.e3<span class="hljs-built_in">string</span>: .e3, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span><span class="hljs-number">0.e3</span><span class="hljs-built_in">string</span>: <span class="hljs-number">0.e3</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000000</span><span class="hljs-number">2.e-3</span><span class="hljs-number">.32</span><span class="hljs-built_in">string</span>: <span class="hljs-number">2.e-3</span><span class="hljs-number">.32</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.002000</span><span class="hljs-number">.22e-3</span><span class="hljs-built_in">string</span>: <span class="hljs-number">.22e-3</span>, <span class="hljs-keyword">float</span>: <span class="hljs-number">0.000220</span></code></pre><p>Implementation of <strong>atof()</strong>:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEN 10</span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myatof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> s[LEN];    <span class="hljs-keyword">double</span> num;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Enter strings, enter a newline to quit:"</span>);    <span class="hljs-keyword">while</span>(s_gets(s,LEN) &amp;&amp; s[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span>)    &#123;        num = myatof(s);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string: %s, corresponding number: %f;\n"</span>, s,num);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">s_gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *ret, *<span class="hljs-built_in">find</span>;    ret = fgets(s, n, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span>(ret)    &#123;        <span class="hljs-built_in">find</span> = <span class="hljs-built_in">strchr</span>(s,<span class="hljs-string">'\n'</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>)            *<span class="hljs-built_in">find</span> = <span class="hljs-string">'\0'</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">while</span>(getchar() != <span class="hljs-string">'\n'</span>)                <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myatof</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sign, sign_e;    <span class="hljs-keyword">int</span> hasdot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> hasE = <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span> intpart = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">double</span> decpart = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">int</span> decdigit = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">0</span>;    <span class="hljs-keyword">double</span> ret;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(*str))<span class="hljs-comment">//跳过开始的空格</span>        str++;      <span class="hljs-comment">//判断符号</span>    sign = (*str == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;    <span class="hljs-comment">//跳过符号位</span>    <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'-'</span> || *str == <span class="hljs-string">'+'</span>)        str++;    <span class="hljs-keyword">for</span>(;*str;str++)     &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*str)) <span class="hljs-comment">//计算整数部分</span>            intpart = <span class="hljs-number">10</span> * intpart + *str - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'.'</span>) <span class="hljs-comment">//小数点</span>        &#123;          hasdot = <span class="hljs-number">1</span>;          str++;          <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'e'</span> || *str == <span class="hljs-string">'E'</span>)<span class="hljs-comment">//科学计数法</span>        &#123;            hasE = <span class="hljs-number">1</span>;            str++;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//不合要求字符，退出</span>            <span class="hljs-keyword">return</span> sign * intpart;    &#125;    <span class="hljs-comment">//退出后的情况：1.一直输入的是数字直到遇到字符串结束符; 343</span>    <span class="hljs-comment">//2. 识别到小数点; 3.3</span>    <span class="hljs-comment">//3. 识别到科学计数法 e 或 E，虽然 e2这种形式是错的，但最终计算出结果还是0; </span>    <span class="hljs-comment">//4. 扫描到非法字符，结束函数，后面不会执行</span>    <span class="hljs-keyword">for</span>( ; *str; str++)    &#123;        <span class="hljs-keyword">if</span>(hasdot &amp;&amp; <span class="hljs-built_in">isdigit</span>(*str)) <span class="hljs-comment">//两种表达：2.3 .3; </span>        <span class="hljs-comment">//2.34小数部分计算：3 / 10  + 4 / (10 *10)</span>        <span class="hljs-comment">//pow() 函数位于math.h头文件中，计算幂，pow(10,2) == 10 * 10，但编译时要加lm</span>            decpart += (*str - <span class="hljs-string">'0'</span>) / <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span> , decdigit++);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasdot &amp;&amp; (*str == <span class="hljs-string">'e'</span> || *str ==<span class="hljs-string">'E'</span>))        <span class="hljs-comment">//情况：2.3e，.3e，.e;最后一种 .e 不合法，但最终计算结果还是为0</span>        &#123;          hasE = <span class="hljs-number">1</span>;          str++;          <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hasE) <span class="hljs-comment">//用科学计数法，但是前面没有小数点，情况：3e3 e3 3e- 3e+ 3e. 3ek </span>            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//遇到不合要求字符 3k 3.k 3.3k .k; 不存在有科学计数法 e 或 E情况 </span>            <span class="hljs-keyword">return</span> sign * (intpart + decpart);    &#125;    <span class="hljs-comment">//退出有一下情况：</span>    <span class="hljs-comment">// 1. 扫描数字直到结束 1.23</span>    <span class="hljs-comment">// 2. 科学计数法，前面数字部分有小数点 或者没有</span>    <span class="hljs-comment">// 3. 扫描不合法字符退出函数</span>    sign_e = (*str == <span class="hljs-string">'-'</span>)? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>; <span class="hljs-comment">//指数部分符号</span>    <span class="hljs-keyword">if</span>(*str == <span class="hljs-string">'+'</span> || *str == <span class="hljs-string">'-'</span>)        str++;    <span class="hljs-keyword">for</span>( ; *str; str++)<span class="hljs-comment">//识别指数部分</span>    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(*str))            <span class="hljs-built_in">exp</span> = <span class="hljs-built_in">exp</span> * <span class="hljs-number">10</span> + *str - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//非法字符</span>            <span class="hljs-keyword">break</span>;    &#125;    ret = sign * ( (intpart + decpart) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span> , sign_e * <span class="hljs-built_in">exp</span>) );    <span class="hljs-keyword">return</span> ret;&#125;</code></pre><h2 id="3-atol"><a href="#3-atol" class="headerlink" title="(3)  atol()"></a>(3)  atol()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">atol</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span></span>;</code></pre><p>该函数将参数 <strong>str</strong> 所指向的字符串转换为<strong>long int</strong>。</p><h2 id="4-strtol"><a href="#4-strtol" class="headerlink" title="(4) strtol()"></a>(4) strtol()</h2><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strtol</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr, <span class="hljs-keyword">int</span> <span class="hljs-keyword">base</span></span>)</span>;</code></pre><p><strong>string to long int</strong>，该函数把参数 <strong>str</strong> 所指向的字符串根据给定的 <strong>base</strong> 转换为<strong>long int</strong>，<strong>base</strong> 必须介于 <strong>2</strong> 和 <strong>36</strong>（包含）之间，或者是特殊值 <strong>0</strong>。<br>&nbsp;<br>参数说明:<br><strong>str</strong>: 要转换的字符串，起始扫描时会跳过开头的空白字符，直到遇到数字或者正负符号开始做转换，知道遇到不合条件字符或者字符串结束字符才结束。<br>&nbsp;<br><strong>endptr</strong>: 指向指针的指针，<strong>*endptr</strong> 为指向第一个非法字符。<br>&nbsp;<br><strong>base</strong>: 基数。代表将 <strong>str</strong> 进行转换采用的进制。范围为 <strong>2~36</strong>，或者 <strong>0</strong>；<br>如 <strong>base</strong> 是 <strong>0</strong>，默认采用 <strong>10</strong> 进制，但如果遇到 <strong>‘0x’</strong> 或者 <strong>‘0X’</strong> 前置的字符，采用 <strong>16</strong> 进制，遇到 <strong>‘0’</strong> 前置非第一种情况，则用 <strong>8</strong> 进制。<br>&nbsp;<br><strong>返回值</strong>: 函数返回转换后的长整型数字，若无有效数字，返回 <strong>0</strong>。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> *end1, *end2;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> n1, n2;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)    &#123;         n1 = strtol(argv[i], &amp;end1, <span class="hljs-number">10</span>);        n2 = strtol(argv[i], &amp;end2, <span class="hljs-number">16</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string%d: %15s, base 10 input, base 10 output: %ld, stopped at %s"</span>        <span class="hljs-string">" (%d);\n"</span>,i, argv[i], n1, end1, *end1);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string%d: %15s, base 16 input, base 10 output: %ld, stopped at %s"</span>         <span class="hljs-string">" (%d);\n"</span>,i, argv[i], n2, end2, *end2);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bye!\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="5-strtod"><a href="#5-strtod" class="headerlink" title="(5) strtod()"></a>(5) strtod()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">strtod</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr)</span></span>;</code></pre><p><strong>string to double</strong>，将参数 <strong>str</strong> 所指向的字符串转换为<strong>double</strong>型浮点数。</p><p>该函数返回转换后的双精度浮点数，如果没有执行有效的转换，则返回零（<strong>0.0</strong>）。</p><h2 id="6-strtoul"><a href="#6-strtoul" class="headerlink" title="(6) strtoul()"></a>(6) strtoul()</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strtoul</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> **endptr, <span class="hljs-keyword">int</span> base)</span></span>;</code></pre><p><strong>string to unsigned long int</strong>，参数<strong>str</strong>所指向的字符串根据给定的<strong>base</strong>转换为<strong>unsigned long int</strong> 型，<strong>base</strong>必须介于 <strong>2</strong> 和 <strong>36</strong>（包含）之间，或者是特殊值<strong>0</strong>。</p><p>该函数返回转换后的长整数，如果没有执行有效的转换，则返回 <strong>0</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arrays and Pointers</title>
    <link href="/2020/11/30/Arrays-and-Pointers/"/>
    <url>/2020/11/30/Arrays-and-Pointers/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 10 Arrays and Pointers</p><a id="more"></a><h1 id="1-Arrays"><a href="#1-Arrays" class="headerlink" title="1. Arrays"></a>1. Arrays</h1><p>An array is composed of a series of elements of <strong>one data type</strong>.</p><h2 id="1-Initialization"><a href="#1-Initialization" class="headerlink" title="(1) Initialization"></a>(1) Initialization</h2><pre><code class="hljs c"><span class="hljs-keyword">int</span> powers[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>&#125;; <span class="hljs-comment">/* ANSI C and later */</span></code></pre><p>As you can see, you initialize an array by using a <strong>comma-separated</strong> list of values enclosed in braces. You can use spaces between the values and the commas, if you want.</p><p>Sometimes you might use an array that’s intended to be a <strong>read-only</strong> array. In such cases, you can, and should, use the <strong>const</strong> keyword when you declare and initialize the array.</p><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;</code></pre><p><strong>C99</strong> added a new capability: <strong>designated initializers</strong>. This feature allows you to pick and choose which elements are initialized.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>, [<span class="hljs-number">4</span>] = <span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>, [<span class="hljs-number">1</span>] = <span class="hljs-number">29</span>&#125;;</code></pre><p><strong>First</strong>, if the code follows a designated initializer with further values, as in the sequence [4] = 31,30,31, these further values are used to initialize the subsequent elements. That is, after initializing <code>days[4]</code> to <code>31</code>, the code initializes <code>days[5]</code> and <code>days[6]</code> to <code>30</code> and <code>31</code>, respectively. </p><p><strong>Second</strong>, if the code initializes a particular element to a value <strong>more than once</strong>, the <strong>last initialization</strong> is the one that takes effect.</p><h2 id="2-Assigning-Array-Values"><a href="#2-Assigning-Array-Values" class="headerlink" title="(2) Assigning Array Values"></a>(2) Assigning Array Values</h2><p><strong>C doesn’t let you assign one array to another as a unit. Nor can you use the list-in-braces form except when initializing.</strong></p><pre><code class="hljs c"><span class="hljs-keyword">int</span> oxen[SIZE] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>&#125;; <span class="hljs-comment">/* ok here */</span><span class="hljs-keyword">int</span> yaks[SIZE];yaks = oxen; <span class="hljs-comment">/* not allowed */</span>yaks[SIZE] = oxen[SIZE]; <span class="hljs-comment">/* out of range */</span> oxen[SIZE<span class="hljs-number">-1</span>] is the last element of <span class="hljs-built_in">array</span> oxenyaks[SIZE] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>&#125;; <span class="hljs-comment">/* doesn't work */</span></code></pre><p><strong>Why can’t assign one array to another as a unit</strong><br>From <code>The C Programming Language</code></p><blockquote><p>There is one difference between an <strong>array name</strong> and a <strong>pointer</strong> that must be kept in mind. A <strong>pointer</strong> is a variable. But an <strong>array name</strong> is not a variable;</p></blockquote><blockquote><p>The <strong>array name</strong> is the <strong>address</strong> of the zeroth element.</p></blockquote><p>理解：<br>数组名为第一个元素的地址，是常量，不能被赋值。</p><h2 id="3-Array-Bounds"><a href="#3-Array-Bounds" class="headerlink" title="(3) Array Bounds"></a>(3) Array Bounds</h2><p>The compiler doesn’t check to see <strong>whether the indices are valid</strong>. The result of using a bad index is, in the language of the C standard, undefined. That means when you run the program, it might seem to work, it might work oddly, or it might abort.</p><h2 id="4-Multidimensional-Arrays"><a href="#4-Multidimensional-Arrays" class="headerlink" title="(4) Multidimensional Arrays"></a>(4) Multidimensional Arrays</h2><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> rain[YEARS][MONTHS] =&#123;&#123;<span class="hljs-number">4.3</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">2.4</span>,<span class="hljs-number">3.5</span>,<span class="hljs-number">6.6</span>&#125;,&#123;<span class="hljs-number">8.5</span>,<span class="hljs-number">8.2</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">1.6</span>,<span class="hljs-number">2.4</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">5.2</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">1.4</span>,<span class="hljs-number">7.3</span>&#125;,&#123;<span class="hljs-number">9.1</span>,<span class="hljs-number">8.5</span>,<span class="hljs-number">6.7</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">2.1</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">1.1</span>,<span class="hljs-number">2.3</span>,<span class="hljs-number">6.1</span>,<span class="hljs-number">8.4</span>&#125;,&#123;<span class="hljs-number">7.2</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">8.4</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">1.7</span>,<span class="hljs-number">4.3</span>,<span class="hljs-number">6.2</span>&#125;,&#123;<span class="hljs-number">7.6</span>,<span class="hljs-number">5.6</span>,<span class="hljs-number">3.8</span>,<span class="hljs-number">2.8</span>,<span class="hljs-number">3.8</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.3</span>,<span class="hljs-number">2.6</span>,<span class="hljs-number">5.2</span>&#125;&#125;;</code></pre><h1 id="2-Pointers-and-Arrays"><a href="#2-Pointers-and-Arrays" class="headerlink" title="2. Pointers and Arrays"></a>2. Pointers and Arrays</h1><p>An <strong>array name</strong> is also the address of the first element of the array. </p><p>That is, if <code>flizny</code> is an <strong>array</strong>, the following is true:</p><pre><code class="hljs c">flizny == &amp;flizny[<span class="hljs-number">0</span>]; <span class="hljs-comment">// name of array is the address of the first element</span></code></pre><p>Both are <strong>constants</strong> because they <strong>remain fixed</strong> for the duration of the program. </p><pre><code class="hljs c">dates + <span class="hljs-number">2</span> == &amp;date[<span class="hljs-number">2</span>] <span class="hljs-comment">// same address</span>*(dates + <span class="hljs-number">2</span>) == dates[<span class="hljs-number">2</span>] <span class="hljs-comment">// same value</span></code></pre><pre><code class="hljs c"><span class="hljs-comment">/* day_mon3.c -- uses pointer notation */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MONTHS 12</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> days[MONTHS] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<span class="hljs-keyword">int</span> index;<span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; MONTHS; index++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Month %2d has %d days.\n"</span>, index +<span class="hljs-number">1</span>,*(days + index)); <span class="hljs-comment">// same as days[index]</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Here, <code>days</code> is the address of the first element of the array, <code>days + index</code> is the address of element <code>days[index]</code>, and <code>*(days + index)</code> is the value of that element, just as <code>days[index]</code> is. </p><h1 id="3-Functions-Arrays-and-Pointers"><a href="#3-Functions-Arrays-and-Pointers" class="headerlink" title="3. Functions, Arrays, and Pointers"></a>3. Functions, Arrays, and Pointers</h1><pre><code class="hljs c"><span class="hljs-keyword">int</span>* ar:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;</code></pre><p>The form <code>int* ar</code> always means that ar is type <strong>pointer-to-int</strong>. The form <code>int ar[]</code> also means that <code>ar</code> is type <strong>pointer-to-int</strong>, but only when used to declare <strong>formal parameters</strong>. </p><p>The idea is that the second form reminds the reader that not only does <code>ar</code> point to an int, it points to an int that’s an element of an array.</p><p>In this context, and only in this context, C interprets <code>int ar[]</code> to mean the same as <code>int* ar</code>; that is, <code>ar</code> is type <strong>pointer-to-int</strong>.</p><p>Because <strong>prototypes</strong> allow you to omit a name, all four of the following prototypes are equivalent:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *, <span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [], <span class="hljs-keyword">int</span>)</span></span>;</code></pre><p>You <strong>can’t omit names</strong> in function definitions, so, for definitions, the following two forms are equivalent:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// code goes here</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;&#123;<span class="hljs-comment">// code goes here</span>&#125;</code></pre><p><strong>Dereferencing an Uninitialized Pointer:</strong> Do not dereference an uninitialized pointer. For example, consider the following:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt; <span class="hljs-comment">// an uninitialized pointer</span>*pt = <span class="hljs-number">5</span>; <span class="hljs-comment">// a terrible error</span></code></pre><p>The second line means store the value <code>5</code> in the location to which <code>pt</code> points. But <code>pt</code>, being <strong>uninitialized</strong>, has a random value, so there is no knowing where the <code>5</code> will be placed. It might go somewhere harmless, it might overwrite data or code, or it might cause the program to crash. </p><h1 id="4-Using-Pointer-Parameters"><a href="#4-Using-Pointer-Parameters" class="headerlink" title="4. Using Pointer Parameters"></a>4. Using Pointer Parameters</h1><p>A function working on an array needs to know where to start and stop. </p><p>The two expressions <code>ar[i]</code> and <code>*(ar+i)</code> are equivalent in meaning. Both work if ar is the name of an <strong>array</strong>, and both work if ar is a <strong>pointer</strong> variable.<br>However, using an expression such as <code>ar++</code> only works if <code>ar</code> is a <strong>pointer</strong> variable.</p><p>You must use <strong>pointers</strong> if you want a function to affect variables in the calling function. The second use is in functions designed to manipulate arrays.</p><h1 id="5-Protecting-Array-Contents"><a href="#5-Protecting-Array-Contents" class="headerlink" title="5. Protecting Array Contents"></a>5. Protecting Array Contents</h1><p>The usual rule is to pass quantities by value unless the program needs to alter the value, in which case you pass a pointer. </p><p>Arrays don’t give you that choice; you must pass a pointer. The reason is efficiency. </p><p>If a function passed an array by value, it would have to allocate enough space to hold a copy of the original array and then copy all the data from the original array to the new array. </p><p>It is much quicker to pass the address of the array and have the function work with the original data.</p><h1 id="6-Using-const-with-Formal-Parameters"><a href="#6-Using-const-with-Formal-Parameters" class="headerlink" title="6. Using const with Formal Parameters"></a>6. Using const with Formal Parameters</h1><p>If a function’s intent is that it not change the contents of the array, use the keyword <strong>const</strong> when declaring the formal parameter in the prototype and in the <strong>function definition</strong>. </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>; <span class="hljs-comment">/* prototype */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">/* definition */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; n; i++)        total += ar[i];    <span class="hljs-keyword">return</span> total;&#125;</code></pre><p>It’s important to understand that using <strong>const</strong> this way <strong>does not require that the original array be constant</strong>; it just says that the function has to treat the array as though it were constant. </p><p>It prevents a function from modifying data in the calling function. </p><p><strong>There are some rules you should know about pointer assignments and const.</strong></p><p><strong>First</strong>, it’s valid to <strong>assign</strong> the <strong>address</strong> of either <strong>constant data</strong> or <strong>non-constant</strong> data to a <strong>pointer-to-constant</strong>:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> locked[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0.08</span>, <span class="hljs-number">0.075</span>, <span class="hljs-number">0.0725</span>, <span class="hljs-number">0.07</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *pc = rates; <span class="hljs-comment">// valid</span>pc = locked; <span class="hljs-comment">// valid</span>pc = &amp;rates[<span class="hljs-number">3</span>]; <span class="hljs-comment">// valid</span></code></pre><p><strong>However</strong>, only the addresses of <strong>non-constant data</strong> can be assigned to <strong>regular pointers</strong>:</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> locked[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0.08</span>, <span class="hljs-number">0.075</span>, <span class="hljs-number">0.0725</span>, <span class="hljs-number">0.07</span>&#125;;<span class="hljs-keyword">double</span> *pnc = rates; <span class="hljs-comment">// valid</span>pnc = locked; <span class="hljs-comment">// not valid</span>pnc = &amp;rates[<span class="hljs-number">3</span>]; <span class="hljs-comment">// valid</span></code></pre><p>This is a reasonable rule. Otherwise, you could use the pointer to change data that was supposed to be constant.</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> rates[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">88.99</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">59.45</span>, <span class="hljs-number">183.11</span>, <span class="hljs-number">340.5</span>&#125;;<span class="hljs-keyword">double</span>* <span class="hljs-keyword">const</span> pc = rates; <span class="hljs-comment">// pc points to beginning of the array</span>pc = &amp;rates[<span class="hljs-number">2</span>]; <span class="hljs-comment">// not allowed to point elsewhere</span>*pc = <span class="hljs-number">92.99</span>; <span class="hljs-comment">// ok -- changes rates[0]</span></code></pre><h1 id="7-Pointers-and-Multidimensional-Arrays"><a href="#7-Pointers-and-Multidimensional-Arrays" class="headerlink" title="7. Pointers and Multidimensional Arrays"></a>7. Pointers and Multidimensional Arrays</h1><p><img src="https://img-blog.csdnimg.cn/20190604210825828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlZTU2Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1-Pointers-to-Multidimensional-Arrays"><a href="#1-Pointers-to-Multidimensional-Arrays" class="headerlink" title="(1) Pointers to Multidimensional Arrays"></a>(1) Pointers to Multidimensional Arrays</h2><pre><code class="hljs c"><span class="hljs-keyword">int</span> (*pz)[<span class="hljs-number">2</span>]; <span class="hljs-comment">// pz points to an array of 2 ints</span></code></pre><p>This statement says that <code>pz</code> is a pointer to an array of two ints. </p><p><code>[ ]</code> has a higher precedence than <code>*</code>. Therefore, with a declaration such as:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span>* pax[<span class="hljs-number">2</span>]; <span class="hljs-comment">// pax is an array of two pointers-to-int</span></code></pre><p>You can use notation such as <code>pz[2][1]</code>, even though <code>pz</code> is a <strong>pointer</strong>, not an <strong>array</strong> name. </p><p>More generally, you can represent individual elements by using <strong>array notation</strong> or <strong>pointer notation</strong> with either an <strong>array</strong> name or a <strong>pointer</strong>:</p><pre><code class="hljs c">zippo[m][n] == *(*(zippo + m) + n)pz[m][n] == *(*(pz + m) + n)</code></pre><h2 id="2-Pointer-Compatibility"><a href="#2-Pointer-Compatibility" class="headerlink" title="(2) Pointer Compatibility"></a>(2) Pointer Compatibility</h2><p>The rules for assigning one <strong>pointer</strong> to another are tighter than the rules for <strong>numeric types</strong>. </p><p>For example, you can assign an <strong>int</strong> value to a <strong>double</strong> variable without using a <strong>type conversion</strong>, but you can’t do the same for <strong>pointers</strong> to these two types:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;<span class="hljs-keyword">double</span> x;<span class="hljs-keyword">int</span> * p1 = &amp;n;<span class="hljs-keyword">double</span>* pd = &amp;x;x = n; <span class="hljs-comment">// implicit type conversion</span>pd = p1; <span class="hljs-comment">// compile-time error</span></code></pre><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt;<span class="hljs-keyword">int</span> (*pa)[<span class="hljs-number">3</span>];<span class="hljs-keyword">int</span> ar1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<span class="hljs-keyword">int</span> ar2[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> **p2; <span class="hljs-comment">// a pointer to a pointer</span>Then we have the following:pt = &amp;ar1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>pt = ar1[<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>pt = ar1; <span class="hljs-comment">// not valid</span>pa = ar1; <span class="hljs-comment">// both pointer-to-int[3]</span>pa = ar2; <span class="hljs-comment">// not valid</span>p2 = &amp;pt; <span class="hljs-comment">// both pointer-to-int *</span>*p2 = ar2[<span class="hljs-number">0</span>]; <span class="hljs-comment">// both pointer-to-int</span>p2 = ar2; <span class="hljs-comment">// not valid</span></code></pre><h2 id="3-Functions-and-Multidimensional-Arrays"><a href="#3-Functions-and-Multidimensional-Arrays" class="headerlink" title="(3) Functions and Multidimensional Arrays"></a>(3) Functions and Multidimensional Arrays</h2><p>You can declare a function parameter of this type like this:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">somefunction</span><span class="hljs-params">( <span class="hljs-keyword">int</span> (*pt)[<span class="hljs-number">4</span>])</span></span>; <span class="hljs-comment">// pt is a pointer to an array of four ints.</span></code></pre><p>Alternatively, if (and only if) <code>pt</code> is a <strong>formal parameter</strong> to a function, you can declare it as follows:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">somefunction</span><span class="hljs-params">( <span class="hljs-keyword">int</span> pt[][<span class="hljs-number">4</span>] )</span></span>;</code></pre><p><strong>Note that the first set of brackets is empty. The empty brackets identify pt as being a pointer.</strong></p><p>Recall that the compiler converts <strong>array</strong> notation to <strong>pointer</strong> notation. This means, for example, that <code>ar[1]</code> will become <code>ar+1</code>. For the compiler to evaluate this, it needs to know the size object to which ar points. </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[][<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// valid declaration</span></code></pre><p>says that <code>ar</code> points to an array of four ints.</p><p>You can also include a size in the other bracket pair, as shown here, but the compiler ignores it: </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// valid declaration, 3 ignored</span></code></pre><p>In general, to declare a <strong>pointer</strong> corresponding to an <strong>N-dimensional array</strong>, <strong>you must supply values for all but the leftmost set of brackets</strong>:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum4d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[][<span class="hljs-number">12</span>][<span class="hljs-number">20</span>][<span class="hljs-number">30</span>], <span class="hljs-keyword">int</span> rows)</span></span>;</code></pre><p>That’s because the <strong>first set of brackets</strong> indicates a <strong>pointer</strong>, whereas the rest of the brackets describe the type of data object <strong>being pointed to</strong>, as the following equivalent prototype illustrates:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum4d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*ar)[<span class="hljs-number">12</span>][<span class="hljs-number">20</span>][<span class="hljs-number">30</span>], <span class="hljs-keyword">int</span> rows)</span></span>; <span class="hljs-comment">// ar a pointer</span></code></pre><p>Here, ar points to a <code>12×20×30</code> array of ints.</p><h2 id="4-Variable-Length-Arrays-VLAs"><a href="#4-Variable-Length-Arrays-VLAs" class="headerlink" title="(4) Variable-Length Arrays (VLAs)"></a>(4) Variable-Length Arrays (VLAs)</h2><p><strong>VLAs Do Not Change Size</strong>:<br>The term <strong>variable in variable-length array</strong> does not mean that you can modify the length of the array after you create it. Once created, a <strong>VLA</strong> keeps the <strong>same size</strong>. What the term variable does mean is that you can use a variable when specifying the array dimensions when <strong>first creating the array</strong>.</p><p>First, here’s how to declare a function with a <strong>two-dimensional VLA</strong> argument:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum2d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">int</span> ar[rows][cols])</span></span>; <span class="hljs-comment">// ar a VLA</span></code></pre><p>One point to note is that a <strong>VLA</strong> declaration in a function definition parameter list doesn’t actually create an array. Just as with the old syntax, the <strong>VLA</strong> name really is a <strong>pointer</strong>. This means a function with a <strong>VLA</strong> parameter actually works with the data in the <strong>original array</strong>, and therefore has the ability to <strong>modify the array</strong> passed as an argument. </p><pre><code class="hljs c"><span class="hljs-keyword">int</span> thing[<span class="hljs-number">10</span>][<span class="hljs-number">6</span>];twoset(<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,thing);...<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">twoset</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> ar[n][m])</span> <span class="hljs-comment">// ar a pointer to</span></span><span class="hljs-function"><span class="hljs-comment">// an array of m ints</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp[n][m]; <span class="hljs-comment">// temp an n x m array of int</span>    temp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// set an element of temp to 2</span>    ar[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// set thing[0][0] to 2</span>&#125;</code></pre><p>When <code>twoset()</code> is called as shown, <code>ar</code> becomes a pointer to <code>thing[0]</code>, and <code>temp</code> is created as a <code>10×6</code>array. Because both <code>ar</code> and <code>thing</code> are pointers to <code>thing[0]</code>, <code>ar[0][0]</code> accesses the same data location as <code>thing[0][0]</code>.</p><p><strong>Variable-length</strong> arrays also allow for <strong>dynamic memory allocation</strong>. This means you can specify the size of the array while the program is running. </p><h1 id="8-Compound-Literals"><a href="#8-Compound-Literals" class="headerlink" title="8. Compound Literals"></a>8. Compound Literals</h1><p>Suppose you want to pass a value to a function with an <strong>int</strong> parameter; you can pass an <strong>int</strong> variable, but you also can pass an <strong>int constant</strong>, such as <strong>5</strong>. Before <strong>C99</strong>, the situation for a function with an <strong>array argument</strong> was different; you could pass an <strong>array</strong>, but there was no equivalent to an <strong>array constant</strong>. <strong>C99</strong> changed that with the addition of compound literals. </p><p><strong>Literals</strong> are <strong>constants</strong> that aren’t symbolic. For example, <strong>5</strong> is a type <strong>int literal</strong>, <strong>81.3</strong> is a <strong>type double literal</strong>, <strong>‘Y’</strong> is a type <strong>char literal</strong>, and <strong>“elephant”</strong> is a <strong>string literal</strong>. </p><p>For <strong>arrays</strong>, a <strong>compound literal</strong> looks like an <strong>array initialization list</strong> preceded by a type name that is enclosed in parentheses. For example, here’s an ordinary array declaration:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> diva[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;</code></pre><p>And here’s a compound literal that creates a nameless array containing the same two int values:</p><pre><code class="hljs c">(<span class="hljs-keyword">int</span> [<span class="hljs-number">2</span>])&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125; <span class="hljs-comment">// a compound literal</span></code></pre><p>Because these <strong>compound literals</strong> are nameless, you can’t just create them in one statement and then use them later. Instead, you have to use them somehow when you make them.<br>One way is to use a *<em>pointer *</em>to keep track of the location. That is, you can do something like this:</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pt1;pt1 = (<span class="hljs-keyword">int</span> [<span class="hljs-number">2</span>]) &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;</code></pre><p>Another thing you could do with a <strong>compound literal</strong> is pass it as an actual argument to a function with a matching formal parameter:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ar[], <span class="hljs-keyword">int</span> n)</span></span>;...<span class="hljs-keyword">int</span> total3;total3 = sum((<span class="hljs-keyword">int</span> [])&#123;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>&#125;, <span class="hljs-number">6</span>);</code></pre><p>Keep in mind that a <strong>compound literal</strong> is a means for providing values that are needed only <strong>temporarily</strong>. It has block scope. That means its existence is not guaranteed once program execution leaves the block in which the compound literal is defined, that is, the innermost pair of braces containing the definition.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Functions</title>
    <link href="/2020/11/30/Functions/"/>
    <url>/2020/11/30/Functions/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 9 Functions</p><a id="more"></a><h1 id="1-Function-Arguments"><a href="#1-Function-Arguments" class="headerlink" title="1. Function Arguments"></a>1. Function Arguments</h1><h2 id="1-Defining-a-Function-with-an-Argument-Formal-Parameters"><a href="#1-Defining-a-Function-with-an-Argument-Formal-Parameters" class="headerlink" title="(1) Defining a Function with an Argument: Formal Parameters"></a>(1) Defining a Function with an Argument: Formal Parameters</h2><p>Formal parameters are local variables, private to the function.  </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dubs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span></span>;</code></pre><h2 id="2-Calling-a-Function-with-an-Argument-Actual-Arguments"><a href="#2-Calling-a-Function-with-an-Argument-Actual-Arguments" class="headerlink" title="(2) Calling a Function with an Argument: Actual Arguments"></a>(2) Calling a Function with an Argument: Actual Arguments</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_n_char</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> num)</span></span>;show_n_char(SPACE, <span class="hljs-number">12</span>);</code></pre><p>The <strong>actual arguments</strong> are the <code>space</code> character and <code>12</code>. These values are assigned to the corresponding <strong>formal parameters</strong> in <strong>show_n_char()</strong>—the variables <code>ch</code> and <code>num</code>. </p><p>In short, the <strong>formal parameter</strong> is a variable in the <strong>called function</strong>, and the <strong>actual argument</strong> is the particular value assigned to the function variable by the <strong>calling function</strong>. </p><p>The <strong>actual argument</strong> can be a constant, a variable, or an even more elaborate expression. Regardless of which it is, the <strong>actual argument</strong> is evaluated, and <strong>its value is copied to the corresponding formal parameter for the function</strong>.</p><p><strong>Because the called function works with data copied from the calling function, the original data in the calling function is protected from whatever manipulations the called function applies to the copies.</strong></p><h1 id="2-Returning-a-Value-from-a-Function-with-return"><a href="#2-Returning-a-Value-from-a-Function-with-return" class="headerlink" title="2. Returning a Value from a Function with return"></a>2. Returning a Value from a Function with return</h1><p>Using <strong>return</strong> has one other effect. It terminates the function and returns control to the next statement in the calling function. <strong>This occurs even if the return statement is not the last in the function.</strong></p><h1 id="3-Finding-Addresses-The-amp-Operator"><a href="#3-Finding-Addresses-The-amp-Operator" class="headerlink" title="3. Finding Addresses: The &amp; Operator"></a>3. Finding Addresses: The &amp; Operator</h1><p>One of the most important C concepts (and sometimes one of the most perplexing) is the <strong>pointer</strong>, which is a variable used to store an address.  </p><p>The unary <strong>&amp;</strong> operator gives you the address where a variable is stored. </p><h1 id="4-Pointers-A-First-Look"><a href="#4-Pointers-A-First-Look" class="headerlink" title="4. Pointers: A First Look"></a>4. Pointers: A First Look</h1><p>Basically, a <strong>pointer</strong> is a variable (or, more generally, a data object) whose value is a memory address. </p><pre><code class="hljs c">ptr = &amp;pooh; <span class="hljs-comment">// assigns pooh's address to ptr</span></code></pre><p>We say that ptr  “points to” pooh. The difference between ptr and &amp;pooh is that <strong>ptr</strong> is a variable, and <strong>&amp;pooh</strong> is a constant. </p><pre><code class="hljs c"><span class="hljs-keyword">int</span> * pi; <span class="hljs-comment">// pi is a pointer to an integer variable</span><span class="hljs-keyword">char</span> * pc; <span class="hljs-comment">// pc is a pointer to a character variable</span><span class="hljs-keyword">float</span> * pf, * pg; <span class="hljs-comment">// pf, pg are pointers to float variables</span></code></pre><p>A <strong>pointer</strong> really is a new type, not an <strong>integer</strong> type. Therefore, as mentioned before, ANSI C provides the <strong>%p</strong> form specifically for pointers.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Character Input/Output</title>
    <link href="/2020/11/29/Character-Input-Output/"/>
    <url>/2020/11/29/Character-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 8 Character Input/Output and Input Validation</p><a id="more"></a><h1 id="1-Single-Character-I-O-getchar-and-putchar"><a href="#1-Single-Character-I-O-getchar-and-putchar" class="headerlink" title="1. Single-Character I/O: getchar() and putchar()"></a>1. Single-Character I/O: getchar() and putchar()</h1><p><strong>getchar()</strong> and <strong>putchar()</strong> perform input and output one character at a time. </p><p>All it does is fetch characters from <strong>keyboard input</strong> and send them to the screen. This process is called <strong>echoing the input</strong>. </p><h1 id="2-Buffers"><a href="#2-Buffers" class="headerlink" title="2. Buffers"></a>2. Buffers</h1><h2 id="1-unbuffered-or-direct-input"><a href="#1-unbuffered-or-direct-input" class="headerlink" title="(1) unbuffered (or direct) input"></a>(1) unbuffered (or direct) input</h2><p>The characters you type are <strong>immediately made available</strong> to the waiting program. </p><h2 id="2-buffered-input"><a href="#2-buffered-input" class="headerlink" title="(2)  buffered input"></a>(2)  buffered input</h2><p>The characters you type are <strong>collected and stored in an area of temporary storage</strong> called a <strong>buffer</strong>.  Pressing <strong>Enter</strong> causes the block of characters you typed to be made available to your program. </p><h3 id="fully-buffered-I-O"><a href="#fully-buffered-I-O" class="headerlink" title="fully buffered I/O"></a>fully buffered I/O</h3><p>The <strong>buffer</strong> is flushed (the contents are sent to their destination) when it is <strong>full</strong>. This kind of buffering usually occurs with <strong>file input</strong>. </p><p>The buffer size depends on the system, but 512 bytes and 4096 bytes are common values. </p><h3 id="line-buffered-I-O"><a href="#line-buffered-I-O" class="headerlink" title="line-buffered I/O"></a>line-buffered I/O</h3><p>The <strong>buffer</strong> is flushed whenever a <strong>newline character shows up</strong>. <strong>Keyboard input</strong> is normally <strong>line buffered</strong>, so that pressing <strong>Enter</strong> flushes the buffer.</p><h1 id="3-Files-Streams-and-Keyboard-Input"><a href="#3-Files-Streams-and-Keyboard-Input" class="headerlink" title="3. Files, Streams, and Keyboard Input"></a>3. Files, Streams, and Keyboard Input</h1><h2 id="1-file"><a href="#1-file" class="headerlink" title="(1)  file"></a>(1)  file</h2><p>A <strong>file</strong> is an area of memory in which information is stored. </p><p>Conceptually, the C program deals with a <strong>stream</strong> instead of directly with a file. </p><h2 id="2-stream"><a href="#2-stream" class="headerlink" title="(2) stream"></a>(2) stream</h2><p>A <strong>stream</strong> is an idealized flow of data to which the actual input or output is mapped.</p><h1 id="4-The-End-of-File"><a href="#4-The-End-of-File" class="headerlink" title="4. The End of File"></a>4. The End of File</h1><p>A computer operating system needs some way to tell where each file begins and ends. </p><p>One method to detect the end of a file is to place a <strong>special character</strong> in the file to <strong>mark the end</strong>.</p><p>A second approach is for the operating system to store information on the size of the file.</p><p>C handles this variety of methods by having the  <strong>getchar()</strong>  function return a special value when the end of a file is reached, regardless of how the operating system actually detects the end of file. The name given to this value is <strong>EOF</strong> (end of file). </p><p>Therefore, the <strong>return value</strong> for <strong>getchar()</strong> when it detects an end of file is <strong>EOF</strong>. The <strong>scanf()</strong> function also returns <strong>EOF</strong> on detecting the end of a file. </p><p>Typically, <strong>EOF</strong> is defined in the <strong>stdio.h</strong> file as follows:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOF (-1)</span></code></pre><p>Normally, <strong>getchar()</strong> returns a value in the range <strong>0</strong> through <strong>127</strong>, because those are values corresponding to the standard character set, but it might return values from <strong>0</strong> through <strong>255</strong> if the system recognizes an extended character set. </p><p>In either case, the value <strong>-1</strong> does not correspond to any character, so it can be used to signal the end of a file.<br>&nbsp;</p><pre><code class="hljs c"><span class="hljs-comment">/* echo_eof.c -- repeats input to end of file */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ch;    <span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)        <span class="hljs-built_in">putchar</span>(ch);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>Note:</strong></p><ul><li>You don’t have to define <strong>EOF</strong> because <strong>stdio.h</strong> takes care of that.</li><li>You don’t have to worry about the actual value of <strong>EOF</strong>, because the <strong>#define</strong> statement in <strong>stdio.h</strong> enables you to use the symbolic representation <strong>EOF</strong>. You shouldn’t write code that assumes <strong>EOF</strong> has a particular value.</li><li><strong>getchar()</strong> is actually type int itself, so it can read the EOF character.</li><li>The fact that <strong>getchar()</strong> is type <strong>int</strong> is why some compilers warn of possible data loss if you assign the <strong>getchar()</strong> return value to a type <strong>char</strong> variable.</li><li>The fact that <strong>ch</strong> is an <strong>integer</strong> doesn’t faze <strong>putchar()</strong>. It still prints the character equivalent.</li><li>To use this program on <strong>keyboard input</strong>, you need a way to type the <strong>EOF</strong> character. On <strong>most Unix and Linux systems</strong>, for example, pressing <strong>Ctrl+D</strong> at the <strong>beginning of a line</strong> causes the <strong>end-of-file signal</strong> to be transmitted. Many <strong>microcomputing systems</strong> recognize <strong>Ctrl+Z</strong> at the beginning of a line as an end-of-file signal; some interpret a <strong>Ctrl+Z</strong> anywhere as an <strong>end-of-file signal</strong>.</li></ul><h1 id="5-Redirection"><a href="#5-Redirection" class="headerlink" title="5. Redirection"></a>5. Redirection</h1><p><strong>Redirecting</strong> input enables your program to use a <strong>file</strong> instead of the <strong>keyboard</strong> for input, and redirecting output enables it to use a <strong>file</strong> instead of the <strong>screen</strong> for output.</p><h2 id="1-Redirecting-Input"><a href="#1-Redirecting-Input" class="headerlink" title="(1) Redirecting Input"></a>(1) Redirecting Input</h2><p>The program runs as described earlier, taking its input from the keyboard. Now suppose you want to use the program on a <strong>text file</strong> called <code>words</code>. </p><p>A <strong>text file</strong> is one containing text—that is, data stored as <strong>human-readable characters</strong>. It could be an essay or a program in C, for example. A file containing machine language instructions, such as the file holding the executable version<br>of a program, is not a text file. </p><p>All you need to do is enter this command instead of the previous one:</p><pre><code class="hljs bash">echo_eof &lt; words</code></pre><p>The <code>&lt;</code> symbol is a <strong>Unix and Linux and DOS/Windows redirection operator</strong>. It causes the <code>words</code> file to be associated with the <strong>stdin stream</strong>, channeling the file contents into the <code>echo_eof</code> program. </p><p>The <code>echo_eof</code> program itself doesn’t know (or care) that the input is coming from a file instead of the keyboard. All it knows is that a stream of characters is being fed to it, so it reads them and prints them one character at a time until the end of file shows up. </p><p>Because C puts files and I/O devices on the same footing, the file is now the I/O device. </p><h2 id="2-Redirecting-Output"><a href="#2-Redirecting-Output" class="headerlink" title="(2) Redirecting Output"></a>(2) Redirecting Output</h2><p>Now suppose you want to have <code>echo_eof</code> send your keyboard input to a file called <code>mywords</code>.</p><p>Then you can enter the following and begin typing:</p><pre><code class="hljs bash">echo_eof &gt; mywords</code></pre><p>The <code>&gt;</code> is a second <strong>redirection operator</strong>. It causes a new file called <code>mywords</code> to be created for your use, and then it *<em>redirects the output *</em>of <code>echo_eof</code> (that is, a copy of the characters you type) to that file. </p><p>If you already have a file with the name <code>mywords</code>, normally it would be <strong>erased</strong> and then <strong>replaced</strong> by the new one. (Many operating systems, however, give you the option of protecting existing files by making them <strong>read-only</strong>.) </p><p>All that appears on your screen are the letters as you type them, and the copies go to the file instead. To end the program, press <strong>Ctrl+D</strong>.</p><h2 id="3-Combined-Redirection"><a href="#3-Combined-Redirection" class="headerlink" title="(3) Combined Redirection"></a>(3) Combined Redirection</h2><p>Now suppose you want to make a copy of the file mywords and call it savewords. Just issue this next command:</p><pre><code class="hljs bash">echo_eof &lt; mywords &gt; savewords</code></pre><p>or:</p><pre><code class="hljs bash">echo_eof &gt; savewords &lt; mywords</code></pre><p><strong>Beware: *<em>Don’t use the *</em>same file for both input and output</strong> to the same command.</p><pre><code class="hljs bash">echo_eof &lt; mywords &gt; mywords....&lt;--WRONG</code></pre><p>The reason is that <code>&gt;</code> mywords causes the original mywords to be <strong>truncated to zero length</strong> before it is ever used as input.</p><p><strong>Rules:</strong></p><ul><li>A <strong>redirection operator</strong> connects an <strong>executable program</strong> (including standard operating system commands) with a <strong>data file</strong>. It cannot be used to connect one data file to another, nor can it be used to connect one program to another program.</li><li>Input cannot be taken from <strong>more than one file</strong>, nor can output be directed to more than one file by using these operators.</li><li>Normally, <strong>spaces between the names and operators are optional</strong>, except occasionally when some characters with special meaning to the Unix shell or Linux shell or the Windows Command Prompt mode are used. We could, for example, have used <code>echo_ eof&lt;words</code>.</li></ul><p>Unix, Linux, and Windows/DOS also feature the <code>&gt;&gt;</code> operator, which enables you to <strong>add data</strong> to the end of an <strong>existing file</strong>, and the pipe operator (<code>|</code>), which enables you to connect the <strong>output of one program</strong> to the <strong>input of a second program</strong>. </p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Branching and Jumps</title>
    <link href="/2020/11/29/Branching-and-Jumps/"/>
    <url>/2020/11/29/Branching-and-Jumps/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Editioni) Chapter 7 C Control Statements: Branching and Jumps</p><a id="more"></a><h1 id="1-getchar-and-putchar"><a href="#1-getchar-and-putchar" class="headerlink" title="1.  getchar() and putchar()"></a>1.  getchar() and putchar()</h1><p>The <strong>getchar()</strong> function takes no arguments, and it <strong>returns</strong> the next character from input.<br>&nbsp;<br>The <strong>putchar()</strong> function prints its argument.<br>&nbsp;<br>Because these functions deal only with characters, they are faster and more compact than the more general <strong>scanf()</strong> and <strong>printf()</strong> functions.<br>&nbsp;<br>Characters are really stored as <strong>integers</strong>. <strong>getchar( )</strong> is actually type <strong>int</strong> itself.</p><h1 id="2-The-ctype-h-Family-of-Character-Functions"><a href="#2-The-ctype-h-Family-of-Character-Functions" class="headerlink" title="2. The ctype.h Family of Character Functions"></a>2. The ctype.h Family of Character Functions</h1><p>C has a standard set of functions for analyzing characters; the <strong>ctype.h</strong> header file contains the prototypes.<br>&nbsp;<br>Note that the mapping functions don’t modify the original argument; instead, they return the modified value. </p><pre><code class="hljs c"><span class="hljs-built_in">tolower</span>(ch); <span class="hljs-comment">// no effect on ch</span>ch = <span class="hljs-built_in">tolower</span>(ch); <span class="hljs-comment">// convert ch to lowercase</span></code></pre><table><thead><tr><th align="left">Name</th><th align="left">True If the Argument Is</th></tr></thead><tbody><tr><td align="left">isalnum()</td><td align="left">Alphanumeric (alphabetic or numeric)</td></tr><tr><td align="left">isalpha()</td><td align="left">Alphabetic</td></tr><tr><td align="left">isblank()</td><td align="left">A standard blank character (space, horizontal tab, or newline) or any additional locale-specific character so specified</td></tr><tr><td align="left">iscntrl()</td><td align="left">A control character, such as Ctrl+B</td></tr><tr><td align="left">isdigit()</td><td align="left">A digit</td></tr><tr><td align="left">isgraph()</td><td align="left">Any printing character other than a space</td></tr><tr><td align="left">islower()</td><td align="left">A lowercase character</td></tr><tr><td align="left">isprint()</td><td align="left">A printing character</td></tr><tr><td align="left">ispunct()</td><td align="left">A punctuation character (any printing character other than a space or an alphanumeric character)</td></tr><tr><td align="left">isspace()</td><td align="left">A whitespace character (a space, newline, formfeed, carriage return, vertical tab, horizontal tab, or, possibly, other locale-defined character)</td></tr><tr><td align="left">isupper()</td><td align="left">An uppercase character</td></tr><tr><td align="left">isxdigit()</td><td align="left">A hexadecimal-digit character</td></tr></tbody></table><table><thead><tr><th align="left">Name</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">tolower()</td><td align="left">If the argument is an uppercase character, this function returns the lowercase version; otherwise, it just returns the original argument.</td></tr><tr><td align="left">toupper()</td><td align="left">If the argument is a lowercase character, this function returns the uppercase version; otherwise, it just returns the original argument.</td></tr></tbody></table><h1 id="3-Logical-Operators"><a href="#3-Logical-Operators" class="headerlink" title="3. Logical Operators"></a>3. Logical Operators</h1><table><thead><tr><th align="left">Operator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">and</td></tr><tr><td align="left">||</td><td align="left">or</td></tr><tr><td align="left">!</td><td align="left">not</td></tr></tbody></table><h2 id="1-Precedence"><a href="#1-Precedence" class="headerlink" title="(1) Precedence"></a>(1) Precedence</h2><p>The <strong>!</strong> operator has a very high precedence—higher than <strong>multiplication</strong>, the same as the <strong>increment operators</strong>, and just below that of <strong>parentheses</strong>. The <strong>&amp;&amp;</strong> operator has higher precedence than <strong>||</strong>.</p><h2 id="2-Order-of-Evaluation"><a href="#2-Order-of-Evaluation" class="headerlink" title="(2) Order of Evaluation"></a>(2) Order of Evaluation</h2><p>The <strong>&amp;&amp;</strong> and <strong>||</strong> operators are sequence points, so all side effects take place before a program moves from one operand to the next. </p><pre><code class="hljs c"><span class="hljs-keyword">while</span> ( x++ &lt; <span class="hljs-number">10</span> &amp;&amp; x + y &lt; <span class="hljs-number">20</span>)</code></pre><p>The fact that the <strong>&amp;&amp;</strong> operator is a sequence point guarantees that <code>x</code> is incremented before the expression on the right is evaluated.</p><h1 id="4-A-Word-Count-Program"><a href="#4-A-Word-Count-Program" class="headerlink" title="4. A Word-Count Program"></a>4. A Word-Count Program</h1><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STOP <span class="hljs-meta-string">'\x1b'</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> c;  <span class="hljs-comment">//read in character</span>    <span class="hljs-keyword">char</span> prev; <span class="hljs-comment">//previous character read</span>    <span class="hljs-keyword">long</span> n_chars = <span class="hljs-number">0L</span>; <span class="hljs-comment">//number of characters</span>    <span class="hljs-keyword">long</span> n_alphabets = <span class="hljs-number">0L</span>; <span class="hljs-comment">//alphabetic</span>    <span class="hljs-keyword">long</span> n_digits = <span class="hljs-number">0L</span>; <span class="hljs-comment">//digits</span>    <span class="hljs-keyword">long</span> n_spaces = <span class="hljs-number">0L</span>;    <span class="hljs-keyword">long</span> n_punctuations = <span class="hljs-number">0L</span>;    <span class="hljs-keyword">int</span> n_lines = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> n_words = <span class="hljs-number">0</span>;    <span class="hljs-keyword">bool</span> inword = <span class="hljs-literal">false</span>;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter text to be analyzed (Esc to terminate):\n"</span>);    prev = <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">while</span> ((c = getchar()) != STOP)    &#123;        n_chars++;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalpha</span>(c))           n_alphabets++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))            n_digits++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ispunct</span>(c))            n_punctuations++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c))            n_spaces++;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'\n'</span>)            n_lines++;        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isspace</span>(c) &amp;&amp; !inword)         &#123;            inword = <span class="hljs-literal">true</span>;            n_words++;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c) &amp;&amp; inword)         &#123;            inword = <span class="hljs-literal">false</span>; <span class="hljs-comment">//reached end of a word</span>        &#125;        prev = c;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Charaters = %ld, alphabets = %ld, digits = %ld,\</span><span class="hljs-string">    punctuations = %ld, spaces = %ld,  words = %d, lines = %d\n"</span>,    n_chars,n_alphabets,n_digits,n_punctuations,n_spaces,n_words,n_lines);    <span class="hljs-comment">/*return 0; */</span>&#125;</code></pre><p>Output:</p><pre><code class="hljs c"><span class="hljs-function">Enter <span class="hljs-built_in">text</span> to be <span class="hljs-title">analyzed</span> <span class="hljs-params">(Esc to <span class="hljs-built_in">terminate</span>)</span>:</span><span class="hljs-function">Reason is a</span><span class="hljs-function">powerful servant but</span>an inadequate master.<span class="hljs-number">2</span> - <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;*** :) ***^[Charaters = <span class="hljs-number">77</span>, alphabets = <span class="hljs-number">45</span>, digits = <span class="hljs-number">3</span>, punctuations = <span class="hljs-number">12</span>, spaces = <span class="hljs-number">17</span>,  words = <span class="hljs-number">17</span>, lines = <span class="hljs-number">5</span></code></pre><h1 id="5-The-Conditional-Operator"><a href="#5-The-Conditional-Operator" class="headerlink" title="5. The Conditional Operator: ?:"></a>5. The Conditional Operator: ?:</h1><p>C offers a shorthand way to express one form of the <strong>if else</strong> statement. It is called a conditional expression and uses the <strong>?:</strong> conditional operator. </p><pre><code class="hljs c">expression1 ? expression2 : expression3</code></pre><p>If expression1 is true (nonzero), the whole conditional expression has the same value as expression2. If expression1 is false (zero), the whole conditional expression has the same value as expression3.</p><h1 id="6-Loop-Aids-continue-and-break"><a href="#6-Loop-Aids-continue-and-break" class="headerlink" title="6. Loop Aids: continue and break"></a>6. Loop Aids: continue and break</h1><h2 id="1-The-continue-Statement"><a href="#1-The-continue-Statement" class="headerlink" title="(1) The continue Statement"></a>(1) The continue Statement</h2><p>The continue statement causes the program to <strong>skip over</strong> the rest of the loop, which is devoted to processing valid input. Instead, the program <strong>starts the next loop cycle</strong> by attempting to read the next input value. </p><p><strong>continue</strong> works for the while, do while, for, and not for the switch function.</p><p><strong>continue</strong> terminates the current loop, but not the entire loop.</p><pre><code class="hljs c"><span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">10</span>; count++)&#123;ch = getchar();<span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'\n'</span>)<span class="hljs-keyword">continue</span>;<span class="hljs-built_in">putchar</span>(ch);&#125;</code></pre><p>In this case, when the <strong>continue</strong> statement is executed, <strong>first count is incremented</strong> and then it’s compared to 10.</p><h2 id="2-The-break-Statement"><a href="#2-The-break-Statement" class="headerlink" title="(2) The break Statement"></a>(2) The break Statement</h2><p>A <strong>break</strong> statement in a loop causes the program to break free of the loop that encloses it and to proceed to the next stage of the program. </p><p>break works for while, do while, for and switch functions.</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> i;  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  &#123;    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)    <span class="hljs-keyword">break</span>;  &#125;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %d\n"</span>,i);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>In this case, when the program executes the <strong>break</strong> statement, it breaks out of the for loop <strong>without adding i</strong>.  </p><h1 id="7-The-goto-Statement"><a href="#7-The-goto-Statement" class="headerlink" title="7. The goto Statement"></a>7. The goto Statement</h1><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &gt; <span class="hljs-number">12</span>)    <span class="hljs-keyword">goto</span> a;<span class="hljs-keyword">goto</span> b;a: cost = cost * <span class="hljs-number">1.05</span>;flag = <span class="hljs-number">2</span>;b: bill = cost * flag;</code></pre><p>It is the same as:</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &gt; <span class="hljs-number">12</span>)&#123;    cost = cost * <span class="hljs-number">1.05</span>;    flag = <span class="hljs-number">2</span>;&#125;bill = cost * flag;</code></pre><p>When a <strong>goto</strong> is encountered, it jumps unconditionally to the statement where the <strong>label</strong> is, and then <strong>executes sequentially from there</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operators, Expressions, and Statements</title>
    <link href="/2020/11/28/Operators-Expressions-and-Statements/"/>
    <url>/2020/11/28/Operators-Expressions-and-Statements/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 5 Operators, Expressions, and Statements</p><a id="more"></a><h1 id="1-Fundamental-Operators"><a href="#1-Fundamental-Operators" class="headerlink" title="1. Fundamental Operators"></a>1. Fundamental Operators</h1><h2 id="1-Assignment-Operator"><a href="#1-Assignment-Operator" class="headerlink" title="(1) Assignment Operator: ="></a>(1) Assignment Operator: =</h2><p>The <code>=</code> symbol is called the assignment operator.</p><h3 id="Some-Terminology-Data-Objects-Lvalues-Rvalues-and-Operands"><a href="#Some-Terminology-Data-Objects-Lvalues-Rvalues-and-Operands" class="headerlink" title="Some Terminology: Data Objects, Lvalues, Rvalues, and Operands"></a>Some Terminology: Data Objects, Lvalues, Rvalues, and Operands</h3><p>Consider an assignment statement. Its purpose is to store a value at a memory location.<br>&nbsp;<br><strong>Data object</strong> is a general term for a region of data storage that can be used to hold values.<br>&nbsp;<br>C uses the term <strong>lvalue</strong> to mean any such name or expression that identifies a particular data object. <strong>Object</strong> refers to the actual data storage, but an <strong>lvalue</strong> is a <strong>label</strong> used to identify, or locate, that storage.</p><p>The term <strong>rvalue</strong> refers to quantities that can be assigned to modifiable <strong>lvalues</strong> but which are not themselves lvalues. <strong>Rvalues</strong> can be constants, variables, or any other expression that yields a value. </p><h2 id="2-Division-Operator"><a href="#2-Division-Operator" class="headerlink" title="(2) Division Operator: /"></a>(2) Division Operator: /</h2><p>Division works differently for integer types than it does for floating types. Floating-type division gives a floating-point answer, but integer division yields an integer answer.</p><p>Integer division does not round to the nearest integer, but always truncates (that is, discards the entire fractional part).</p><pre><code class="hljs c"><span class="hljs-number">5</span>/<span class="hljs-number">2</span> = <span class="hljs-number">2</span><span class="hljs-number">-5</span>/<span class="hljs-number">2</span> = <span class="hljs-number">-2</span><span class="hljs-number">5</span>/(<span class="hljs-number">-2</span>) = <span class="hljs-number">-2</span></code></pre><h2 id="3-Modulus-Operator"><a href="#3-Modulus-Operator" class="headerlink" title="(3) Modulus Operator: %"></a>(3) Modulus Operator: %</h2><p>The modulus operator is used in <strong>integer arithmetic</strong>. It gives the remainder that results when the integer to its left is divided by the integer to its right. For example, 13 % 5 (read as “13 modulo 5”) has the value 3.</p><p>You get a negative modulus value if the first operand is negative, and you get a positive modulus otherwise.</p><pre><code class="hljs c"><span class="hljs-number">5</span>%<span class="hljs-number">2</span> = <span class="hljs-number">1</span><span class="hljs-number">-5</span>%<span class="hljs-number">2</span> = <span class="hljs-number">-1</span><span class="hljs-number">5</span>%(<span class="hljs-number">-2</span>) = <span class="hljs-number">1</span></code></pre><h2 id="4-Increment-and-Decrement-Operators-and-–"><a href="#4-Increment-and-Decrement-Operators-and-–" class="headerlink" title="(4) Increment and Decrement Operators: ++ and –"></a>(4) Increment and Decrement Operators: ++ and –</h2><p>The increment operator performs a simple task; it increments (increases) the value of its operand by 1. </p><pre><code class="hljs pgsql">a_post = a++; // postfix: a <span class="hljs-keyword">is</span> changed <span class="hljs-keyword">after</span> its <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> usedb_pre= ++b;// prefix: b <span class="hljs-keyword">is</span> changed <span class="hljs-keyword">before</span> its <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> used(a + b)++; //invalid</code></pre><p>You can get fooled if you try to do too much at once with the increment operators.</p><pre><code class="hljs c"><span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">21</span>)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%10d %10d\n"</span>, num, num*num++);&#125;</code></pre><p>In C, the compiler can choose which arguments in a function to evaluate first.</p><pre><code class="hljs c">ans = num/<span class="hljs-number">2</span> + <span class="hljs-number">5</span>*(<span class="hljs-number">1</span> + num++);</code></pre><p>You would think that it would find num/2 first and then move on, but it might do the last term first.</p><h2 id="5-The-Comma-Operator"><a href="#5-The-Comma-Operator" class="headerlink" title="(5) The Comma Operator"></a>(5) The Comma Operator</h2><p>First, it guarantees that the expressions it separates are evaluated in a <strong>left-to-right order</strong>.<br>Second, the <strong>value of the whole comma expression</strong> is the value of the <strong>right-hand member</strong>.</p><pre><code class="hljs c">x = (y = <span class="hljs-number">3</span>, (z = ++y + <span class="hljs-number">2</span>) + <span class="hljs-number">5</span>);<span class="hljs-comment">//x = (z = ++y + 2) + 5;</span></code></pre><h1 id="2-Operator-Precedence"><a href="#2-Operator-Precedence" class="headerlink" title="2. Operator Precedence"></a>2. Operator Precedence</h1><table><thead><tr><th align="center">Operators (decreasing precedence)</th><th align="center">Associativity</th></tr></thead><tbody><tr><td align="center">+ - (unary)</td><td align="center">Left to right</td></tr><tr><td align="center">* /</td><td align="center">Left to right</td></tr><tr><td align="center">+ - (binary)</td><td align="center">Left to right</td></tr><tr><td align="center">=</td><td align="center">Left to right</td></tr><tr><td align="center">,</td><td align="center">Left to right</td></tr></tbody></table><h1 id="3-Expressions-and-Statements"><a href="#3-Expressions-and-Statements" class="headerlink" title="3. Expressions and Statements"></a>3. Expressions and Statements</h1><h2 id="1-Expressions"><a href="#1-Expressions" class="headerlink" title="(1) Expressions"></a>(1) Expressions</h2><p>An expression consists of a combination of operators and operands.<br>&nbsp;<br>An important property of C is that every C expression has a value. </p><h2 id="2-Statements"><a href="#2-Statements" class="headerlink" title="(2) Statements"></a>(2) Statements</h2><p>Statements are the primary building blocks of a program. A program is a series of statements with some necessary punctuation. A statement is a complete instruction to the computer. In C, statements are indicated by a <strong>semicolon</strong> at the end. </p><h1 id="4-Type-Conversions"><a href="#4-Type-Conversions" class="headerlink" title="4. Type Conversions"></a>4. Type Conversions</h1><h2 id="1-Automatic-Type-Conversions"><a href="#1-Automatic-Type-Conversions" class="headerlink" title="(1) Automatic Type Conversions"></a>(1) Automatic Type Conversions</h2><ol><li>When appearing in an <strong>expression</strong>, <strong>char</strong> and <strong>short</strong>, both <strong>signed</strong> and <strong>unsigned</strong>, are <strong>automatically</strong> converted to <strong>int</strong> or, if necessary, to <strong>unsigned int</strong>. (If <strong>short</strong> is the same size as <strong>int</strong>, <strong>unsigned short</strong> is larger than <strong>int</strong>; in that case, <strong>unsigned short</strong> is converted to <strong>unsigned int</strong>.) Under <strong>K&amp;R</strong> C, but not under current C, <strong>float</strong> is automatically converted to <strong>double</strong>. Because they are conversions to larger types, they are called <strong>promotions</strong>.</li><li>In any <strong>operation</strong> involving <strong>two types</strong>, both values are converted to the <strong>higher ranking</strong> of the two types.</li><li>The <strong>ranking of types</strong>, from <strong>highest to lowest</strong>, is <strong>long double</strong>, <strong>double</strong>, <strong>float</strong>, <strong>unsigned long long</strong>, <strong>long long</strong>, <strong>unsigned long</strong>, <strong>long</strong>, <strong>unsigned int</strong>, and <strong>int</strong>. One possible <strong>exception</strong> is when <strong>long and int are the same size</strong>, in which case <strong>unsigned int</strong> outranks <strong>long</strong>. The <strong>short</strong> and <strong>char</strong> types don’t appear in this list because they would have been already promoted to int or perhaps <strong>unsigned int</strong>.</li><li>In an <strong>assignment statement</strong>, the final result of the calculations is converted to the type of <strong>the variable being assigned a value</strong>. This process can result in <strong>promotion</strong>, as described in rule 1, or <strong>demotion</strong>, in which a value is converted to a lower-ranking type.</li><li>When passed as <strong>function arguments</strong>, <strong>char</strong> and <strong>short</strong> are converted to <strong>int</strong>, and <strong>float</strong> is converted to <strong>double</strong>. This <strong>automatic promotion</strong> is overridden by function prototyping.</li></ol><h2 id="2-The-Cast-Operator"><a href="#2-The-Cast-Operator" class="headerlink" title="(2) The Cast Operator"></a>(2) The Cast Operator</h2><p>The parentheses and type name together constitute a cast operator.</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>)<span class="hljs-number">1.6</span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Charater Strings and Formatted Input/Output</title>
    <link href="/2020/11/28/Charater-Strings-and-Formatted-Input-Output/"/>
    <url>/2020/11/28/Charater-Strings-and-Formatted-Input-Output/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 4 Charater Strings and Formatted Input/Output</p><a id="more"></a><h1 id="1-Character-Strings"><a href="#1-Character-Strings" class="headerlink" title="1. Character Strings"></a>1. Character Strings</h1><p> A character string is a series of one or more characters. </p><h2 id="1-Type-char-Arrays-and-the-Null-Character"><a href="#1-Type-char-Arrays-and-the-Null-Character" class="headerlink" title="(1) Type char Arrays and the Null Character"></a>(1) Type char Arrays and the Null Character</h2><p>C has no special variable type for strings. Instead, strings are stored in an array of type char. Characters in a string are stored in adjacent memory cells, one character per cell, and an array consists of adjacent memory locations.<br><img src="https://img-blog.csdnimg.cn/20190521222859479.png" srcset="/img/loading.gif" alt=""><br>The <strong>null character</strong> is not the digit zero; it is the nonprinting character whose <strong>ASCII</strong> code value (or equivalent) is <strong>0</strong>. Strings in C are always stored with this terminating null character. The presence of the null character means that the array must have <strong>at least one more cell</strong> than the number of characters to be stored. </p><h2 id="2-Using-Strings"><a href="#2-Using-Strings" class="headerlink" title="(2) Using Strings"></a>(2) Using Strings</h2><p>In general, <strong>scanf()</strong> is used with <strong>%s</strong> to read only a <strong>single word</strong>, not a whole phrase, as a string. C has other input-reading functions, such as <strong>fgets()</strong>, for handling general strings.</p><h2 id="3-Strings-Versus-Characters"><a href="#3-Strings-Versus-Characters" class="headerlink" title="(3) Strings Versus Characters"></a>(3) Strings Versus Characters</h2><p><img src="https://img-blog.csdnimg.cn/201905212249433.png" srcset="/img/loading.gif" alt="A word is the natural unit of memory for a given computer design.For 8-bit microcomputers,"></p><h1 id="2-The-strlen-Function"><a href="#2-The-strlen-Function" class="headerlink" title="2. The strlen() Function"></a>2. The strlen() Function</h1><p>The <strong>strlen()</strong> function gives the length of a string in characters.<br>The <strong>string.h</strong> file contains function prototypes for several string related functions, including <strong>strlen()</strong>.<br>&nbsp;<br>The <strong>strlen()</strong> gives you the exact number of characters (including spaces and punctuation) in the string. The <strong>sizeof</strong> operator gives you a number one <strong>larger</strong> because it also counts the <strong>invisible null character</strong> used to end the string.<br>&nbsp;<br>The <strong>C99</strong> and <strong>C11</strong> standards use a <strong>%zd</strong> specifier for the type used by the <strong>sizeof</strong> operator. This also applies for type returned by <strong>strlen()</strong>.<br>&nbsp;<br>The preceding chapter used <strong>sizeof</strong> with <strong>parentheses</strong>, but this example doesn’t. <strong>Parentheses</strong> are <strong>required for types</strong> but are <strong>optional for particular quantities</strong>. That is, you would use <strong>sizeof(char)</strong> or <strong>sizeof(float)</strong> but can use <strong>sizeof name</strong> or <strong>sizeof 6.28.</strong></p><h1 id="3-Constants-and-the-C-Preprocessor"><a href="#3-Constants-and-the-C-Preprocessor" class="headerlink" title="3. Constants and the C Preprocessor"></a>3. Constants and the C Preprocessor</h1><p>The <strong>preprocessor</strong> uses <strong>#include</strong> to incorporate information from another file, it also lets you define constants. Just add a line like the following at the top of the file containing your program:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TAXRATE 0.015</span></code></pre><p><strong>No semicolon</strong> is used because this is a substitution mechanism handled by the <strong>preprocessor</strong>, not a <strong>C</strong> statement.</p><h1 id="4-The-const-Modifier"><a href="#4-The-const-Modifier" class="headerlink" title="4. The const Modifier"></a>4. The const Modifier</h1><p><strong>C90</strong> added a second way to <strong>create symbolic constants</strong>—using the <strong>const</strong> keyword to convert a declaration for a <strong>variable</strong> into a declaration for a <strong>constant</strong>:</p><pre><code class="hljs c"><span class="hljs-comment">// MONTHS a symbolic constant for 12</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MONTHS = <span class="hljs-number">12</span>;</code></pre><p>This newer approach is more flexible than using <strong>#define</strong>; it lets you declare a type, and it allows better control over which parts of a program can use the constant.</p><h1 id="5-Manifest-Constants-on-the-Job"><a href="#5-Manifest-Constants-on-the-Job" class="headerlink" title="5. Manifest Constants on the Job"></a>5. Manifest Constants on the Job</h1><p>The C header files <strong>limits.h</strong> and <strong>float.h</strong> supply detailed information about the <strong>size limits</strong> of <strong>integer</strong> types and <strong>floating</strong> types, respectively. </p><h1 id="6-The-printf-Function"><a href="#6-The-printf-Function" class="headerlink" title="6. The printf() Function"></a>6. The printf() Function</h1><p>The instructions you give <strong>printf()</strong> when you ask it to print a variable depend on the variable type. </p><table><thead><tr><th align="left">Conversion</th><th align="left">Output Specification</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">Floating-point-number, hexadecimal digits and p-notation(C99/C11).</td></tr><tr><td align="left">%A</td><td align="left">Floating-point-number, hexadecimal digits and p-notation(C99/C11).</td></tr><tr><td align="left">%c</td><td align="left">Single character.</td></tr><tr><td align="left">%d</td><td align="left">Single decimal integer.</td></tr><tr><td align="left">%e</td><td align="left">Floating-point number, e-notation.</td></tr><tr><td align="left">%E</td><td align="left">Floating-point number, e-notation.</td></tr><tr><td align="left">%f</td><td align="left">Floating-point number, decimal notation.</td></tr><tr><td align="left">%g</td><td align="left">Using %f or %e, depending on the value. The %e style is used if the exponent is less than -4 or greater than or equal to the presion.</td></tr><tr><td align="left">%G</td><td align="left">Using %f or %E, depending on the value. The %E style is used if the exponent is less than -4 or greater than or equal to the presion.</td></tr><tr><td align="left">%i</td><td align="left">Single decimal integer(same as %d).</td></tr><tr><td align="left">%o</td><td align="left">Unsigned octal integer.</td></tr><tr><td align="left">%p</td><td align="left">A pointer.</td></tr><tr><td align="left">%s</td><td align="left">Character string.</td></tr><tr><td align="left">%u</td><td align="left">Unsigned decimal integer.</td></tr><tr><td align="left">%x</td><td align="left">Unsigned hexadecimal integer, using hex digits 0f.</td></tr><tr><td align="left">%X</td><td align="left">Unsigned hexadecimal integer, using hex digits 0F.</td></tr><tr><td align="left">%%</td><td align="left">Prints a percent sign.</td></tr></tbody></table><h2 id="1-Conversion-Specification-Modifiers-for-printf"><a href="#1-Conversion-Specification-Modifiers-for-printf" class="headerlink" title="(1) Conversion Specification Modifiers for printf()"></a>(1) Conversion Specification Modifiers for printf()</h2><table><thead><tr><th align="left">Modifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">flag</td><td align="left">Five flags:-,+,space,#, and 0.</td></tr><tr><td align="left">digit(s)</td><td align="left">The minimun field width. A wilder field will be used if the printed number or string won’t fit in the field.</td></tr><tr><td align="left">.digit(s)</td><td align="left">Presions. For %e, %E, and %f conversions, the maximun number of significant digits. For %g and %G conversions, the maximun number of significant digits. For %s conversion, the maximun number of characters to be printed. For integer conversions, the minimun number of digits to apper: leading zeros are used if necessary to meet this minimum. Using only . implies a following zero, so %.f is the same as %.0f.</td></tr><tr><td align="left">h</td><td align="left">Used with an integer conversion specifier to indicate a short int or unsigned short int value.</td></tr><tr><td align="left">hh</td><td align="left">Used with an integer conversion specifier to indicate a signed char or unsigned char value.</td></tr><tr><td align="left">j</td><td align="left">Used with an integer conversion specifier to indicate an intmax_t or uintmax_t value; these are types defined in stdint.h.</td></tr><tr><td align="left">l</td><td align="left">Used with an integer conversion specifier to indicate a long int or unsigned long int.</td></tr><tr><td align="left">ll</td><td align="left">Used with an integer conversion specifier to indicate a long long int or unsigned long long int.(C99).</td></tr><tr><td align="left">L</td><td align="left">Used with a floating-point conversion specifier to indicate a long double value.</td></tr><tr><td align="left">t</td><td align="left">Used with an integer conversion specifier to indicate a ptrdiff_t value. This is the type corresponding to the difference between two pointers. (C99).</td></tr><tr><td align="left">z</td><td align="left">Used with an integer conversion specifier to indicate a size_t value. This is the type returned by sizeof. (C99).</td></tr></tbody></table><h2 id="2-The-printf-Flags"><a href="#2-The-printf-Flags" class="headerlink" title="(2) The printf( ) Flags"></a>(2) The printf( ) Flags</h2><table><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">The item is left-justified; that is, it is printed begining at the left of the field.</td></tr><tr><td align="left">+</td><td align="left">Signed values are displayed with a plus sign, if positive, and with a minus sign, if negative.</td></tr><tr><td align="left">space</td><td align="left">Signed values are displayed with a  leading space (but no sign) if positive and with a minus sign if negative. A + flag overrides a space.</td></tr><tr><td align="left">#</td><td align="left">Used  an alternative form for the conversion specification. Produces an initial 0 for the %o form and initial 0x for the %x or %X form, respectively. For all floating-point forms, # gurantees that a decimal-point character is printed, even if no digits follow. For %g and %G forms, it prevents traing zeros form being removed.</td></tr><tr><td align="left">0</td><td align="left">For numeric forms, pad the field width with leading zeros indtead of with spaces. This flag is ignored if a - flag is present or if, for an integer form, a precision is specified.</td></tr></tbody></table><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">float</span> f = <span class="hljs-number">321454.321345</span>;   <span class="hljs-keyword">float</span> f1 = <span class="hljs-number">12.2345678</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %04f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %06.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %6.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2.3 = %-6.2f\n"</span>,<span class="hljs-number">2.3</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"321454.321345 = %7f\n"</span>,f);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"321454.321345 = %7.3f\n"</span>,f);    <span class="hljs-keyword">int</span> n1 = <span class="hljs-number">3456</span>;  <span class="hljs-keyword">int</span> n2  = <span class="hljs-number">1</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3456 = %3.2d\n"</span>,n1);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3456 = %6.2d\n\n"</span>,n1);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 = %.4d\n"</span>,n2);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 = %3.2d\n\n"</span>,n2);    <span class="hljs-comment">//测试字符串宽度精度</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %9.3s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %9s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\"printf\" = %3s\n"</span>,<span class="hljs-string">"printf"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Output：</p><pre><code class="hljs c"><span class="hljs-number">2.3</span> = <span class="hljs-number">2.300000</span> <span class="hljs-comment">//%04f：输出宽度至少4，精度不限制时用默认的，浮点数默认精度6位，这里宽度指总的宽度（包括小数点和小数点后面的数）</span><span class="hljs-number">2.3</span> = <span class="hljs-number">002.30</span> <span class="hljs-comment">//%06.2f： 总共宽度至少6位，精度2位，因此左边补0</span><span class="hljs-number">2.3</span> =   <span class="hljs-number">2.30</span> <span class="hljs-comment">//%6.2f：总共宽度至少6位，精度2位，左边空两格，默认右对齐</span><span class="hljs-number">2.3</span> = <span class="hljs-number">2.30</span> <span class="hljs-comment">// %-6.2f：总共宽度至少6位，精度2位，右边空两格，加-号左对齐</span><span class="hljs-number">321454.321345</span> = <span class="hljs-number">321454.312500</span><span class="hljs-number">321454.321345</span> = <span class="hljs-number">321454.312</span><span class="hljs-number">3456</span> = <span class="hljs-number">3456</span>  <span class="hljs-comment">//%3.2d ，总宽度至少3</span><span class="hljs-number">3456</span> =   <span class="hljs-number">3456</span>  <span class="hljs-comment">//%6.2d ，总宽度至少6</span><span class="hljs-number">1</span> = <span class="hljs-number">0001</span> <span class="hljs-comment">//%.4d 有效位4位，只有1位，其余补0</span><span class="hljs-number">1</span> =  <span class="hljs-number">01</span>  <span class="hljs-comment">//%3.2d 总宽度3，有效位2，因此左边空1格，补一个0</span><span class="hljs-string">"printf"</span> =        pri <span class="hljs-comment">// %9.3s 总宽度至少9，有效3位，因此只现实3个字符</span><span class="hljs-string">"printf"</span> =    <span class="hljs-built_in">printf</span>  <span class="hljs-comment">// %9s，总宽度至少9，宽度9</span><span class="hljs-string">"printf"</span> = <span class="hljs-built_in">printf</span>   <span class="hljs-comment">// %3s，总宽度至少3，因此宽度为6</span></code></pre><h2 id="3-The-Return-Value-of-printf"><a href="#3-The-Return-Value-of-printf" class="headerlink" title="(3) The Return Value of printf()"></a>(3) The Return Value of printf()</h2><p>The <strong>printf()</strong> function also has a return value; it returns the <strong>number of characters</strong> it printed. </p><h2 id="4-Printing-Long-Strings"><a href="#4-Printing-Long-Strings" class="headerlink" title="(4) Printing Long Strings"></a>(4) Printing Long Strings</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's one way to print a "</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"long string.\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's another way to print a \</span><span class="hljs-string">long string.\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here's the newest way to print a "</span><span class="hljs-string">"long string.\n"</span>); <span class="hljs-comment">/* ANSI C */</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Method 1 is to use more than one <strong>printf()</strong> statement.<br>Method 2 is to terminate the end of the first line with a backslash/return combination.<br>Method 3, which ANSI C introduced, is <strong>string concatenation</strong>. If you follow one <strong>quoted</strong> string constant with another, separated only by <strong>whitespace</strong>, C treats the combination as a <strong>single string</strong>. </p><h1 id="7-scanf"><a href="#7-scanf" class="headerlink" title="7. scanf()"></a>7. scanf()</h1><p>It converts string input into various forms: integers, floating-point numbers, characters, and C strings.<br>&nbsp;<br>Rules:</p><blockquote><ul><li>If you use <strong>scanf()</strong> to read a value for one of the basic variable types, precede the variable name with an <strong>&amp;</strong>.</li><li>If you use <strong>scanf()</strong> to read a string into a <strong>character array</strong>, don’t use an <strong>&amp;</strong>.</li></ul></blockquote><h2 id="1-Conversion-Specifiers-for-scanf"><a href="#1-Conversion-Specifiers-for-scanf" class="headerlink" title="(1) Conversion Specifiers for scanf()"></a>(1) Conversion Specifiers for scanf()</h2><p>The <strong>scanf()</strong> function uses pretty much the same set of conversion specification characters as <strong>printf()</strong> does. The main difference is that <strong>printf()</strong> uses %f, %e, %E, %g, and %G for both type float and type double, whereas <strong>scanf()</strong> uses them just for type float, requiring the <strong>l</strong> modifier for double. </p><table><thead><tr><th align="left">Conversion Specifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">%c</td><td align="left">Interpret input as a character.</td></tr><tr><td align="left">%d</td><td align="left">Interpret input as a signed decimal integer.</td></tr><tr><td align="left">%e, %f, %g, %a</td><td align="left">Interpret input as a floating-point number (%a is C99).</td></tr><tr><td align="left">%E, %F, %G, %A</td><td align="left">Interpret input as a floating-point number (%A is C99).</td></tr><tr><td align="left">%i</td><td align="left">Interpret input as a signed decimal integer.</td></tr><tr><td align="left">%o</td><td align="left">Interpret input as a signed Octal integer.</td></tr><tr><td align="left">%p</td><td align="left">Intepret input as a pointer (an address).</td></tr><tr><td align="left">%s</td><td align="left">Intepret input as a string. Input begins with the first non-whitespace character and includes evertything up to the next whitespace character.</td></tr><tr><td align="left">%u</td><td align="left">Interpret input as a unsigned decimal integer.</td></tr><tr><td align="left">%x, %X</td><td align="left">Interpret input as a signed hexadecimal integer.</td></tr></tbody></table><h2 id="2-Conversion-Modifiers-for-scanf"><a href="#2-Conversion-Modifiers-for-scanf" class="headerlink" title="(2) Conversion Modifiers for scanf()"></a>(2) Conversion Modifiers for scanf()</h2><table><thead><tr><th align="left">Modifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">Suppress assignment.</td></tr><tr><td align="left">digit(s)</td><td align="left">Maximum field width. Input stops when the maximum field width is reached or when the first whitespace character is encountered, whichever comes first.</td></tr><tr><td align="left">hh</td><td align="left">Read an integer as a signed char or unsigned char.</td></tr><tr><td align="left">ll</td><td align="left">Read an integer as a long long or unsigned long long (C99).</td></tr><tr><td align="left">h, l or L</td><td align="left">“%hd” and “%hi” indicate that the value will be stored in a <strong>short int</strong>. “%ho”, “%hx”, and “%hu” indicate that the value will be stored in an <strong>unsigned short int</strong>. “%ld” and “%li” indicate that the value will be stored in a <strong>long</strong>. “%lo”, “%lx”, and “%lu” indicate that the value will be stored in <strong>unsigned long</strong>. “%le”, “%lf”, and “%lg” indicate that the value will be stored in type <strong>double</strong>. Using L instead of l with e, f, and g indicates that the value will be stored in type <strong>long double</strong>. In the absence of these modifiers, d, i, o, and x indicate type <strong>int</strong>, and e, f, and g indicate type <strong>float</strong>.</td></tr><tr><td align="left">j</td><td align="left">When followed by an integer specifier, indicates using the intmax_t or uintmax_t type (C99).</td></tr><tr><td align="left">z</td><td align="left">When followed by an integer specifier, indicates using the type returned by sizeof (C99).</td></tr><tr><td align="left">t</td><td align="left">When followed by an integer specifier, indicates using the type used to represent the difference between two pointers (C99).</td></tr></tbody></table><h2 id="3-The-scanf-View-of-Input"><a href="#3-The-scanf-View-of-Input" class="headerlink" title="(3) The scanf() View of Input"></a>(3) The scanf() View of Input</h2><p>It skips over whitespace characters (spaces, tabs, and newlines) until it finds a non-whitespace character. scanf() continues reading and saving characters until it encounters a nondigit. </p><p>&nbsp;<br>If you use a <strong>%c</strong> specifier, all input characters are fair game. If the next input character is a space or a newline, a space or a newline is assigned to the indicated variable; <strong>whitespace is not skipped</strong>.</p><h2 id="4-The-scanf-Return-Value"><a href="#4-The-scanf-Return-Value" class="headerlink" title="(4) The scanf() Return Value"></a>(4) The scanf() Return Value</h2><p>The <strong>scanf()</strong> function returns <strong>the number of items</strong> that it successfully reads. If it reads no items, which happens if you type a nonnumeric string when it expects a number, <strong>scanf()</strong> returns the value 0. It returns <strong>EOF</strong> when it detects the condition known as “end of file.” </p><h1 id="8-The-Modifier-with-printf-and-scanf"><a href="#8-The-Modifier-with-printf-and-scanf" class="headerlink" title="8. The * Modifier with printf() and scanf()"></a>8. The * Modifier with printf() and scanf()</h1><h2 id="1-The-Modifier-with-printf"><a href="#1-The-Modifier-with-printf" class="headerlink" title="(1) The * Modifier with printf()"></a>(1) The * Modifier with printf()</h2><p>Suppose that you don’t want to commit yourself to a field width in advance but rather you want the program to specify it. You can do this by using <code>*</code> instead of a number for the field width, but you also have to add an argument to tell what the field width should be.<br>&nbsp;<br>That is, if you have the conversion specifier <code>%*d</code>, the argument list should include a value for <code>*</code> and a value for <code>d</code>. </p><h2 id="2-The-Modifier-with-scanf"><a href="#2-The-Modifier-with-scanf" class="headerlink" title="(2) The * Modifier with scanf()"></a>(2) The * Modifier with scanf()</h2><p>The <code>*</code> serves quite a different purpose for <strong>scanf()</strong>. When placed between the <code>%</code> and the specifier letter, it causes that function to <strong>skip over corresponding input</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data and C</title>
    <link href="/2020/11/24/Data-and-C/"/>
    <url>/2020/11/24/Data-and-C/</url>
    
    <content type="html"><![CDATA[<p>C Primer Plus (Sixth Edition) Chapter 3 Data and C</p><a id="more"></a><h1 id="1-Bits-Bytes-and-Words"><a href="#1-Bits-Bytes-and-Words" class="headerlink" title="1. Bits, Bytes, and Words"></a>1. Bits, Bytes, and Words</h1><h2 id="1-Bit"><a href="#1-Bit" class="headerlink" title="(1) Bit"></a>(1) Bit</h2><p>The smallest unit of memory is called a <strong>bit</strong>. It can hold one of two values: 0 or 1.</p><h2 id="2-Byte"><a href="#2-Byte" class="headerlink" title="(2) Byte"></a>(2) Byte</h2><p><strong>byte</strong> is the usual unit of computer memory. For nearly all machines, a byte is 8 bits, and that is the standard definition, at least when used to measure storage.<br>&nbsp;<br>Because each bit can be either 0 or 1, there are 256 (that’s 2 times itself 8 times) possible bit patterns of 0s and 1s that can fit in an 8-bit byte.</p><h2 id="3-Word"><a href="#3-Word" class="headerlink" title="(3) Word"></a>(3) Word</h2><p>A <strong>word</strong> is the natural unit of memory for a given computer design.<br>&nbsp;<br>For 8-bit microcomputers, such as the original Apples, a word is just 8 bits. Since then, personal computers moved up to 16-bit words, 32-bit words, and, at the present, 64-bit words. Larger word sizes enable faster transfer of data and allow more memory to be accessed.</p><h1 id="2-Integer-Versus-Floating-Point-Types"><a href="#2-Integer-Versus-Floating-Point-Types" class="headerlink" title="2. Integer Versus Floating-Point Types"></a>2. Integer Versus Floating-Point Types</h1><h2 id="1-The-Integer"><a href="#1-The-Integer" class="headerlink" title="(1) The Integer"></a>(1) The Integer</h2><p>An <strong>integer</strong> is a number with no fractional part.</p><h2 id="2-The-Floating-Point-Number"><a href="#2-The-Floating-Point-Number" class="headerlink" title="(2) The Floating-Point Number"></a>(2) The Floating-Point Number</h2><p>A <strong>floating-point</strong> number more or less corresponds to what mathematicians call a real number.<br>&nbsp;<br>The key point here is that the scheme used to store a floating-point number is different from the one used to store an integer. <strong>Floating-point representation involves breaking up a number into a fractional part and an exponent part and storing the parts separately</strong>.<br>&nbsp;<br>For some arithmetic operations, such as subtracting one large number from another, floating-point numbers are subject to greater <strong>loss of precision</strong>. Because there is an infinite number of real numbers in any range，For example, 7.0 might be stored as a 6.99999 float value.</p><h1 id="3-Basic-C-Data-Types"><a href="#3-Basic-C-Data-Types" class="headerlink" title="3. Basic C Data Types"></a>3. Basic C Data Types</h1><h2 id="1-The-int-Type"><a href="#1-The-int-Type" class="headerlink" title="(1) The int Type"></a>(1) The int Type</h2><p>The <strong>int</strong> type is a signed integer. That means it must be an integer and it can be positive, negative, or zero.</p><h3 id="Octal-and-Hexadecimal"><a href="#Octal-and-Hexadecimal" class="headerlink" title="Octal and Hexadecimal"></a>Octal and Hexadecimal</h3><p>A prefix of <strong>0x</strong> or <strong>0X</strong> (zero-ex) means that you are specifying a <strong>hexadecimal</strong> value, so 16 is written as 0x10, or 0X10.<br>&nbsp;<br>A <strong>0</strong> (zero) prefix means that you are writing in <strong>octal</strong>. For example, the decimal value 16 is written as 020 in <strong>octal</strong>.</p><h3 id="Other-Integer-Types"><a href="#Other-Integer-Types" class="headerlink" title="Other Integer Types"></a>Other Integer Types</h3><p>C offers three adjective keywords to modify the basic integer type: <strong>short</strong>, <strong>long</strong>, and <strong>unsigned</strong>.<br>&nbsp;<br>To cause a small constant to be treated as type long, you can append an <strong>l</strong> (lowercase <strong>L</strong>) or <strong>L</strong> as a <strong>suffix</strong>. </p><p>Add a <strong>u</strong> or <strong>U</strong> to the <strong>suffix</strong> for <strong>unsigned long long</strong>, as in <code>5ull</code> or <code>10LLU</code> .<br>&nbsp;<br>Note that the <strong>short</strong> variable end is displayed the same whether you tell <strong>printf()</strong> that end is a <strong>short</strong> (the <strong>%hd</strong> specifier) or an <strong>int</strong> (the <strong>%d</strong> specifier). </p><p><strong>That’s because C automatically expands a type short value to a type int value when it’s passed as an argument to a function</strong>.</p><p><strong>The int type is intended to be the integer size that the computer handles most efficiently</strong>.</p><h2 id="2-Using-Characters-Type-char"><a href="#2-Using-Characters-Type-char" class="headerlink" title="(2) Using Characters: Type char"></a>(2) Using Characters: Type char</h2><p>The <strong>char</strong> type is used for storing characters such as <strong>letters</strong> and <strong>punctuation marks</strong>, but technically it is an <strong>integer</strong> type.<br>&nbsp;<br>To handle characters, the computer uses a <strong>numerical code</strong> in which certain integers represent certain characters. </p><p>The most commonly used code in the U.S. is the <code>ASCII</code> code.<br>&nbsp;<br>The standard <code>ASCII</code> code runs numerically from 0 to 127. This range is small enough that 7 bits can hold it. The char type is typically defined as an 8-bit unit of memory.<br>&nbsp;<br><strong>Character Constants and Initialization</strong>：A single character contained between single quotes is a C character constant.<br>&nbsp;<br>Because characters are really stored as numeric values, you can also use the numerical code to assign values:</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> grade = <span class="hljs-number">65</span>; <span class="hljs-comment">/* ok for ASCII, but poor style */</span></code></pre><p>Because 65 is the <code>ASCII</code> code for the letter <code>A</code>, this example assigns the value <code>A</code> to grade.<br>&nbsp;<br>C treats character constants as type <code>int</code> rather than type <code>char</code>. For example, on an <code>ASCII</code> system with a 32-bit int and an 8-bit char, the code.</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> grade = <span class="hljs-string">'B'</span>;</code></pre><p><strong>represents ‘B’ as the numerical value 66 stored in a 32-bit unit, but grade winds up with 66 stored in an 8-bit unit.</strong> </p><p>This characteristic of character constants makes it possible to define a character constant such as <code>&#39;FATE&#39;</code>, with four separate 8-bit <code>ASCII</code> codes stored in a 32-bit unit.</p><p>However, attempting to assign such a character constant to a char variable results in only the <strong>last 8 bits</strong> being used, so the variable gets the value <code>&#39;E&#39;</code>.</p><p><strong>Nonprinting Characters</strong><br>The first way we have already mentioned—just use the <code>ASCII</code> code.<br>&nbsp;<br>The second way to represent certain awkward characters in C is to use special symbol sequences. These are called <strong>escape sequences</strong>. </p><table><thead><tr><th align="left">Sequence</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">\a</td><td align="left">Aleart(ANSI C)</td></tr><tr><td align="left">\b</td><td align="left">Backspace</td></tr><tr><td align="left">\f</td><td align="left">Form feed</td></tr><tr><td align="left">\n</td><td align="left">Newline</td></tr><tr><td align="left">\r</td><td align="left">Carrigae return</td></tr><tr><td align="left">\t</td><td align="left">Horizontal tab</td></tr><tr><td align="left">\v</td><td align="left">Vertical tab</td></tr><tr><td align="left">\</td><td align="left">Backslash()</td></tr><tr><td align="left">&#39;</td><td align="left">Single quote(‘)</td></tr><tr><td align="left">&quot;</td><td align="left">Double quote(“)</td></tr><tr><td align="left">?</td><td align="left">Question mark(?)</td></tr><tr><td align="left">\0oo</td><td align="left">Octal value (o represents an octal digit.)</td></tr><tr><td align="left">\0hh</td><td align="left">Hexadecimal value (h represents a hexadecimal digit.)</td></tr></tbody></table><p>To represent alert character (<code>\a</code>), you could use the <code>ASCII</code> code instead: <code>&#39;007&#39;</code>. You can omit the leading zeros, so <code>&#39;\07&#39;</code> or even <code>&#39;\7&#39;</code>will do. This notation causes numbers to be interpreted as octal, even if there is no initial 0.</p><p><strong>Note:</strong> When a character, be it an <strong>escape sequence or not</strong>, is part of a string of characters enclosed in double quotes, <strong>don’t enclose it in single quotes</strong>.</p><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello!\007\n"</span>);</code></pre><p>will print </p><pre><code class="hljs c">Hello! <span class="hljs-keyword">and</span> <span class="hljs-built_in">beep</span></code></pre><h2 id="3-The-Bool-Type"><a href="#3-The-Bool-Type" class="headerlink" title="(3) The _Bool Type"></a>(3) The _Bool Type</h2><p>C uses the value $1$ for <strong>true</strong> and $0$ for <strong>false</strong>, the <strong>_Bool</strong> type really is just an <strong>integer</strong> type, but one that, in principle, only requires 1 bit of memory, because that is enough to cover the full range from $0$ to $1$.</p><h2 id="4-Portable-Types-stdint-h-and-inttypes-h"><a href="#4-Portable-Types-stdint-h-and-inttypes-h" class="headerlink" title="(4) Portable Types: stdint.h and inttypes.h"></a>(4) Portable Types: stdint.h and inttypes.h</h2><p>The same type name doesn’t necessarily mean the same thing on different systems, What C has done is create more names for the existing types. The trick is to define these new names in a header file called <strong>stdint.h</strong>. </p><p>For example, <code>int32_t</code> represents the type for a <strong>32-bit signed integer</strong>. The header file on a system that uses a 32-bit int could define <code>int32_t</code> as an <strong>alias for int</strong>. A different system, one with a 16-bit int and a 32-bit long, could define the same name, <code>int32_t</code>, as an <strong>alias for int</strong>. </p><h2 id="5-Types-float-double-and-long-double"><a href="#5-Types-float-double-and-long-double" class="headerlink" title="(5) Types float, double, and long double"></a>(5) Types float, double, and long double</h2><p>Here are two <strong>valid floating-point constants</strong>:</p><pre><code class="hljs angelscript"><span class="hljs-number">-1.56E+12</span><span class="hljs-number">3.14159</span><span class="hljs-number">.2</span><span class="hljs-number">4e16</span><span class="hljs-number">.8E-5</span><span class="hljs-number">100.</span></code></pre><p><strong>Rules:</strong></p><ul><li>You can leave out positive signs. </li><li>You can do without a <strong>decimal point</strong> (2E5) or an <strong>exponential part</strong> (19.28), but <strong>not both simultaneously</strong>. </li><li>You can <strong>omit a fractional part</strong> (3.E16) or <strong>an integer<br>part</strong> (.45E–6), but <strong>not both</strong> (that wouldn’t leave much!). </li><li>Don’t use spaces in a floating-point constant.</li></ul><p>By default, the compiler assumes <strong>floating-point constants</strong> are <strong>double</strong> precision.</p><p>C enables you to <strong>override</strong> this default by using an <strong>f</strong> or <strong>F</strong> <strong>suffix</strong> to make the compiler treat a <strong>floating-point</strong> constant as type <strong>float</strong>; examples are <code>2.3f</code> and <code>9.11E9F</code>. </p><p>An <strong>l</strong> or <strong>L</strong> <strong>suffix</strong> makes a number type <strong>long double</strong>; examples are <code>54.3l</code> and <code>4.32e4L</code>. </p><p>If the floating-point number has <strong>no suffix</strong>, it is type <strong>double</strong>.</p><h1 id="4-Format-Specifier"><a href="#4-Format-Specifier" class="headerlink" title="4. Format Specifier"></a>4. Format Specifier</h1><p>It indicates the form that <strong>printf()</strong> uses to display a value.</p><h2 id="1-d"><a href="#1-d" class="headerlink" title="(1) %d"></a>(1) %d</h2><p><strong>%d</strong> notation is used to indicate just where in a line the <strong>integer</strong> is to be printed.  <strong>d means decimal</strong><br>&nbsp;<br>Each <strong>%d</strong> in the format string must be matched by a corresponding <strong>int</strong> value in the list of items to be printed. </p><h2 id="2-Printing-short-long-long-long-and-unsigned-Types"><a href="#2-Printing-short-long-long-long-and-unsigned-Types" class="headerlink" title="(2) Printing short, long, long long, and unsigned Types"></a>(2) Printing short, long, long long, and unsigned Types</h2><p>To print an <strong>unsigned int</strong> number, use the <strong>%u</strong> notation. To print a <strong>long</strong> value, use the <strong>%ld</strong> format specifier.<br>&nbsp;<br>Note that although C allows both <strong>uppercase</strong> and <strong>lowercase</strong> letters for <strong>constant suffixes</strong>, these format specifiers use just <strong>lowercase</strong>.<br>&nbsp;<br>C has several additional <strong>printf()</strong> formats. First, you can use an <strong>h</strong> <strong>prefix</strong> for <strong>short</strong> types. Therefore, <strong>%hd</strong> displays a <strong>short integer</strong> in <strong>decimal</strong> form, and <strong>%ho</strong> displays a <strong>short integer in octal form</strong>. Both the <strong>h</strong> and <strong>l</strong> <strong>prefixes</strong> can be used with <strong>u</strong> for <strong>unsigned</strong> types. </p><h2 id="3-c"><a href="#3-c" class="headerlink" title="(3) %c"></a>(3) %c</h2><p>The <strong>printf()</strong> function uses <strong>%c</strong> to indicate that a <strong>character</strong> should be printed. </p><h2 id="4-Printing-Floating-Point-Values"><a href="#4-Printing-Floating-Point-Values" class="headerlink" title="(4) Printing Floating-Point Values"></a>(4) Printing Floating-Point Values</h2><p>The <strong>printf()</strong> function uses the <strong>%f</strong> format specifier to print type <strong>float</strong> and <strong>double</strong> numbers using <strong>decimal</strong> notation, and it uses <strong>%e</strong> to print them in <strong>exponential</strong> notation. </p><table><thead><tr><th align="left">Format</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">%f</td><td align="left"><strong>decimal</strong> notation(float, double)</td></tr><tr><td align="left">%e</td><td align="left"><strong>exponential</strong> notation(float, double)</td></tr><tr><td align="left">%a, %A</td><td align="left"><strong>hexadecimal p</strong> notation(float,double)</td></tr><tr><td align="left">%Lf, %Le, %La</td><td align="left"><strong>decimal</strong>, <strong>exponential</strong>, <strong>hexadecimal p</strong> notation(long double)</td></tr></tbody></table><h1 id="5-Type-Sizes"><a href="#5-Type-Sizes" class="headerlink" title="5. Type Sizes"></a>5. Type Sizes</h1><p>What type sizes does your system use?</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type int has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type char has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Type long has a size of %zd bytes.\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>));&#125;<span class="hljs-comment">//C has a built-in operator called sizeof that gives sizes in bytes. C99 and C11 provide a %zd specifier for this type used by sizeof.</span></code></pre><p>answer</p><pre><code class="hljs routeros">Type int has a size of 4 bytes.Type char has a size of 1 bytes.Type long has a size of 8 bytes.</code></pre>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>C Primer Plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
