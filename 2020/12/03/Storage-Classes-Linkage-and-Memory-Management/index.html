

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/groot.png">
  <link rel="icon" type="image/png" href="/img/groot.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="诗酒趁年华">
  <meta name="author" content="李诩">
  <meta name="keywords" content="编程, 阅读, 音乐, 生活">
  <title>Storage Classes, Linkage, and Memory Management - CD_LX</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Carpe Diem</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/Storage-Classes-Linkage-and-Memory-Management_Inner.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-03 20:16" pubdate>
        December 3, 2020 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      66
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Storage Classes, Linkage, and Memory Management</h1>
            
            <div class="markdown-body" id="post-body">
              <p>C Primer Plus (Sixth Edition) Chapter 12 Storage Classes, Linkage, and Memory Management<a id="more"></a></p>
<h1 id="1-Storage-Classes"><a href="#1-Storage-Classes" class="headerlink" title="1. Storage Classes"></a>1. Storage Classes</h1><h2 id="1-Scope"><a href="#1-Scope" class="headerlink" title="(1) Scope"></a>(1) Scope</h2><p><strong>Scope</strong> describes the <strong>region or regions</strong> of a program that can access an identifier. </p>
<p>A C variable has one of the following scopes: <strong>block scope</strong>, <strong>function scope</strong>, <strong>function prototype scope</strong>, or <strong>file scope</strong>. </p>
<h3 id="Block-scope"><a href="#Block-scope" class="headerlink" title="Block scope"></a>Block scope</h3><p> A <strong>block</strong>  is a region of code contained within an <strong>opening brace and the matching closing brace</strong>. </p>
<p>A variable defined inside a block has <strong>block scope</strong>, and it is visible from the point it is defined until the end of the block containing the definition. </p>
<p>Also, <strong>formal function parameters</strong>, even though they occur before the opening brace of a function, have <strong>block scope</strong> and belong to the block containing the function body. </p>
<h3 id="Function-scope"><a href="#Function-scope" class="headerlink" title="Function scope"></a>Function scope</h3><p><strong>Function scope</strong> applies just to <strong>labels</strong> used with <strong>goto statements</strong>. This means that even if a <strong>label</strong> first appears inside an inner block in a function, its scope extends to the whole function. </p>
<h3 id="Function-prototype-scope"><a href="#Function-prototype-scope" class="headerlink" title="Function prototype scope"></a>Function prototype scope</h3><p><strong>Function prototype scope</strong> runs from the point the variable is defined to the end of the prototype declaration. </p>
<p>What this means is that all the compiler cares about when handling a function prototype argument is the <strong>types</strong>; the names you use, if any, normally don’t matter, and they needn’t match the names you use in the function definition. </p>
<h3 id="File-scope"><a href="#File-scope" class="headerlink" title="File scope"></a>File scope</h3><p>A variable with its definition placed outside of any function has <strong>file scope</strong>. A variable with file scope is visible from the point it is defined to the end of the file containing the definition. <strong>File scope</strong> variables are also called <strong>global variables</strong>.</p>
<p><strong>Translation Units and Files:</strong><br>What you view as <strong>several files</strong> may appear to the compiler as <strong>a single file</strong>. </p>
<p>For example, suppose that, as often is the case, you include one or more <strong>header files</strong> in a source code file. A header file, in turn, may include other header files. So several separate physical files may be involved. </p>
<p>However, C preprocessing essentially replaces an <code>#include</code> directive with the contents of the header file. Thus the compiler sees <strong>a single file</strong> containing information from your <strong>source code file and all the header files</strong>. </p>
<p>This single file is called a <strong>translation unit</strong>. When we describe a variable as having file scope, it’s actually visible to the whole <strong>translation unit</strong>. If your program consists of several source code files, then it will consist of several translation units, with each translation unit corresponding to a source code file and its included files.</p>
<h2 id="2-Linkage"><a href="#2-Linkage" class="headerlink" title="(2) Linkage"></a>(2) Linkage</h2><p>A C variable has one of the following <strong>linkages</strong>: <strong>external linkage</strong>, <strong>internal linkage</strong>, or <strong>no linkage</strong>. </p>
<p>Variables with <strong>block scope</strong>, <strong>function scope</strong>, or <strong>function prototype scope</strong> have <strong>no linkage</strong>. That means they are <strong>private</strong> to the block, function, or prototype in which they are defined. </p>
<p>A variable with <strong>file scope</strong> can have <strong>either internal or external linkage</strong>.</p>
<p>A variable with <strong>external linkage</strong> can be used anywhere in a <strong>multifile program</strong>. </p>
<p>A variable with <strong>internal linkage</strong> can be used anywhere in a <strong>single translation unit</strong>.</p>
<p>The C Standard uses “<strong>file scope with internal linkage</strong>“ to describe <strong>scope limited to one translation unit</strong> (a source code file plus its included header files) and “<strong>file scope with external linkage</strong>“ to describe scope that, at least potentially, extends to <strong>other translation units</strong>. </p>
<p>Some common <strong>short cuts</strong> are to use “<strong>file scop</strong>“ for “<strong>file scope with internal linkag</strong>“ and “<strong>global scope</strong>“ or “<strong>program scope</strong>“ for “<strong>file scope with external linkage</strong>“.</p>
<p>So how can you tell whether a file scope variable has internal or external linkage? You look to see if the <strong>storage class specifier</strong> *<em>static *</em>is used in the external definition:</p>
<pre><code class="hljs c"><span class="hljs-keyword">int</span> giants = <span class="hljs-number">5</span>; <span class="hljs-comment">// file scope, external linkage</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> dodgers = <span class="hljs-number">3</span>; <span class="hljs-comment">// file scope, internal linkage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
...
&#125;</code></pre>
<h2 id="3-Storage-Duration"><a href="#3-Storage-Duration" class="headerlink" title="(3) Storage Duration"></a>(3) Storage Duration</h2><p><strong>Scope</strong> and <strong>linkage</strong> describe the <strong>visibility of identifiers</strong>. </p>
<p><strong>Storage duration</strong> describes the <strong>persistence of the objects</strong> accessed by these identifiers. </p>
<p>A C object has one of the following <strong>four storage durations</strong>: <strong>static storage duration</strong>, <strong>thread storage duration</strong>, <strong>automatic storage duration</strong>, or <strong>allocated storage duration</strong>.</p>
<p>If an object has <strong>static storage duration</strong>, it <strong>exists throughout program execution</strong>. </p>
<p>Variables with <strong>file scope</strong> have <strong>static storage duration</strong>. Note that for <strong>file scope</strong> variables, the keyword <strong>static</strong> indicates the <strong>linkage type</strong>, <strong>not the storage duration</strong>. </p>
<p>A <strong>file scope</strong> variable declared using <strong>static</strong> has <strong>internal linkage</strong>, but all <strong>file scope</strong> variables, using <strong>internal linkage</strong> or <strong>external linkage</strong>, have <strong>static storage duration</strong>.</p>
<p><strong>Thread storage duration</strong> comes into play in concurrent programming, in which program execution can be divided into <strong>multiple threads</strong>. </p>
<p>An object with <strong>thread storage duration</strong> exists from when it’s declared until the <strong>thread terminates</strong>. Such an object is created when a declaration that would otherwise create a <strong>file scope</strong> object is modified with the keyword <code>_Thread_local</code>. When a variable is declared with this specifier, each thread gets its own private copy of that variable.</p>
<p>Variables with <strong>block scope</strong> normally have <strong>automatic storage duration</strong>. </p>
<p>These variables have memory allocated for them when the program enters the block in which they are defined, and the memory is freed when the block is exited. </p>
<p>The idea is that <strong>memory</strong> used for automatic variables is a workspace or scratch pad that can be reused.</p>
<p><strong>Variable-length arrays</strong> provide a slight <strong>exception</strong> in that they exist from the point of declaration to the end of the block rather than from the beginning of the block to the end.</p>
<h2 id="4-Automatic-Variables"><a href="#4-Automatic-Variables" class="headerlink" title="(4) Automatic Variables"></a>(4) Automatic Variables</h2><p>A variable belonging to the <strong>automatic storage class</strong> has <strong>automatic storage duration</strong>, <strong>block scope</strong>, and <strong>no linkage</strong>. </p>
<p>By default, any variable declared in a <strong>block</strong> or <strong>function header</strong> belongs to the <strong>automatic storage class</strong>.</p>
<p>You can use the keyword <strong>auto</strong>, as shown here:</p>
<p>The keyword <strong>auto</strong> is termed a <strong>storage-class specifier</strong>. </p>
<p>Statements that are part of a <strong>loop</strong> or <strong>if *<em>statement qualify as a *</em>block</strong> even if braces (that is, { }) aren’t used. </p>
<p>Automatic variables are not initialized unless you do so explicitly.</p>
<h2 id="5-Register-Variables"><a href="#5-Register-Variables" class="headerlink" title="(5) Register Variables"></a>(5) Register Variables</h2><p>Variables are normally stored in computer memory. With luck, <strong>register variables</strong> are stored in the <strong>CPU registers</strong> or, more generally, in the <strong>fastest memory available</strong>, where they can be accessed and manipulated more <strong>rapidly</strong> than regular variables. </p>
<p>Because a <strong>register variable</strong> may be in a <strong>register</strong> rather than in <strong>memory</strong>, you <strong>can’t take the address of a register variable</strong>. </p>
<p>In most other respects, <strong>register variables</strong> are the same as <strong>automatic variables</strong>. That is, they have <strong>block scope</strong>, <strong>no linkage</strong>, and <strong>automatic storage duration</strong>. </p>
<p>Declaring a variable as a <strong>register class</strong> is more a <strong>request</strong> than a direct order. The compiler has to weigh your demands against the number of registers or amount of fast memory available, or it can simply ignore the request. In that case, the variable becomes an ordinary <strong>automatic variable</strong>; however, you still <strong>can’t use the address operator</strong> with it.</p>
<p>You can request that formal parameters be register variables. Just use the keyword in the function heading:</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">macho</span><span class="hljs-params">(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> n)</span></span></code></pre>
<h2 id="6-Static-Variables-with-Block-Scope"><a href="#6-Static-Variables-with-Block-Scope" class="headerlink" title="(6) Static Variables with Block Scope"></a>(6) Static Variables with Block Scope</h2><p><strong>Static</strong> means that the variable stays put in <strong>memory</strong>, not necessarily in value. </p>
<p>Variables with <strong>file scope</strong> automatically (and necessarily) have <strong>static storage duration</strong>. </p>
<p>You also can create <strong>local variables</strong> having <strong>block scope</strong> but <strong>static duration</strong>. These variables have the same <strong>scope</strong> as <strong>automatic variables</strong>, but they don’t vanish when the containing function ends its job.</p>
<p><strong>Static variables</strong> and <strong>external variables</strong> are already in place after a program is loaded into memory. </p>
<h2 id="7-Static-Variables-with-External-Linkage"><a href="#7-Static-Variables-with-External-Linkage" class="headerlink" title="(7) Static Variables with External Linkage"></a>(7) Static Variables with External Linkage</h2><p>A <strong>static variable</strong> with <strong>external linkage</strong> has <strong>file scope</strong>, <strong>external linkage</strong>, and <strong>static storage duration</strong>. </p>
<p>This class is sometimes termed the <strong>external storage class</strong>, and variables of this type are called <strong>external variables</strong>. </p>
<p>You create an <strong>external variable</strong> by placing a <strong>defining declaration outside of any function</strong>. As a matter of documentation, an <strong>external variable</strong> can additionally be declared inside a function that uses it by using the <code>extern</code> keyword. </p>
<p>If a particular <strong>external variable</strong> is <strong>defined in one source code file</strong> and is <strong>used in a second source code file</strong>, <strong>declaring</strong> the variable in the second file with <code>extern</code> is mandatory. <strong>Declarations</strong> look like this:</p>
<pre><code class="hljs c"><span class="hljs-keyword">int</span> Errupt; <span class="hljs-comment">/* externally defined variable */</span>
<span class="hljs-keyword">double</span> Up[<span class="hljs-number">100</span>]; <span class="hljs-comment">/* externally defined array */</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> Coal; <span class="hljs-comment">/* mandatory declaration if */</span>
<span class="hljs-comment">/* Coal defined in another file */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> Errupt; <span class="hljs-comment">/* optional declaration */</span>
    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> Up[]; <span class="hljs-comment">/* optional declaration */</span>
    ...
&#125;</code></pre>
<p>Unlike <strong>automatic variables</strong>, <strong>external variables</strong> are <strong>initialized automatically to zero</strong> if you don’t <strong>initialize</strong> them. </p>
<p>This rule applies to elements of an <strong>externally defined array</strong>, too. Unlike the case for <strong>automatic variables</strong>, you can use <strong>only constant expressions</strong> to <strong>initialize file scope variables</strong>:</p>
<pre><code class="hljs c"><span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// ok, 10 is constant</span>
<span class="hljs-keyword">int</span> y = <span class="hljs-number">3</span> + <span class="hljs-number">20</span>; <span class="hljs-comment">// ok, a constant expression</span>
<span class="hljs-keyword">size_t</span> z = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>); <span class="hljs-comment">// ok, a constant expression</span>
<span class="hljs-keyword">int</span> x2 = <span class="hljs-number">2</span> * x; <span class="hljs-comment">// not ok, x is a variable</span></code></pre>
<p>(As long as the type is not a variable array, a sizeof expression is considered a constant<br>expression.)</p>
<pre><code class="hljs c"><span class="hljs-keyword">int</span> tern = <span class="hljs-number">1</span>; <span class="hljs-comment">/* tern defined */</span>
main()
&#123;
    external <span class="hljs-keyword">int</span> tern; <span class="hljs-comment">/* use a tern defined elsewhere */</span>
    ...
&#125;</code></pre>
<p>Here, <code>tern</code> is <strong>declared</strong> twice. The <strong>first declaration</strong> causes <strong>storage to be set aside</strong> for the variable. It constitutes a <strong>definition</strong> of the variable. </p>
<p>The <strong>second declaration</strong> merely tells the compiler to use the <code>tern</code> variable that <strong>has been created previously</strong>, so it is <strong>not a definition</strong>. </p>
<p>The first declaration is called a <strong>defining declaration</strong>, and the <strong>second</strong> is called a <strong>referencing declaration</strong>. </p>
<p>The keyword <code>extern</code> indicates that a <strong>declaration is not a definition</strong> because it instructs the compiler to look elsewhere.</p>
<p>Suppose you do this:</p>
<pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> tern;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    ...
&#125;</code></pre>
<p>The <strong>compiler</strong> will assume that the <strong>actual definition</strong> of <code>tern</code> is somewhere else in your program, perhaps in another file. This declaration <strong>does not cause space to be allocated</strong>. </p>
<p>Therefore, don’tuse the keyword <code>extern</code> to create an <strong>external definition</strong>; use it only to <strong>refer to an existing external definition</strong>.</p>
<p>An <strong>external variable</strong> can be <strong>initialized only once</strong>, and that must occur when the variable is defined. </p>
<pre><code class="hljs c"><span class="hljs-comment">// file one.c</span>
<span class="hljs-keyword">char</span> permis = <span class="hljs-string">'N'</span>;
...
<span class="hljs-comment">// file two.c</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> permis = <span class="hljs-string">'Y'</span>; <span class="hljs-comment">/* error */</span></code></pre>
<p>This is an <strong>error</strong> because the defining declaration in <code>file_one.c</code> already has created and i<strong>nitialized</strong> permis.</p>
<h2 id="8-Static-Variables-with-Internal-Linkage"><a href="#8-Static-Variables-with-Internal-Linkage" class="headerlink" title="(8) Static Variables with Internal Linkage"></a>(8) Static Variables with Internal Linkage</h2><p>Variables of this <strong>storage class</strong> have <strong>static storage duration</strong>, <strong>file scope</strong>, and <strong>internal linkage</strong>. </p>
<p>You create one by <strong>defining it outside of any function</strong> (just as with an external variable) with the storage class specifier <code>static</code>:</p>
<pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> svil = <span class="hljs-number">1</span>; <span class="hljs-comment">// static variable, internal linkage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    ...
&#125;</code></pre>
<p><strong>Static variable with internal linkage</strong> can be used only by functions <strong>in the same file</strong>. </p>
<h1 id="2-A-Random-Number-Function-and-a-Static-Variable"><a href="#2-A-Random-Number-Function-and-a-Static-Variable" class="headerlink" title="2. A Random-Number Function and a Static Variable"></a>2. A Random-Number Function and a Static Variable</h1><p>The <strong>ANSI C library</strong> provides the <strong>rand()</strong> function to <strong>generate random numbers</strong>. There are a variety of algorithms for generating random numbers, and <strong>ANSI C</strong> enables implementations to use the best algorithm for a particular machine. </p>
<p>Actually, rand() is a “<strong>pseudorandom number generator</strong>“, meaning that the actual sequence of numbers is predictable.</p>
<p>The scheme starts with a number called the “<strong>seed</strong>“. The function uses the seed to produce a new number, which becomes the new seed. Then the new seed can be used to produce a newer seed, and so on. </p>
<p>For this scheme to work, the random-number function must remember the seed it used the <strong>last time it was called</strong>. </p>
<pre><code class="hljs c"><span class="hljs-comment">/* s_and_r.c -- file for rand1() and srand1() */</span>
<span class="hljs-comment">/* uses ANSI C portable algorithm */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> next = <span class="hljs-number">1</span>; <span class="hljs-comment">/* the seed */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">/* magic formula to generate pseudorandom number */</span>
    next = next * <span class="hljs-number">1103515245</span> + <span class="hljs-number">12345</span>;
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) (next/<span class="hljs-number">65536</span>) % <span class="hljs-number">32768</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">srand1</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> seed)</span></span>
<span class="hljs-function"></span>&#123;
    next = seed;
&#125;</code></pre>
<pre><code class="hljs c"><span class="hljs-comment">/* r_drive1.c -- test rand1() and srand1() */</span>
<span class="hljs-comment">/* compile with s_and_r.c */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rand0</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">//外部函数</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> count;
    <span class="hljs-keyword">unsigned</span> seed;
    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Please enter your choice for seed."</span>);
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%u"</span>,&amp;seed) == <span class="hljs-number">1</span>)
    &#123;
       srand1(seed);
       <span class="hljs-keyword">for</span>(count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">5</span>; count++)
       <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,rand1());
       <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Please enter next seed (q to quit):"</span>);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<h1 id="3-Allocated-Memory"><a href="#3-Allocated-Memory" class="headerlink" title="3. Allocated Memory"></a>3. Allocated Memory</h1><h2 id="1-malloc-and-free"><a href="#1-malloc-and-free" class="headerlink" title="(1) malloc() and free()"></a>(1) malloc() and free()</h2><p><strong>Static data</strong>, is <strong>allocated</strong> when the program is <strong>loaded into memory</strong>, and <strong>automatic data</strong> is <strong>allocated</strong> when program execution <strong>enters a block</strong> and <strong>deallocated</strong> when execution leaves the block.</p>
<p>C goes beyond this. You can allocate more memory as a program runs. The main tool is the <strong>malloc()</strong> function, which takes one argument: *<em>the number of bytes of memory *</em>you want.</p>
<p>Then <strong>malloc()</strong> finds a <strong>suitable block of free memory</strong>. The memory is <strong>anonymous</strong>; that is, <strong>malloc()</strong> allocates memory but it <strong>doesn’t assign a name</strong> to it. </p>
<p>It does <strong>return the address of the first byte of that block</strong>. </p>
<p>Therefore, you can assign that address to a pointer variable and use the pointer to access the memory. Because char represents a byte, <strong>malloc()</strong> has traditionally been defined as type <strong>pointer-to-char</strong>. </p>
<p>Since the ANSI C standard, however, C uses a new type: <strong>pointer-to-void</strong>. This type is intended to be a “<strong>generic pointer</strong>“. </p>
<p>The <strong>malloc()</strong> function can be used to return pointers to arrays, structures, and so forth, so normally the return value is <strong>typecast</strong> to the proper value. Under ANSI C, you should still <strong>typecast</strong> for clarity, but assigning a <strong>pointer-to-void</strong> value to a <strong>pointer of another type</strong> is not considered a <strong>type clash</strong>. </p>
<p>If <strong>malloc()</strong> fails to find the required space, it returns the <strong>null pointer</strong>.</p>
<pre><code class="hljs c"><span class="hljs-keyword">double</span> * ptd;
ptd = (<span class="hljs-keyword">double</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">30</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>));</code></pre>
<p>This code requests space for <strong>30 type double values</strong> and sets <code>ptd</code> to <strong>point to the location</strong>. </p>
<p>Note that <code>ptd</code> is declared as a <strong>pointer to a single double</strong> and <strong>not to a block of 30 double values</strong>.</p>
<p>You now have <strong>three ways to create an array</strong>:</p>
<ul>
<li>Declare an array using <strong>constant expressions</strong> for the array dimensions and use the array name to access elements. Such an array can be created using either <strong>static or automatic</strong> memory.</li>
<li>Declare a <strong>variable-length array</strong> using variable expressions for the array dimensions and use the array name to access elements. (Recall that this is a C99 feature.) This feature is available only for <strong>automatic memory</strong>.</li>
<li>Declare a <strong>pointer</strong>, call <strong>malloc()</strong>, assign the <strong>return value</strong> to the <strong>pointer</strong>, and use the <strong>pointer</strong> to access elements. The pointer can be <strong>either static or automatic</strong>.</li>
</ul>
<p>You can use the second and third methods to do something you can’t do with an ordinary declared array—create a <strong>dynamic array</strong>, one that’s allocated while the program runs and that you can choose a size for while the program runs. </p>
<p>Normally, you should balance each use of <strong>malloc()</strong> with a use of <strong>free()</strong>. The <strong>free()</strong> function takes as its argument an address returned earlier by <strong>malloc()</strong> and <strong>frees up the memory</strong> that had been allocated.</p>
<p>Thus, the <strong>duration of allocated memory</strong> is from when <strong>malloc()</strong> is called to allocate the memory until <strong>free()</strong> is called to free up the memory so that it can be reused. Think of <strong>malloc()</strong> and <strong>free()</strong> as managing a pool of memory. </p>
<p>The argument to <strong>free()</strong> should be a pointer to a block of memory allocated by <strong>malloc()</strong>.</p>
<p>Both <strong>malloc()</strong> and <strong>free()</strong> have prototypes in the <code>stdlib.h</code> header file.</p>
<p>The <strong>free()</strong> function frees only the block of memory to which its argument points. Some operating systems will free allocated memory automatically when a program finishes, but others may not.</p>
<h2 id="2-The-calloc-Function"><a href="#2-The-calloc-Function" class="headerlink" title="(2) The calloc() Function"></a>(2) The calloc() Function</h2><p>Another option for <strong>memory allotment</strong> is to use <strong>calloc()</strong>. A typical use looks like this:</p>
<pre><code class="hljs c"><span class="hljs-keyword">long</span> * newmem;
newmem = (<span class="hljs-keyword">long</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">100</span>, <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">long</span>));</code></pre>
<p>Like <strong>malloc()</strong>, <strong>calloc()</strong> returns a <strong>pointer-to-char</strong> in its <strong>pre-ANSI</strong> version and a pointer-to void under <strong>ANSI</strong>. You should use the <strong>cast operator</strong> if you want to store a different type. </p>
<p>This new function takes two arguments, both of which should be <strong>unsigned integers</strong> (type <strong>size_t</strong> since ANSI). The first argument is the <strong>number of memory cells</strong> you want. The second argument<br>is the <strong>size of each cell</strong> in <strong>bytes</strong>. </p>
<p>The <strong>calloc()</strong> function sets all the bits in the block to <strong>zero</strong>. (Note, however, that on some hardware systems, a floating-point value of <strong>0</strong> is not represented by all bits set to <strong>0</strong>.)</p>
<p>The <strong>free()</strong> function can also be used to <strong>free memory</strong> allocated by <strong>calloc()</strong>.</p>
<h2 id="3-Dynamic-Memory-Allocation-and-Variable-Length-Arrays"><a href="#3-Dynamic-Memory-Allocation-and-Variable-Length-Arrays" class="headerlink" title="(3) Dynamic Memory Allocation and Variable-Length Arrays"></a>(3) Dynamic Memory Allocation and Variable-Length Arrays</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vlamal</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">int</span> * pi;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);
    pi = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">int</span> ar[n]; <span class="hljs-comment">// vla</span>
    pi[<span class="hljs-number">2</span>] = ar[<span class="hljs-number">2</span>] = <span class="hljs-number">-5</span>;
    ...
&#125;</code></pre>
<pre><code class="hljs c"><span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> m = <span class="hljs-number">6</span>;
<span class="hljs-keyword">int</span> ar2[n][m]; <span class="hljs-comment">// n x m VLA</span>
<span class="hljs-keyword">int</span> (* p2)[<span class="hljs-number">6</span>]; <span class="hljs-comment">// works pre-C99</span>
<span class="hljs-keyword">int</span> (* p3)[m]; <span class="hljs-comment">// requires VLA support</span>
p2 = (<span class="hljs-keyword">int</span> (*)[<span class="hljs-number">6</span>]) <span class="hljs-built_in">malloc</span>(n * <span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)); <span class="hljs-comment">// n * 6 array</span>
p3 = (<span class="hljs-keyword">int</span> (*)[m]) <span class="hljs-built_in">malloc</span>(n * m * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)); <span class="hljs-comment">// n * m array</span>
<span class="hljs-comment">// above expression also requires VLA support</span>
ar2[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = p2[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">12</span>;</code></pre>
<h2 id="4-Storage-Classes-and-Dynamic-Memory-Allocation"><a href="#4-Storage-Classes-and-Dynamic-Memory-Allocation" class="headerlink" title="(4) Storage Classes and Dynamic Memory Allocation"></a>(4) Storage Classes and Dynamic Memory Allocation</h2><p>You can think of a program as dividing its available memory into <strong>three separate sections</strong>: one for static variables with external linkage, internal linkage, and no linkage; one for automatic variables; and one for dynamically allocated memory.</p>
<p>The <strong>amount of memory</strong> needed for the <strong>static duration storage classes</strong> is known <strong>at compile time</strong>, and the data stored in this section is available as long as the program runs. Each variable of these classes comes into being when the program starts and expires when the program ends.</p>
<p>An <strong>automatic variable</strong>, however, comes into existence when a program <strong>enters the block</strong> of code containing the <strong>variable’s definition</strong> and expires when its <strong>block of code is exited</strong>. Therefore, as a<br>program calls functions and as functions terminate, the amount of memory used by automatic variables grows and shrinks. This section of memory is typically <strong>handled as a stack</strong>. That means new variables are added sequentially in memory as they are created and then are removed in the <strong>opposite order as they pass away</strong>.</p>
<p><strong>Dynamically allocated memory</strong> comes into existence when <strong>malloc()</strong> or a related function is called, and it’s freed when <strong>free() is called</strong>. Memory persistence is controlled by the programmer, not by a set of rigid rules, so a memory block can be created in one function and disposed of in another function. Because of this, the section of memory used for dynamic memory allocation can end up fragmented—that is, <strong>unused chunks could be interspersed among active blocks of memory</strong>. Also, using dynamic memory tends to be a <strong>slower process than using stack memory</strong>.</p>
<p>Typically, a program uses <strong>different regions of memory</strong> for static objects, automatic objects, and<br>dynamically allocated objects. </p>
<h1 id="4-ANSI-C-Type-Qualifiers"><a href="#4-ANSI-C-Type-Qualifiers" class="headerlink" title="4. ANSI C Type Qualifiers"></a>4. ANSI C Type Qualifiers</h1><h2 id="1-The-const-Type-Qualifier"><a href="#1-The-const-Type-Qualifier" class="headerlink" title="(1) The const Type Qualifier"></a>(1) The const Type Qualifier</h2><p>The <strong>const</strong> keyword in a declaration establishes a variable whose value <strong>cannot be modified</strong> by assignment or by incrementing or decrementing. </p>
<h2 id="2-The-volatile-Type-Qualifier"><a href="#2-The-volatile-Type-Qualifier" class="headerlink" title="(2) The volatile Type Qualifier"></a>(2) The volatile Type Qualifier</h2><p>The <strong>volatile</strong> qualifier tells the compiler that a variable can have its value <strong>altered by agencies</strong> other than the program. </p>
<p>It is typically used for hardware addresses and for data shared with other programs or threads running simultaneously. </p>
<p>For example, an address might hold the current clock time. The value at that address changes as time changes, regardless of what your program is doing. Or an address could be used to receive information transmitted from, say, another computer.</p>
<p>The syntax is the same as for const:</p>
<pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> loc1; <span class="hljs-comment">/* loc1 is a volatile location */</span>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> * ploc; <span class="hljs-comment">/* ploc points to a volatile location */</span></code></pre>
<p>These statements declare <code>loc1</code> to be a <strong>volatile</strong> value and <code>ploc</code> to <strong>point to a volatile</strong> value.</p>
<p><strong>volatile</strong> facilitates compiler optimization. </p>
<h2 id="3-The-restrict-Type-Qualifier"><a href="#3-The-restrict-Type-Qualifier" class="headerlink" title="(3) The restrict Type Qualifier"></a>(3) The restrict Type Qualifier</h2><p>The <strong>restrict</strong> keyword enhances computational support by giving the compiler permission to optimize certain kinds of code. </p>
<p>It can be applied only to <strong>pointers</strong>, and it indicates that a <strong>pointer</strong> is the <strong>sole initial means</strong> of accessing a data object. </p>
<pre><code class="hljs c"><span class="hljs-keyword">int</span> ar[<span class="hljs-number">10</span>];
<span class="hljs-keyword">int</span> * <span class="hljs-keyword">restrict</span> restar = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
<span class="hljs-keyword">int</span> * par = ar;</code></pre>
<p>Here, the pointer <code>restar</code> is the sole initial means of access to the memory allocated by <strong>malloc()</strong>. Therefore, it can be qualified with the keyword <strong>restrict</strong>. The pointer <code>par</code>, however, is neither the initial nor the sole means of access to the data in the ar array, so it cannot be qualified as <strong>restrict</strong>.</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/C/">C</a>
                    
                      <a class="hover-with-bg" href="/categories/C/C-Primer-Plus/">C Primer Plus</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C</a>
                    
                      <a class="hover-with-bg" href="/tags/C-Primer-Plus/">C Primer Plus</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/01/Character-Strings-and-String-Functions/">
                        <span class="hidden-mobile">Character Strings and String Functions</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  
    <!-- APlayer 音乐播放器 -->
    <div id="aplayer"></div>
    <script defer src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js" ></script>
<link  rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
<script type="text/javascript">
  var oldLoadAp = window.onload;
  window.onload = function () {
    oldLoadAp && oldLoadAp();

    new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      autoplay: 'false' === 'true',
      loop: 'all',
      order: 'random',
      theme: '#58C9B9',
      preload: 'none',
      audio: [{"name":"Bang Bang","artist":"Nancy Sinatra","url":"/music/songs/Bang Bang.mp3","cover":"/music/cover/Bang Bang.jpg","lrc":"/music/lyrics/Bang Bang.lrc"},{"name":"Silhouettes Of You","artist":"Isaac Gracie","url":"/music/songs/Silhouettes Of You.mp3","cover":"/music/cover/Silhouettes Of You.jpg","lrc":"/music/lyrics/Silhouettes Of You.lrc"},{"name":"Mad World","artist":"Adam Lambert","url":"/music/songs/Mad World.mp3","cover":"/music/cover/Mad World.jpg","lrc":"/music/lyrics/Mad World.lrc"},{"name":"Señorita","artist":"Shawn Mendes Camila Cabello","url":"/music/songs/Señorita.mp3","cover":"/music/cover/Señorita.jpg","lrc":"/music/lyrics/Señorita.lrc"},{"name":"Issues","artist":"Julia Michaels","url":"/music/songs/Issues.mp3","cover":"/music/cover/Issues.jpg","lrc":"/music/lyrics/Issues.lrc"},{"name":"Mystery of Love","artist":"Sufjan Stevens","url":"/music/songs/Mystery of Love.mp3","cover":"/music/cover/Mystery of Love.jpg","lrc":"/music/lyrics/Mystery of Love.lrc"},{"name":"Bad Things","artist":"Machine Gun Kelly Camila Cabello","url":"/music/songs/Bad Things.mp3","cover":"/music/cover/Bad Things.jpg","lrc":"/music/lyrics/Bad Things.lrc"},{"name":"小夜曲","artist":"Franz Schubert","url":"/music/songs/小夜曲.mp3","cover":"/music/cover/小夜曲.jpg"}]
    });
  }
</script>

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Storage Classes, Linkage, and Memory Management&nbsp;",
      ],
      cursorChar: " ",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script>
      !function (e, t, a) {
        function r() {
          for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
          requestAnimationFrame(r)
        }

        function n() {
          var t = "function" == typeof e.onclick && e.onclick;
          e.onclick = function (e) {
            t && t(), o(e)
          }
        }

        function o(e) {
          var a = t.createElement("div");
          a.className = "heart", s.push({
            el: a,
            x: e.clientX - 5,
            y: e.clientY - 5,
            scale: 1,
            alpha: 1,
            color: c()
          }), t.body.appendChild(a)
        }

        function i(e) {
          var a = t.createElement("style");
          a.type = "text/css";
          try {
            a.appendChild(t.createTextNode(e))
          } catch (t) {
            a.styleSheet.cssText = e
          }
          t.getElementsByTagName("head")[0].appendChild(a)
        }

        function c() {
          return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
        }

        var s = [];
        e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {
          setTimeout(e, 1e3 / 60)
        }, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()
      }(window, document);
    </script>
  














</body>
</html>
